// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: prediction/network_layers.proto

#ifndef PROTOBUF_prediction_2fnetwork_5flayers_2eproto__INCLUDED
#define PROTOBUF_prediction_2fnetwork_5flayers_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace apollo {
namespace prediction {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_prediction_2fnetwork_5flayers_2eproto();
void protobuf_AssignDesc_prediction_2fnetwork_5flayers_2eproto();
void protobuf_ShutdownFile_prediction_2fnetwork_5flayers_2eproto();

class ActivationParameter;
class BatchNormalizationParameter;
class ConcatenateParameter;
class DenseParameter;
class FlattenParameter;
class InputParameter;
class LSTMParameter;
class LayerParameter;
class TensorParameter;

// ===================================================================

class TensorParameter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.prediction.TensorParameter) */ {
 public:
  TensorParameter();
  virtual ~TensorParameter();

  TensorParameter(const TensorParameter& from);

  inline TensorParameter& operator=(const TensorParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TensorParameter& default_instance();

  void Swap(TensorParameter* other);

  // implements Message ----------------------------------------------

  inline TensorParameter* New() const { return New(NULL); }

  TensorParameter* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TensorParameter& from);
  void MergeFrom(const TensorParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TensorParameter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float data = 1 [packed = true];
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  float data(int index) const;
  void set_data(int index, float value);
  void add_data(float value);
  const ::google::protobuf::RepeatedField< float >&
      data() const;
  ::google::protobuf::RepeatedField< float >*
      mutable_data();

  // repeated int32 shape = 2;
  int shape_size() const;
  void clear_shape();
  static const int kShapeFieldNumber = 2;
  ::google::protobuf::int32 shape(int index) const;
  void set_shape(int index, ::google::protobuf::int32 value);
  void add_shape(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      shape() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_shape();

  // @@protoc_insertion_point(class_scope:apollo.prediction.TensorParameter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > data_;
  mutable int _data_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > shape_;
  friend void  protobuf_AddDesc_prediction_2fnetwork_5flayers_2eproto();
  friend void protobuf_AssignDesc_prediction_2fnetwork_5flayers_2eproto();
  friend void protobuf_ShutdownFile_prediction_2fnetwork_5flayers_2eproto();

  void InitAsDefaultInstance();
  static TensorParameter* default_instance_;
};
// -------------------------------------------------------------------

class InputParameter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.prediction.InputParameter) */ {
 public:
  InputParameter();
  virtual ~InputParameter();

  InputParameter(const InputParameter& from);

  inline InputParameter& operator=(const InputParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InputParameter& default_instance();

  void Swap(InputParameter* other);

  // implements Message ----------------------------------------------

  inline InputParameter* New() const { return New(NULL); }

  InputParameter* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InputParameter& from);
  void MergeFrom(const InputParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InputParameter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 input_shape = 1;
  int input_shape_size() const;
  void clear_input_shape();
  static const int kInputShapeFieldNumber = 1;
  ::google::protobuf::int32 input_shape(int index) const;
  void set_input_shape(int index, ::google::protobuf::int32 value);
  void add_input_shape(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      input_shape() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_input_shape();

  // optional string dtype = 2;
  bool has_dtype() const;
  void clear_dtype();
  static const int kDtypeFieldNumber = 2;
  const ::std::string& dtype() const;
  void set_dtype(const ::std::string& value);
  void set_dtype(const char* value);
  void set_dtype(const char* value, size_t size);
  ::std::string* mutable_dtype();
  ::std::string* release_dtype();
  void set_allocated_dtype(::std::string* dtype);

  // optional bool sparse = 3;
  bool has_sparse() const;
  void clear_sparse();
  static const int kSparseFieldNumber = 3;
  bool sparse() const;
  void set_sparse(bool value);

  // @@protoc_insertion_point(class_scope:apollo.prediction.InputParameter)
 private:
  inline void set_has_dtype();
  inline void clear_has_dtype();
  inline void set_has_sparse();
  inline void clear_has_sparse();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > input_shape_;
  ::google::protobuf::internal::ArenaStringPtr dtype_;
  bool sparse_;
  friend void  protobuf_AddDesc_prediction_2fnetwork_5flayers_2eproto();
  friend void protobuf_AssignDesc_prediction_2fnetwork_5flayers_2eproto();
  friend void protobuf_ShutdownFile_prediction_2fnetwork_5flayers_2eproto();

  void InitAsDefaultInstance();
  static InputParameter* default_instance_;
};
// -------------------------------------------------------------------

class DenseParameter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.prediction.DenseParameter) */ {
 public:
  DenseParameter();
  virtual ~DenseParameter();

  DenseParameter(const DenseParameter& from);

  inline DenseParameter& operator=(const DenseParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DenseParameter& default_instance();

  void Swap(DenseParameter* other);

  // implements Message ----------------------------------------------

  inline DenseParameter* New() const { return New(NULL); }

  DenseParameter* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DenseParameter& from);
  void MergeFrom(const DenseParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DenseParameter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 units = 1;
  bool has_units() const;
  void clear_units();
  static const int kUnitsFieldNumber = 1;
  ::google::protobuf::int32 units() const;
  void set_units(::google::protobuf::int32 value);

  // optional string activation = 2;
  bool has_activation() const;
  void clear_activation();
  static const int kActivationFieldNumber = 2;
  const ::std::string& activation() const;
  void set_activation(const ::std::string& value);
  void set_activation(const char* value);
  void set_activation(const char* value, size_t size);
  ::std::string* mutable_activation();
  ::std::string* release_activation();
  void set_allocated_activation(::std::string* activation);

  // optional bool use_bias = 3;
  bool has_use_bias() const;
  void clear_use_bias();
  static const int kUseBiasFieldNumber = 3;
  bool use_bias() const;
  void set_use_bias(bool value);

  // optional .apollo.prediction.TensorParameter weights = 4;
  bool has_weights() const;
  void clear_weights();
  static const int kWeightsFieldNumber = 4;
  const ::apollo::prediction::TensorParameter& weights() const;
  ::apollo::prediction::TensorParameter* mutable_weights();
  ::apollo::prediction::TensorParameter* release_weights();
  void set_allocated_weights(::apollo::prediction::TensorParameter* weights);

  // optional .apollo.prediction.TensorParameter bias = 5;
  bool has_bias() const;
  void clear_bias();
  static const int kBiasFieldNumber = 5;
  const ::apollo::prediction::TensorParameter& bias() const;
  ::apollo::prediction::TensorParameter* mutable_bias();
  ::apollo::prediction::TensorParameter* release_bias();
  void set_allocated_bias(::apollo::prediction::TensorParameter* bias);

  // @@protoc_insertion_point(class_scope:apollo.prediction.DenseParameter)
 private:
  inline void set_has_units();
  inline void clear_has_units();
  inline void set_has_activation();
  inline void clear_has_activation();
  inline void set_has_use_bias();
  inline void clear_has_use_bias();
  inline void set_has_weights();
  inline void clear_has_weights();
  inline void set_has_bias();
  inline void clear_has_bias();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr activation_;
  ::google::protobuf::int32 units_;
  bool use_bias_;
  ::apollo::prediction::TensorParameter* weights_;
  ::apollo::prediction::TensorParameter* bias_;
  friend void  protobuf_AddDesc_prediction_2fnetwork_5flayers_2eproto();
  friend void protobuf_AssignDesc_prediction_2fnetwork_5flayers_2eproto();
  friend void protobuf_ShutdownFile_prediction_2fnetwork_5flayers_2eproto();

  void InitAsDefaultInstance();
  static DenseParameter* default_instance_;
};
// -------------------------------------------------------------------

class BatchNormalizationParameter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.prediction.BatchNormalizationParameter) */ {
 public:
  BatchNormalizationParameter();
  virtual ~BatchNormalizationParameter();

  BatchNormalizationParameter(const BatchNormalizationParameter& from);

  inline BatchNormalizationParameter& operator=(const BatchNormalizationParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BatchNormalizationParameter& default_instance();

  void Swap(BatchNormalizationParameter* other);

  // implements Message ----------------------------------------------

  inline BatchNormalizationParameter* New() const { return New(NULL); }

  BatchNormalizationParameter* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BatchNormalizationParameter& from);
  void MergeFrom(const BatchNormalizationParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BatchNormalizationParameter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double epsilon = 1 [default = 1e-05];
  bool has_epsilon() const;
  void clear_epsilon();
  static const int kEpsilonFieldNumber = 1;
  double epsilon() const;
  void set_epsilon(double value);

  // optional int32 axis = 2;
  bool has_axis() const;
  void clear_axis();
  static const int kAxisFieldNumber = 2;
  ::google::protobuf::int32 axis() const;
  void set_axis(::google::protobuf::int32 value);

  // optional bool center = 3;
  bool has_center() const;
  void clear_center();
  static const int kCenterFieldNumber = 3;
  bool center() const;
  void set_center(bool value);

  // optional bool scale = 4;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 4;
  bool scale() const;
  void set_scale(bool value);

  // optional float momentum = 5;
  bool has_momentum() const;
  void clear_momentum();
  static const int kMomentumFieldNumber = 5;
  float momentum() const;
  void set_momentum(float value);

  // optional .apollo.prediction.TensorParameter mu = 6;
  bool has_mu() const;
  void clear_mu();
  static const int kMuFieldNumber = 6;
  const ::apollo::prediction::TensorParameter& mu() const;
  ::apollo::prediction::TensorParameter* mutable_mu();
  ::apollo::prediction::TensorParameter* release_mu();
  void set_allocated_mu(::apollo::prediction::TensorParameter* mu);

  // optional .apollo.prediction.TensorParameter sigma = 7;
  bool has_sigma() const;
  void clear_sigma();
  static const int kSigmaFieldNumber = 7;
  const ::apollo::prediction::TensorParameter& sigma() const;
  ::apollo::prediction::TensorParameter* mutable_sigma();
  ::apollo::prediction::TensorParameter* release_sigma();
  void set_allocated_sigma(::apollo::prediction::TensorParameter* sigma);

  // optional .apollo.prediction.TensorParameter gamma = 8;
  bool has_gamma() const;
  void clear_gamma();
  static const int kGammaFieldNumber = 8;
  const ::apollo::prediction::TensorParameter& gamma() const;
  ::apollo::prediction::TensorParameter* mutable_gamma();
  ::apollo::prediction::TensorParameter* release_gamma();
  void set_allocated_gamma(::apollo::prediction::TensorParameter* gamma);

  // optional .apollo.prediction.TensorParameter beta = 9;
  bool has_beta() const;
  void clear_beta();
  static const int kBetaFieldNumber = 9;
  const ::apollo::prediction::TensorParameter& beta() const;
  ::apollo::prediction::TensorParameter* mutable_beta();
  ::apollo::prediction::TensorParameter* release_beta();
  void set_allocated_beta(::apollo::prediction::TensorParameter* beta);

  // @@protoc_insertion_point(class_scope:apollo.prediction.BatchNormalizationParameter)
 private:
  inline void set_has_epsilon();
  inline void clear_has_epsilon();
  inline void set_has_axis();
  inline void clear_has_axis();
  inline void set_has_center();
  inline void clear_has_center();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_momentum();
  inline void clear_has_momentum();
  inline void set_has_mu();
  inline void clear_has_mu();
  inline void set_has_sigma();
  inline void clear_has_sigma();
  inline void set_has_gamma();
  inline void clear_has_gamma();
  inline void set_has_beta();
  inline void clear_has_beta();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double epsilon_;
  ::google::protobuf::int32 axis_;
  bool center_;
  bool scale_;
  ::apollo::prediction::TensorParameter* mu_;
  ::apollo::prediction::TensorParameter* sigma_;
  ::apollo::prediction::TensorParameter* gamma_;
  ::apollo::prediction::TensorParameter* beta_;
  float momentum_;
  friend void  protobuf_AddDesc_prediction_2fnetwork_5flayers_2eproto();
  friend void protobuf_AssignDesc_prediction_2fnetwork_5flayers_2eproto();
  friend void protobuf_ShutdownFile_prediction_2fnetwork_5flayers_2eproto();

  void InitAsDefaultInstance();
  static BatchNormalizationParameter* default_instance_;
};
// -------------------------------------------------------------------

class LSTMParameter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.prediction.LSTMParameter) */ {
 public:
  LSTMParameter();
  virtual ~LSTMParameter();

  LSTMParameter(const LSTMParameter& from);

  inline LSTMParameter& operator=(const LSTMParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LSTMParameter& default_instance();

  void Swap(LSTMParameter* other);

  // implements Message ----------------------------------------------

  inline LSTMParameter* New() const { return New(NULL); }

  LSTMParameter* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LSTMParameter& from);
  void MergeFrom(const LSTMParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LSTMParameter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 units = 1;
  bool has_units() const;
  void clear_units();
  static const int kUnitsFieldNumber = 1;
  ::google::protobuf::int32 units() const;
  void set_units(::google::protobuf::int32 value);

  // optional bool return_sequences = 2;
  bool has_return_sequences() const;
  void clear_return_sequences();
  static const int kReturnSequencesFieldNumber = 2;
  bool return_sequences() const;
  void set_return_sequences(bool value);

  // optional bool stateful = 3;
  bool has_stateful() const;
  void clear_stateful();
  static const int kStatefulFieldNumber = 3;
  bool stateful() const;
  void set_stateful(bool value);

  // optional string activation = 4;
  bool has_activation() const;
  void clear_activation();
  static const int kActivationFieldNumber = 4;
  const ::std::string& activation() const;
  void set_activation(const ::std::string& value);
  void set_activation(const char* value);
  void set_activation(const char* value, size_t size);
  ::std::string* mutable_activation();
  ::std::string* release_activation();
  void set_allocated_activation(::std::string* activation);

  // optional string recurrent_activation = 5;
  bool has_recurrent_activation() const;
  void clear_recurrent_activation();
  static const int kRecurrentActivationFieldNumber = 5;
  const ::std::string& recurrent_activation() const;
  void set_recurrent_activation(const ::std::string& value);
  void set_recurrent_activation(const char* value);
  void set_recurrent_activation(const char* value, size_t size);
  ::std::string* mutable_recurrent_activation();
  ::std::string* release_recurrent_activation();
  void set_allocated_recurrent_activation(::std::string* recurrent_activation);

  // optional bool use_bias = 6;
  bool has_use_bias() const;
  void clear_use_bias();
  static const int kUseBiasFieldNumber = 6;
  bool use_bias() const;
  void set_use_bias(bool value);

  // optional bool unit_forget_bias = 7 [default = true];
  bool has_unit_forget_bias() const;
  void clear_unit_forget_bias();
  static const int kUnitForgetBiasFieldNumber = 7;
  bool unit_forget_bias() const;
  void set_unit_forget_bias(bool value);

  // optional bool go_backwards = 8 [default = false];
  bool has_go_backwards() const;
  void clear_go_backwards();
  static const int kGoBackwardsFieldNumber = 8;
  bool go_backwards() const;
  void set_go_backwards(bool value);

  // optional bool unroll = 9 [default = false];
  bool has_unroll() const;
  void clear_unroll();
  static const int kUnrollFieldNumber = 9;
  bool unroll() const;
  void set_unroll(bool value);

  // optional int32 implementation = 10 [default = 0];
  bool has_implementation() const;
  void clear_implementation();
  static const int kImplementationFieldNumber = 10;
  ::google::protobuf::int32 implementation() const;
  void set_implementation(::google::protobuf::int32 value);

  // optional .apollo.prediction.TensorParameter weights_input = 15;
  bool has_weights_input() const;
  void clear_weights_input();
  static const int kWeightsInputFieldNumber = 15;
  const ::apollo::prediction::TensorParameter& weights_input() const;
  ::apollo::prediction::TensorParameter* mutable_weights_input();
  ::apollo::prediction::TensorParameter* release_weights_input();
  void set_allocated_weights_input(::apollo::prediction::TensorParameter* weights_input);

  // optional .apollo.prediction.TensorParameter weights_forget = 16;
  bool has_weights_forget() const;
  void clear_weights_forget();
  static const int kWeightsForgetFieldNumber = 16;
  const ::apollo::prediction::TensorParameter& weights_forget() const;
  ::apollo::prediction::TensorParameter* mutable_weights_forget();
  ::apollo::prediction::TensorParameter* release_weights_forget();
  void set_allocated_weights_forget(::apollo::prediction::TensorParameter* weights_forget);

  // optional .apollo.prediction.TensorParameter weights_cell = 17;
  bool has_weights_cell() const;
  void clear_weights_cell();
  static const int kWeightsCellFieldNumber = 17;
  const ::apollo::prediction::TensorParameter& weights_cell() const;
  ::apollo::prediction::TensorParameter* mutable_weights_cell();
  ::apollo::prediction::TensorParameter* release_weights_cell();
  void set_allocated_weights_cell(::apollo::prediction::TensorParameter* weights_cell);

  // optional .apollo.prediction.TensorParameter weights_output = 18;
  bool has_weights_output() const;
  void clear_weights_output();
  static const int kWeightsOutputFieldNumber = 18;
  const ::apollo::prediction::TensorParameter& weights_output() const;
  ::apollo::prediction::TensorParameter* mutable_weights_output();
  ::apollo::prediction::TensorParameter* release_weights_output();
  void set_allocated_weights_output(::apollo::prediction::TensorParameter* weights_output);

  // optional .apollo.prediction.TensorParameter bias_input = 19;
  bool has_bias_input() const;
  void clear_bias_input();
  static const int kBiasInputFieldNumber = 19;
  const ::apollo::prediction::TensorParameter& bias_input() const;
  ::apollo::prediction::TensorParameter* mutable_bias_input();
  ::apollo::prediction::TensorParameter* release_bias_input();
  void set_allocated_bias_input(::apollo::prediction::TensorParameter* bias_input);

  // optional .apollo.prediction.TensorParameter bias_forget = 20;
  bool has_bias_forget() const;
  void clear_bias_forget();
  static const int kBiasForgetFieldNumber = 20;
  const ::apollo::prediction::TensorParameter& bias_forget() const;
  ::apollo::prediction::TensorParameter* mutable_bias_forget();
  ::apollo::prediction::TensorParameter* release_bias_forget();
  void set_allocated_bias_forget(::apollo::prediction::TensorParameter* bias_forget);

  // optional .apollo.prediction.TensorParameter bias_cell = 21;
  bool has_bias_cell() const;
  void clear_bias_cell();
  static const int kBiasCellFieldNumber = 21;
  const ::apollo::prediction::TensorParameter& bias_cell() const;
  ::apollo::prediction::TensorParameter* mutable_bias_cell();
  ::apollo::prediction::TensorParameter* release_bias_cell();
  void set_allocated_bias_cell(::apollo::prediction::TensorParameter* bias_cell);

  // optional .apollo.prediction.TensorParameter bias_output = 22;
  bool has_bias_output() const;
  void clear_bias_output();
  static const int kBiasOutputFieldNumber = 22;
  const ::apollo::prediction::TensorParameter& bias_output() const;
  ::apollo::prediction::TensorParameter* mutable_bias_output();
  ::apollo::prediction::TensorParameter* release_bias_output();
  void set_allocated_bias_output(::apollo::prediction::TensorParameter* bias_output);

  // optional .apollo.prediction.TensorParameter recurrent_weights_input = 25;
  bool has_recurrent_weights_input() const;
  void clear_recurrent_weights_input();
  static const int kRecurrentWeightsInputFieldNumber = 25;
  const ::apollo::prediction::TensorParameter& recurrent_weights_input() const;
  ::apollo::prediction::TensorParameter* mutable_recurrent_weights_input();
  ::apollo::prediction::TensorParameter* release_recurrent_weights_input();
  void set_allocated_recurrent_weights_input(::apollo::prediction::TensorParameter* recurrent_weights_input);

  // optional .apollo.prediction.TensorParameter recurrent_weights_forget = 26;
  bool has_recurrent_weights_forget() const;
  void clear_recurrent_weights_forget();
  static const int kRecurrentWeightsForgetFieldNumber = 26;
  const ::apollo::prediction::TensorParameter& recurrent_weights_forget() const;
  ::apollo::prediction::TensorParameter* mutable_recurrent_weights_forget();
  ::apollo::prediction::TensorParameter* release_recurrent_weights_forget();
  void set_allocated_recurrent_weights_forget(::apollo::prediction::TensorParameter* recurrent_weights_forget);

  // optional .apollo.prediction.TensorParameter recurrent_weights_cell = 27;
  bool has_recurrent_weights_cell() const;
  void clear_recurrent_weights_cell();
  static const int kRecurrentWeightsCellFieldNumber = 27;
  const ::apollo::prediction::TensorParameter& recurrent_weights_cell() const;
  ::apollo::prediction::TensorParameter* mutable_recurrent_weights_cell();
  ::apollo::prediction::TensorParameter* release_recurrent_weights_cell();
  void set_allocated_recurrent_weights_cell(::apollo::prediction::TensorParameter* recurrent_weights_cell);

  // optional .apollo.prediction.TensorParameter recurrent_weights_output = 28;
  bool has_recurrent_weights_output() const;
  void clear_recurrent_weights_output();
  static const int kRecurrentWeightsOutputFieldNumber = 28;
  const ::apollo::prediction::TensorParameter& recurrent_weights_output() const;
  ::apollo::prediction::TensorParameter* mutable_recurrent_weights_output();
  ::apollo::prediction::TensorParameter* release_recurrent_weights_output();
  void set_allocated_recurrent_weights_output(::apollo::prediction::TensorParameter* recurrent_weights_output);

  // @@protoc_insertion_point(class_scope:apollo.prediction.LSTMParameter)
 private:
  inline void set_has_units();
  inline void clear_has_units();
  inline void set_has_return_sequences();
  inline void clear_has_return_sequences();
  inline void set_has_stateful();
  inline void clear_has_stateful();
  inline void set_has_activation();
  inline void clear_has_activation();
  inline void set_has_recurrent_activation();
  inline void clear_has_recurrent_activation();
  inline void set_has_use_bias();
  inline void clear_has_use_bias();
  inline void set_has_unit_forget_bias();
  inline void clear_has_unit_forget_bias();
  inline void set_has_go_backwards();
  inline void clear_has_go_backwards();
  inline void set_has_unroll();
  inline void clear_has_unroll();
  inline void set_has_implementation();
  inline void clear_has_implementation();
  inline void set_has_weights_input();
  inline void clear_has_weights_input();
  inline void set_has_weights_forget();
  inline void clear_has_weights_forget();
  inline void set_has_weights_cell();
  inline void clear_has_weights_cell();
  inline void set_has_weights_output();
  inline void clear_has_weights_output();
  inline void set_has_bias_input();
  inline void clear_has_bias_input();
  inline void set_has_bias_forget();
  inline void clear_has_bias_forget();
  inline void set_has_bias_cell();
  inline void clear_has_bias_cell();
  inline void set_has_bias_output();
  inline void clear_has_bias_output();
  inline void set_has_recurrent_weights_input();
  inline void clear_has_recurrent_weights_input();
  inline void set_has_recurrent_weights_forget();
  inline void clear_has_recurrent_weights_forget();
  inline void set_has_recurrent_weights_cell();
  inline void clear_has_recurrent_weights_cell();
  inline void set_has_recurrent_weights_output();
  inline void clear_has_recurrent_weights_output();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 units_;
  bool return_sequences_;
  bool stateful_;
  bool use_bias_;
  bool unit_forget_bias_;
  ::google::protobuf::internal::ArenaStringPtr activation_;
  ::google::protobuf::internal::ArenaStringPtr recurrent_activation_;
  bool go_backwards_;
  bool unroll_;
  ::google::protobuf::int32 implementation_;
  ::apollo::prediction::TensorParameter* weights_input_;
  ::apollo::prediction::TensorParameter* weights_forget_;
  ::apollo::prediction::TensorParameter* weights_cell_;
  ::apollo::prediction::TensorParameter* weights_output_;
  ::apollo::prediction::TensorParameter* bias_input_;
  ::apollo::prediction::TensorParameter* bias_forget_;
  ::apollo::prediction::TensorParameter* bias_cell_;
  ::apollo::prediction::TensorParameter* bias_output_;
  ::apollo::prediction::TensorParameter* recurrent_weights_input_;
  ::apollo::prediction::TensorParameter* recurrent_weights_forget_;
  ::apollo::prediction::TensorParameter* recurrent_weights_cell_;
  ::apollo::prediction::TensorParameter* recurrent_weights_output_;
  friend void  protobuf_AddDesc_prediction_2fnetwork_5flayers_2eproto();
  friend void protobuf_AssignDesc_prediction_2fnetwork_5flayers_2eproto();
  friend void protobuf_ShutdownFile_prediction_2fnetwork_5flayers_2eproto();

  void InitAsDefaultInstance();
  static LSTMParameter* default_instance_;
};
// -------------------------------------------------------------------

class ActivationParameter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.prediction.ActivationParameter) */ {
 public:
  ActivationParameter();
  virtual ~ActivationParameter();

  ActivationParameter(const ActivationParameter& from);

  inline ActivationParameter& operator=(const ActivationParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActivationParameter& default_instance();

  void Swap(ActivationParameter* other);

  // implements Message ----------------------------------------------

  inline ActivationParameter* New() const { return New(NULL); }

  ActivationParameter* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActivationParameter& from);
  void MergeFrom(const ActivationParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActivationParameter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string activation = 1;
  bool has_activation() const;
  void clear_activation();
  static const int kActivationFieldNumber = 1;
  const ::std::string& activation() const;
  void set_activation(const ::std::string& value);
  void set_activation(const char* value);
  void set_activation(const char* value, size_t size);
  ::std::string* mutable_activation();
  ::std::string* release_activation();
  void set_allocated_activation(::std::string* activation);

  // @@protoc_insertion_point(class_scope:apollo.prediction.ActivationParameter)
 private:
  inline void set_has_activation();
  inline void clear_has_activation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr activation_;
  friend void  protobuf_AddDesc_prediction_2fnetwork_5flayers_2eproto();
  friend void protobuf_AssignDesc_prediction_2fnetwork_5flayers_2eproto();
  friend void protobuf_ShutdownFile_prediction_2fnetwork_5flayers_2eproto();

  void InitAsDefaultInstance();
  static ActivationParameter* default_instance_;
};
// -------------------------------------------------------------------

class FlattenParameter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.prediction.FlattenParameter) */ {
 public:
  FlattenParameter();
  virtual ~FlattenParameter();

  FlattenParameter(const FlattenParameter& from);

  inline FlattenParameter& operator=(const FlattenParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlattenParameter& default_instance();

  void Swap(FlattenParameter* other);

  // implements Message ----------------------------------------------

  inline FlattenParameter* New() const { return New(NULL); }

  FlattenParameter* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlattenParameter& from);
  void MergeFrom(const FlattenParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FlattenParameter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.prediction.FlattenParameter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_prediction_2fnetwork_5flayers_2eproto();
  friend void protobuf_AssignDesc_prediction_2fnetwork_5flayers_2eproto();
  friend void protobuf_ShutdownFile_prediction_2fnetwork_5flayers_2eproto();

  void InitAsDefaultInstance();
  static FlattenParameter* default_instance_;
};
// -------------------------------------------------------------------

class ConcatenateParameter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.prediction.ConcatenateParameter) */ {
 public:
  ConcatenateParameter();
  virtual ~ConcatenateParameter();

  ConcatenateParameter(const ConcatenateParameter& from);

  inline ConcatenateParameter& operator=(const ConcatenateParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConcatenateParameter& default_instance();

  void Swap(ConcatenateParameter* other);

  // implements Message ----------------------------------------------

  inline ConcatenateParameter* New() const { return New(NULL); }

  ConcatenateParameter* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConcatenateParameter& from);
  void MergeFrom(const ConcatenateParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConcatenateParameter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 axis = 1;
  bool has_axis() const;
  void clear_axis();
  static const int kAxisFieldNumber = 1;
  ::google::protobuf::int32 axis() const;
  void set_axis(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:apollo.prediction.ConcatenateParameter)
 private:
  inline void set_has_axis();
  inline void clear_has_axis();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 axis_;
  friend void  protobuf_AddDesc_prediction_2fnetwork_5flayers_2eproto();
  friend void protobuf_AssignDesc_prediction_2fnetwork_5flayers_2eproto();
  friend void protobuf_ShutdownFile_prediction_2fnetwork_5flayers_2eproto();

  void InitAsDefaultInstance();
  static ConcatenateParameter* default_instance_;
};
// -------------------------------------------------------------------

class LayerParameter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.prediction.LayerParameter) */ {
 public:
  LayerParameter();
  virtual ~LayerParameter();

  LayerParameter(const LayerParameter& from);

  inline LayerParameter& operator=(const LayerParameter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LayerParameter& default_instance();

  enum OneofLayersCase {
    kInput = 4,
    kActivation = 5,
    kDense = 6,
    kBatchNormalization = 7,
    kLstm = 8,
    kFlatten = 9,
    kConcatenate = 10,
    ONEOF_LAYERS_NOT_SET = 0,
  };

  void Swap(LayerParameter* other);

  // implements Message ----------------------------------------------

  inline LayerParameter* New() const { return New(NULL); }

  LayerParameter* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LayerParameter& from);
  void MergeFrom(const LayerParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LayerParameter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional int32 order_number = 3;
  bool has_order_number() const;
  void clear_order_number();
  static const int kOrderNumberFieldNumber = 3;
  ::google::protobuf::int32 order_number() const;
  void set_order_number(::google::protobuf::int32 value);

  // optional .apollo.prediction.InputParameter input = 4;
  bool has_input() const;
  void clear_input();
  static const int kInputFieldNumber = 4;
  const ::apollo::prediction::InputParameter& input() const;
  ::apollo::prediction::InputParameter* mutable_input();
  ::apollo::prediction::InputParameter* release_input();
  void set_allocated_input(::apollo::prediction::InputParameter* input);

  // optional .apollo.prediction.ActivationParameter activation = 5;
  bool has_activation() const;
  void clear_activation();
  static const int kActivationFieldNumber = 5;
  const ::apollo::prediction::ActivationParameter& activation() const;
  ::apollo::prediction::ActivationParameter* mutable_activation();
  ::apollo::prediction::ActivationParameter* release_activation();
  void set_allocated_activation(::apollo::prediction::ActivationParameter* activation);

  // optional .apollo.prediction.DenseParameter dense = 6;
  bool has_dense() const;
  void clear_dense();
  static const int kDenseFieldNumber = 6;
  const ::apollo::prediction::DenseParameter& dense() const;
  ::apollo::prediction::DenseParameter* mutable_dense();
  ::apollo::prediction::DenseParameter* release_dense();
  void set_allocated_dense(::apollo::prediction::DenseParameter* dense);

  // optional .apollo.prediction.BatchNormalizationParameter batch_normalization = 7;
  bool has_batch_normalization() const;
  void clear_batch_normalization();
  static const int kBatchNormalizationFieldNumber = 7;
  const ::apollo::prediction::BatchNormalizationParameter& batch_normalization() const;
  ::apollo::prediction::BatchNormalizationParameter* mutable_batch_normalization();
  ::apollo::prediction::BatchNormalizationParameter* release_batch_normalization();
  void set_allocated_batch_normalization(::apollo::prediction::BatchNormalizationParameter* batch_normalization);

  // optional .apollo.prediction.LSTMParameter lstm = 8;
  bool has_lstm() const;
  void clear_lstm();
  static const int kLstmFieldNumber = 8;
  const ::apollo::prediction::LSTMParameter& lstm() const;
  ::apollo::prediction::LSTMParameter* mutable_lstm();
  ::apollo::prediction::LSTMParameter* release_lstm();
  void set_allocated_lstm(::apollo::prediction::LSTMParameter* lstm);

  // optional .apollo.prediction.FlattenParameter flatten = 9;
  bool has_flatten() const;
  void clear_flatten();
  static const int kFlattenFieldNumber = 9;
  const ::apollo::prediction::FlattenParameter& flatten() const;
  ::apollo::prediction::FlattenParameter* mutable_flatten();
  ::apollo::prediction::FlattenParameter* release_flatten();
  void set_allocated_flatten(::apollo::prediction::FlattenParameter* flatten);

  // optional .apollo.prediction.ConcatenateParameter concatenate = 10;
  bool has_concatenate() const;
  void clear_concatenate();
  static const int kConcatenateFieldNumber = 10;
  const ::apollo::prediction::ConcatenateParameter& concatenate() const;
  ::apollo::prediction::ConcatenateParameter* mutable_concatenate();
  ::apollo::prediction::ConcatenateParameter* release_concatenate();
  void set_allocated_concatenate(::apollo::prediction::ConcatenateParameter* concatenate);

  OneofLayersCase oneof_layers_case() const;
  // @@protoc_insertion_point(class_scope:apollo.prediction.LayerParameter)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_order_number();
  inline void clear_has_order_number();
  inline void set_has_input();
  inline void set_has_activation();
  inline void set_has_dense();
  inline void set_has_batch_normalization();
  inline void set_has_lstm();
  inline void set_has_flatten();
  inline void set_has_concatenate();

  inline bool has_oneof_layers() const;
  void clear_oneof_layers();
  inline void clear_has_oneof_layers();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 order_number_;
  union OneofLayersUnion {
    OneofLayersUnion() {}
    ::apollo::prediction::InputParameter* input_;
    ::apollo::prediction::ActivationParameter* activation_;
    ::apollo::prediction::DenseParameter* dense_;
    ::apollo::prediction::BatchNormalizationParameter* batch_normalization_;
    ::apollo::prediction::LSTMParameter* lstm_;
    ::apollo::prediction::FlattenParameter* flatten_;
    ::apollo::prediction::ConcatenateParameter* concatenate_;
  } oneof_layers_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_prediction_2fnetwork_5flayers_2eproto();
  friend void protobuf_AssignDesc_prediction_2fnetwork_5flayers_2eproto();
  friend void protobuf_ShutdownFile_prediction_2fnetwork_5flayers_2eproto();

  void InitAsDefaultInstance();
  static LayerParameter* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TensorParameter

// repeated float data = 1 [packed = true];
inline int TensorParameter::data_size() const {
  return data_.size();
}
inline void TensorParameter::clear_data() {
  data_.Clear();
}
inline float TensorParameter::data(int index) const {
  // @@protoc_insertion_point(field_get:apollo.prediction.TensorParameter.data)
  return data_.Get(index);
}
inline void TensorParameter::set_data(int index, float value) {
  data_.Set(index, value);
  // @@protoc_insertion_point(field_set:apollo.prediction.TensorParameter.data)
}
inline void TensorParameter::add_data(float value) {
  data_.Add(value);
  // @@protoc_insertion_point(field_add:apollo.prediction.TensorParameter.data)
}
inline const ::google::protobuf::RepeatedField< float >&
TensorParameter::data() const {
  // @@protoc_insertion_point(field_list:apollo.prediction.TensorParameter.data)
  return data_;
}
inline ::google::protobuf::RepeatedField< float >*
TensorParameter::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:apollo.prediction.TensorParameter.data)
  return &data_;
}

// repeated int32 shape = 2;
inline int TensorParameter::shape_size() const {
  return shape_.size();
}
inline void TensorParameter::clear_shape() {
  shape_.Clear();
}
inline ::google::protobuf::int32 TensorParameter::shape(int index) const {
  // @@protoc_insertion_point(field_get:apollo.prediction.TensorParameter.shape)
  return shape_.Get(index);
}
inline void TensorParameter::set_shape(int index, ::google::protobuf::int32 value) {
  shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:apollo.prediction.TensorParameter.shape)
}
inline void TensorParameter::add_shape(::google::protobuf::int32 value) {
  shape_.Add(value);
  // @@protoc_insertion_point(field_add:apollo.prediction.TensorParameter.shape)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TensorParameter::shape() const {
  // @@protoc_insertion_point(field_list:apollo.prediction.TensorParameter.shape)
  return shape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TensorParameter::mutable_shape() {
  // @@protoc_insertion_point(field_mutable_list:apollo.prediction.TensorParameter.shape)
  return &shape_;
}

// -------------------------------------------------------------------

// InputParameter

// repeated int32 input_shape = 1;
inline int InputParameter::input_shape_size() const {
  return input_shape_.size();
}
inline void InputParameter::clear_input_shape() {
  input_shape_.Clear();
}
inline ::google::protobuf::int32 InputParameter::input_shape(int index) const {
  // @@protoc_insertion_point(field_get:apollo.prediction.InputParameter.input_shape)
  return input_shape_.Get(index);
}
inline void InputParameter::set_input_shape(int index, ::google::protobuf::int32 value) {
  input_shape_.Set(index, value);
  // @@protoc_insertion_point(field_set:apollo.prediction.InputParameter.input_shape)
}
inline void InputParameter::add_input_shape(::google::protobuf::int32 value) {
  input_shape_.Add(value);
  // @@protoc_insertion_point(field_add:apollo.prediction.InputParameter.input_shape)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
InputParameter::input_shape() const {
  // @@protoc_insertion_point(field_list:apollo.prediction.InputParameter.input_shape)
  return input_shape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
InputParameter::mutable_input_shape() {
  // @@protoc_insertion_point(field_mutable_list:apollo.prediction.InputParameter.input_shape)
  return &input_shape_;
}

// optional string dtype = 2;
inline bool InputParameter::has_dtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InputParameter::set_has_dtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InputParameter::clear_has_dtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InputParameter::clear_dtype() {
  dtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dtype();
}
inline const ::std::string& InputParameter::dtype() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.InputParameter.dtype)
  return dtype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputParameter::set_dtype(const ::std::string& value) {
  set_has_dtype();
  dtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.prediction.InputParameter.dtype)
}
inline void InputParameter::set_dtype(const char* value) {
  set_has_dtype();
  dtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.prediction.InputParameter.dtype)
}
inline void InputParameter::set_dtype(const char* value, size_t size) {
  set_has_dtype();
  dtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.prediction.InputParameter.dtype)
}
inline ::std::string* InputParameter::mutable_dtype() {
  set_has_dtype();
  // @@protoc_insertion_point(field_mutable:apollo.prediction.InputParameter.dtype)
  return dtype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InputParameter::release_dtype() {
  // @@protoc_insertion_point(field_release:apollo.prediction.InputParameter.dtype)
  clear_has_dtype();
  return dtype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputParameter::set_allocated_dtype(::std::string* dtype) {
  if (dtype != NULL) {
    set_has_dtype();
  } else {
    clear_has_dtype();
  }
  dtype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dtype);
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.InputParameter.dtype)
}

// optional bool sparse = 3;
inline bool InputParameter::has_sparse() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InputParameter::set_has_sparse() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InputParameter::clear_has_sparse() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InputParameter::clear_sparse() {
  sparse_ = false;
  clear_has_sparse();
}
inline bool InputParameter::sparse() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.InputParameter.sparse)
  return sparse_;
}
inline void InputParameter::set_sparse(bool value) {
  set_has_sparse();
  sparse_ = value;
  // @@protoc_insertion_point(field_set:apollo.prediction.InputParameter.sparse)
}

// -------------------------------------------------------------------

// DenseParameter

// optional int32 units = 1;
inline bool DenseParameter::has_units() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DenseParameter::set_has_units() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DenseParameter::clear_has_units() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DenseParameter::clear_units() {
  units_ = 0;
  clear_has_units();
}
inline ::google::protobuf::int32 DenseParameter::units() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.DenseParameter.units)
  return units_;
}
inline void DenseParameter::set_units(::google::protobuf::int32 value) {
  set_has_units();
  units_ = value;
  // @@protoc_insertion_point(field_set:apollo.prediction.DenseParameter.units)
}

// optional string activation = 2;
inline bool DenseParameter::has_activation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DenseParameter::set_has_activation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DenseParameter::clear_has_activation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DenseParameter::clear_activation() {
  activation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_activation();
}
inline const ::std::string& DenseParameter::activation() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.DenseParameter.activation)
  return activation_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DenseParameter::set_activation(const ::std::string& value) {
  set_has_activation();
  activation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.prediction.DenseParameter.activation)
}
inline void DenseParameter::set_activation(const char* value) {
  set_has_activation();
  activation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.prediction.DenseParameter.activation)
}
inline void DenseParameter::set_activation(const char* value, size_t size) {
  set_has_activation();
  activation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.prediction.DenseParameter.activation)
}
inline ::std::string* DenseParameter::mutable_activation() {
  set_has_activation();
  // @@protoc_insertion_point(field_mutable:apollo.prediction.DenseParameter.activation)
  return activation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DenseParameter::release_activation() {
  // @@protoc_insertion_point(field_release:apollo.prediction.DenseParameter.activation)
  clear_has_activation();
  return activation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DenseParameter::set_allocated_activation(::std::string* activation) {
  if (activation != NULL) {
    set_has_activation();
  } else {
    clear_has_activation();
  }
  activation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), activation);
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.DenseParameter.activation)
}

// optional bool use_bias = 3;
inline bool DenseParameter::has_use_bias() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DenseParameter::set_has_use_bias() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DenseParameter::clear_has_use_bias() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DenseParameter::clear_use_bias() {
  use_bias_ = false;
  clear_has_use_bias();
}
inline bool DenseParameter::use_bias() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.DenseParameter.use_bias)
  return use_bias_;
}
inline void DenseParameter::set_use_bias(bool value) {
  set_has_use_bias();
  use_bias_ = value;
  // @@protoc_insertion_point(field_set:apollo.prediction.DenseParameter.use_bias)
}

// optional .apollo.prediction.TensorParameter weights = 4;
inline bool DenseParameter::has_weights() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DenseParameter::set_has_weights() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DenseParameter::clear_has_weights() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DenseParameter::clear_weights() {
  if (weights_ != NULL) weights_->::apollo::prediction::TensorParameter::Clear();
  clear_has_weights();
}
inline const ::apollo::prediction::TensorParameter& DenseParameter::weights() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.DenseParameter.weights)
  return weights_ != NULL ? *weights_ : *default_instance_->weights_;
}
inline ::apollo::prediction::TensorParameter* DenseParameter::mutable_weights() {
  set_has_weights();
  if (weights_ == NULL) {
    weights_ = new ::apollo::prediction::TensorParameter;
  }
  // @@protoc_insertion_point(field_mutable:apollo.prediction.DenseParameter.weights)
  return weights_;
}
inline ::apollo::prediction::TensorParameter* DenseParameter::release_weights() {
  // @@protoc_insertion_point(field_release:apollo.prediction.DenseParameter.weights)
  clear_has_weights();
  ::apollo::prediction::TensorParameter* temp = weights_;
  weights_ = NULL;
  return temp;
}
inline void DenseParameter::set_allocated_weights(::apollo::prediction::TensorParameter* weights) {
  delete weights_;
  weights_ = weights;
  if (weights) {
    set_has_weights();
  } else {
    clear_has_weights();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.DenseParameter.weights)
}

// optional .apollo.prediction.TensorParameter bias = 5;
inline bool DenseParameter::has_bias() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DenseParameter::set_has_bias() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DenseParameter::clear_has_bias() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DenseParameter::clear_bias() {
  if (bias_ != NULL) bias_->::apollo::prediction::TensorParameter::Clear();
  clear_has_bias();
}
inline const ::apollo::prediction::TensorParameter& DenseParameter::bias() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.DenseParameter.bias)
  return bias_ != NULL ? *bias_ : *default_instance_->bias_;
}
inline ::apollo::prediction::TensorParameter* DenseParameter::mutable_bias() {
  set_has_bias();
  if (bias_ == NULL) {
    bias_ = new ::apollo::prediction::TensorParameter;
  }
  // @@protoc_insertion_point(field_mutable:apollo.prediction.DenseParameter.bias)
  return bias_;
}
inline ::apollo::prediction::TensorParameter* DenseParameter::release_bias() {
  // @@protoc_insertion_point(field_release:apollo.prediction.DenseParameter.bias)
  clear_has_bias();
  ::apollo::prediction::TensorParameter* temp = bias_;
  bias_ = NULL;
  return temp;
}
inline void DenseParameter::set_allocated_bias(::apollo::prediction::TensorParameter* bias) {
  delete bias_;
  bias_ = bias;
  if (bias) {
    set_has_bias();
  } else {
    clear_has_bias();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.DenseParameter.bias)
}

// -------------------------------------------------------------------

// BatchNormalizationParameter

// optional double epsilon = 1 [default = 1e-05];
inline bool BatchNormalizationParameter::has_epsilon() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BatchNormalizationParameter::set_has_epsilon() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BatchNormalizationParameter::clear_has_epsilon() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BatchNormalizationParameter::clear_epsilon() {
  epsilon_ = 1e-05;
  clear_has_epsilon();
}
inline double BatchNormalizationParameter::epsilon() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.BatchNormalizationParameter.epsilon)
  return epsilon_;
}
inline void BatchNormalizationParameter::set_epsilon(double value) {
  set_has_epsilon();
  epsilon_ = value;
  // @@protoc_insertion_point(field_set:apollo.prediction.BatchNormalizationParameter.epsilon)
}

// optional int32 axis = 2;
inline bool BatchNormalizationParameter::has_axis() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BatchNormalizationParameter::set_has_axis() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BatchNormalizationParameter::clear_has_axis() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BatchNormalizationParameter::clear_axis() {
  axis_ = 0;
  clear_has_axis();
}
inline ::google::protobuf::int32 BatchNormalizationParameter::axis() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.BatchNormalizationParameter.axis)
  return axis_;
}
inline void BatchNormalizationParameter::set_axis(::google::protobuf::int32 value) {
  set_has_axis();
  axis_ = value;
  // @@protoc_insertion_point(field_set:apollo.prediction.BatchNormalizationParameter.axis)
}

// optional bool center = 3;
inline bool BatchNormalizationParameter::has_center() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BatchNormalizationParameter::set_has_center() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BatchNormalizationParameter::clear_has_center() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BatchNormalizationParameter::clear_center() {
  center_ = false;
  clear_has_center();
}
inline bool BatchNormalizationParameter::center() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.BatchNormalizationParameter.center)
  return center_;
}
inline void BatchNormalizationParameter::set_center(bool value) {
  set_has_center();
  center_ = value;
  // @@protoc_insertion_point(field_set:apollo.prediction.BatchNormalizationParameter.center)
}

// optional bool scale = 4;
inline bool BatchNormalizationParameter::has_scale() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BatchNormalizationParameter::set_has_scale() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BatchNormalizationParameter::clear_has_scale() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BatchNormalizationParameter::clear_scale() {
  scale_ = false;
  clear_has_scale();
}
inline bool BatchNormalizationParameter::scale() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.BatchNormalizationParameter.scale)
  return scale_;
}
inline void BatchNormalizationParameter::set_scale(bool value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:apollo.prediction.BatchNormalizationParameter.scale)
}

// optional float momentum = 5;
inline bool BatchNormalizationParameter::has_momentum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BatchNormalizationParameter::set_has_momentum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BatchNormalizationParameter::clear_has_momentum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BatchNormalizationParameter::clear_momentum() {
  momentum_ = 0;
  clear_has_momentum();
}
inline float BatchNormalizationParameter::momentum() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.BatchNormalizationParameter.momentum)
  return momentum_;
}
inline void BatchNormalizationParameter::set_momentum(float value) {
  set_has_momentum();
  momentum_ = value;
  // @@protoc_insertion_point(field_set:apollo.prediction.BatchNormalizationParameter.momentum)
}

// optional .apollo.prediction.TensorParameter mu = 6;
inline bool BatchNormalizationParameter::has_mu() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BatchNormalizationParameter::set_has_mu() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BatchNormalizationParameter::clear_has_mu() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BatchNormalizationParameter::clear_mu() {
  if (mu_ != NULL) mu_->::apollo::prediction::TensorParameter::Clear();
  clear_has_mu();
}
inline const ::apollo::prediction::TensorParameter& BatchNormalizationParameter::mu() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.BatchNormalizationParameter.mu)
  return mu_ != NULL ? *mu_ : *default_instance_->mu_;
}
inline ::apollo::prediction::TensorParameter* BatchNormalizationParameter::mutable_mu() {
  set_has_mu();
  if (mu_ == NULL) {
    mu_ = new ::apollo::prediction::TensorParameter;
  }
  // @@protoc_insertion_point(field_mutable:apollo.prediction.BatchNormalizationParameter.mu)
  return mu_;
}
inline ::apollo::prediction::TensorParameter* BatchNormalizationParameter::release_mu() {
  // @@protoc_insertion_point(field_release:apollo.prediction.BatchNormalizationParameter.mu)
  clear_has_mu();
  ::apollo::prediction::TensorParameter* temp = mu_;
  mu_ = NULL;
  return temp;
}
inline void BatchNormalizationParameter::set_allocated_mu(::apollo::prediction::TensorParameter* mu) {
  delete mu_;
  mu_ = mu;
  if (mu) {
    set_has_mu();
  } else {
    clear_has_mu();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.BatchNormalizationParameter.mu)
}

// optional .apollo.prediction.TensorParameter sigma = 7;
inline bool BatchNormalizationParameter::has_sigma() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BatchNormalizationParameter::set_has_sigma() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BatchNormalizationParameter::clear_has_sigma() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BatchNormalizationParameter::clear_sigma() {
  if (sigma_ != NULL) sigma_->::apollo::prediction::TensorParameter::Clear();
  clear_has_sigma();
}
inline const ::apollo::prediction::TensorParameter& BatchNormalizationParameter::sigma() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.BatchNormalizationParameter.sigma)
  return sigma_ != NULL ? *sigma_ : *default_instance_->sigma_;
}
inline ::apollo::prediction::TensorParameter* BatchNormalizationParameter::mutable_sigma() {
  set_has_sigma();
  if (sigma_ == NULL) {
    sigma_ = new ::apollo::prediction::TensorParameter;
  }
  // @@protoc_insertion_point(field_mutable:apollo.prediction.BatchNormalizationParameter.sigma)
  return sigma_;
}
inline ::apollo::prediction::TensorParameter* BatchNormalizationParameter::release_sigma() {
  // @@protoc_insertion_point(field_release:apollo.prediction.BatchNormalizationParameter.sigma)
  clear_has_sigma();
  ::apollo::prediction::TensorParameter* temp = sigma_;
  sigma_ = NULL;
  return temp;
}
inline void BatchNormalizationParameter::set_allocated_sigma(::apollo::prediction::TensorParameter* sigma) {
  delete sigma_;
  sigma_ = sigma;
  if (sigma) {
    set_has_sigma();
  } else {
    clear_has_sigma();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.BatchNormalizationParameter.sigma)
}

// optional .apollo.prediction.TensorParameter gamma = 8;
inline bool BatchNormalizationParameter::has_gamma() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BatchNormalizationParameter::set_has_gamma() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BatchNormalizationParameter::clear_has_gamma() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BatchNormalizationParameter::clear_gamma() {
  if (gamma_ != NULL) gamma_->::apollo::prediction::TensorParameter::Clear();
  clear_has_gamma();
}
inline const ::apollo::prediction::TensorParameter& BatchNormalizationParameter::gamma() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.BatchNormalizationParameter.gamma)
  return gamma_ != NULL ? *gamma_ : *default_instance_->gamma_;
}
inline ::apollo::prediction::TensorParameter* BatchNormalizationParameter::mutable_gamma() {
  set_has_gamma();
  if (gamma_ == NULL) {
    gamma_ = new ::apollo::prediction::TensorParameter;
  }
  // @@protoc_insertion_point(field_mutable:apollo.prediction.BatchNormalizationParameter.gamma)
  return gamma_;
}
inline ::apollo::prediction::TensorParameter* BatchNormalizationParameter::release_gamma() {
  // @@protoc_insertion_point(field_release:apollo.prediction.BatchNormalizationParameter.gamma)
  clear_has_gamma();
  ::apollo::prediction::TensorParameter* temp = gamma_;
  gamma_ = NULL;
  return temp;
}
inline void BatchNormalizationParameter::set_allocated_gamma(::apollo::prediction::TensorParameter* gamma) {
  delete gamma_;
  gamma_ = gamma;
  if (gamma) {
    set_has_gamma();
  } else {
    clear_has_gamma();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.BatchNormalizationParameter.gamma)
}

// optional .apollo.prediction.TensorParameter beta = 9;
inline bool BatchNormalizationParameter::has_beta() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BatchNormalizationParameter::set_has_beta() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BatchNormalizationParameter::clear_has_beta() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BatchNormalizationParameter::clear_beta() {
  if (beta_ != NULL) beta_->::apollo::prediction::TensorParameter::Clear();
  clear_has_beta();
}
inline const ::apollo::prediction::TensorParameter& BatchNormalizationParameter::beta() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.BatchNormalizationParameter.beta)
  return beta_ != NULL ? *beta_ : *default_instance_->beta_;
}
inline ::apollo::prediction::TensorParameter* BatchNormalizationParameter::mutable_beta() {
  set_has_beta();
  if (beta_ == NULL) {
    beta_ = new ::apollo::prediction::TensorParameter;
  }
  // @@protoc_insertion_point(field_mutable:apollo.prediction.BatchNormalizationParameter.beta)
  return beta_;
}
inline ::apollo::prediction::TensorParameter* BatchNormalizationParameter::release_beta() {
  // @@protoc_insertion_point(field_release:apollo.prediction.BatchNormalizationParameter.beta)
  clear_has_beta();
  ::apollo::prediction::TensorParameter* temp = beta_;
  beta_ = NULL;
  return temp;
}
inline void BatchNormalizationParameter::set_allocated_beta(::apollo::prediction::TensorParameter* beta) {
  delete beta_;
  beta_ = beta;
  if (beta) {
    set_has_beta();
  } else {
    clear_has_beta();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.BatchNormalizationParameter.beta)
}

// -------------------------------------------------------------------

// LSTMParameter

// optional int32 units = 1;
inline bool LSTMParameter::has_units() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LSTMParameter::set_has_units() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LSTMParameter::clear_has_units() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LSTMParameter::clear_units() {
  units_ = 0;
  clear_has_units();
}
inline ::google::protobuf::int32 LSTMParameter::units() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LSTMParameter.units)
  return units_;
}
inline void LSTMParameter::set_units(::google::protobuf::int32 value) {
  set_has_units();
  units_ = value;
  // @@protoc_insertion_point(field_set:apollo.prediction.LSTMParameter.units)
}

// optional bool return_sequences = 2;
inline bool LSTMParameter::has_return_sequences() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LSTMParameter::set_has_return_sequences() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LSTMParameter::clear_has_return_sequences() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LSTMParameter::clear_return_sequences() {
  return_sequences_ = false;
  clear_has_return_sequences();
}
inline bool LSTMParameter::return_sequences() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LSTMParameter.return_sequences)
  return return_sequences_;
}
inline void LSTMParameter::set_return_sequences(bool value) {
  set_has_return_sequences();
  return_sequences_ = value;
  // @@protoc_insertion_point(field_set:apollo.prediction.LSTMParameter.return_sequences)
}

// optional bool stateful = 3;
inline bool LSTMParameter::has_stateful() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LSTMParameter::set_has_stateful() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LSTMParameter::clear_has_stateful() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LSTMParameter::clear_stateful() {
  stateful_ = false;
  clear_has_stateful();
}
inline bool LSTMParameter::stateful() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LSTMParameter.stateful)
  return stateful_;
}
inline void LSTMParameter::set_stateful(bool value) {
  set_has_stateful();
  stateful_ = value;
  // @@protoc_insertion_point(field_set:apollo.prediction.LSTMParameter.stateful)
}

// optional string activation = 4;
inline bool LSTMParameter::has_activation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LSTMParameter::set_has_activation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LSTMParameter::clear_has_activation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LSTMParameter::clear_activation() {
  activation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_activation();
}
inline const ::std::string& LSTMParameter::activation() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LSTMParameter.activation)
  return activation_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LSTMParameter::set_activation(const ::std::string& value) {
  set_has_activation();
  activation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.prediction.LSTMParameter.activation)
}
inline void LSTMParameter::set_activation(const char* value) {
  set_has_activation();
  activation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.prediction.LSTMParameter.activation)
}
inline void LSTMParameter::set_activation(const char* value, size_t size) {
  set_has_activation();
  activation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.prediction.LSTMParameter.activation)
}
inline ::std::string* LSTMParameter::mutable_activation() {
  set_has_activation();
  // @@protoc_insertion_point(field_mutable:apollo.prediction.LSTMParameter.activation)
  return activation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LSTMParameter::release_activation() {
  // @@protoc_insertion_point(field_release:apollo.prediction.LSTMParameter.activation)
  clear_has_activation();
  return activation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LSTMParameter::set_allocated_activation(::std::string* activation) {
  if (activation != NULL) {
    set_has_activation();
  } else {
    clear_has_activation();
  }
  activation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), activation);
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.LSTMParameter.activation)
}

// optional string recurrent_activation = 5;
inline bool LSTMParameter::has_recurrent_activation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LSTMParameter::set_has_recurrent_activation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LSTMParameter::clear_has_recurrent_activation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LSTMParameter::clear_recurrent_activation() {
  recurrent_activation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_recurrent_activation();
}
inline const ::std::string& LSTMParameter::recurrent_activation() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LSTMParameter.recurrent_activation)
  return recurrent_activation_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LSTMParameter::set_recurrent_activation(const ::std::string& value) {
  set_has_recurrent_activation();
  recurrent_activation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.prediction.LSTMParameter.recurrent_activation)
}
inline void LSTMParameter::set_recurrent_activation(const char* value) {
  set_has_recurrent_activation();
  recurrent_activation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.prediction.LSTMParameter.recurrent_activation)
}
inline void LSTMParameter::set_recurrent_activation(const char* value, size_t size) {
  set_has_recurrent_activation();
  recurrent_activation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.prediction.LSTMParameter.recurrent_activation)
}
inline ::std::string* LSTMParameter::mutable_recurrent_activation() {
  set_has_recurrent_activation();
  // @@protoc_insertion_point(field_mutable:apollo.prediction.LSTMParameter.recurrent_activation)
  return recurrent_activation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LSTMParameter::release_recurrent_activation() {
  // @@protoc_insertion_point(field_release:apollo.prediction.LSTMParameter.recurrent_activation)
  clear_has_recurrent_activation();
  return recurrent_activation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LSTMParameter::set_allocated_recurrent_activation(::std::string* recurrent_activation) {
  if (recurrent_activation != NULL) {
    set_has_recurrent_activation();
  } else {
    clear_has_recurrent_activation();
  }
  recurrent_activation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), recurrent_activation);
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.LSTMParameter.recurrent_activation)
}

// optional bool use_bias = 6;
inline bool LSTMParameter::has_use_bias() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LSTMParameter::set_has_use_bias() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LSTMParameter::clear_has_use_bias() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LSTMParameter::clear_use_bias() {
  use_bias_ = false;
  clear_has_use_bias();
}
inline bool LSTMParameter::use_bias() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LSTMParameter.use_bias)
  return use_bias_;
}
inline void LSTMParameter::set_use_bias(bool value) {
  set_has_use_bias();
  use_bias_ = value;
  // @@protoc_insertion_point(field_set:apollo.prediction.LSTMParameter.use_bias)
}

// optional bool unit_forget_bias = 7 [default = true];
inline bool LSTMParameter::has_unit_forget_bias() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LSTMParameter::set_has_unit_forget_bias() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LSTMParameter::clear_has_unit_forget_bias() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LSTMParameter::clear_unit_forget_bias() {
  unit_forget_bias_ = true;
  clear_has_unit_forget_bias();
}
inline bool LSTMParameter::unit_forget_bias() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LSTMParameter.unit_forget_bias)
  return unit_forget_bias_;
}
inline void LSTMParameter::set_unit_forget_bias(bool value) {
  set_has_unit_forget_bias();
  unit_forget_bias_ = value;
  // @@protoc_insertion_point(field_set:apollo.prediction.LSTMParameter.unit_forget_bias)
}

// optional bool go_backwards = 8 [default = false];
inline bool LSTMParameter::has_go_backwards() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LSTMParameter::set_has_go_backwards() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LSTMParameter::clear_has_go_backwards() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LSTMParameter::clear_go_backwards() {
  go_backwards_ = false;
  clear_has_go_backwards();
}
inline bool LSTMParameter::go_backwards() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LSTMParameter.go_backwards)
  return go_backwards_;
}
inline void LSTMParameter::set_go_backwards(bool value) {
  set_has_go_backwards();
  go_backwards_ = value;
  // @@protoc_insertion_point(field_set:apollo.prediction.LSTMParameter.go_backwards)
}

// optional bool unroll = 9 [default = false];
inline bool LSTMParameter::has_unroll() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LSTMParameter::set_has_unroll() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LSTMParameter::clear_has_unroll() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LSTMParameter::clear_unroll() {
  unroll_ = false;
  clear_has_unroll();
}
inline bool LSTMParameter::unroll() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LSTMParameter.unroll)
  return unroll_;
}
inline void LSTMParameter::set_unroll(bool value) {
  set_has_unroll();
  unroll_ = value;
  // @@protoc_insertion_point(field_set:apollo.prediction.LSTMParameter.unroll)
}

// optional int32 implementation = 10 [default = 0];
inline bool LSTMParameter::has_implementation() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LSTMParameter::set_has_implementation() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LSTMParameter::clear_has_implementation() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LSTMParameter::clear_implementation() {
  implementation_ = 0;
  clear_has_implementation();
}
inline ::google::protobuf::int32 LSTMParameter::implementation() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LSTMParameter.implementation)
  return implementation_;
}
inline void LSTMParameter::set_implementation(::google::protobuf::int32 value) {
  set_has_implementation();
  implementation_ = value;
  // @@protoc_insertion_point(field_set:apollo.prediction.LSTMParameter.implementation)
}

// optional .apollo.prediction.TensorParameter weights_input = 15;
inline bool LSTMParameter::has_weights_input() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LSTMParameter::set_has_weights_input() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LSTMParameter::clear_has_weights_input() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LSTMParameter::clear_weights_input() {
  if (weights_input_ != NULL) weights_input_->::apollo::prediction::TensorParameter::Clear();
  clear_has_weights_input();
}
inline const ::apollo::prediction::TensorParameter& LSTMParameter::weights_input() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LSTMParameter.weights_input)
  return weights_input_ != NULL ? *weights_input_ : *default_instance_->weights_input_;
}
inline ::apollo::prediction::TensorParameter* LSTMParameter::mutable_weights_input() {
  set_has_weights_input();
  if (weights_input_ == NULL) {
    weights_input_ = new ::apollo::prediction::TensorParameter;
  }
  // @@protoc_insertion_point(field_mutable:apollo.prediction.LSTMParameter.weights_input)
  return weights_input_;
}
inline ::apollo::prediction::TensorParameter* LSTMParameter::release_weights_input() {
  // @@protoc_insertion_point(field_release:apollo.prediction.LSTMParameter.weights_input)
  clear_has_weights_input();
  ::apollo::prediction::TensorParameter* temp = weights_input_;
  weights_input_ = NULL;
  return temp;
}
inline void LSTMParameter::set_allocated_weights_input(::apollo::prediction::TensorParameter* weights_input) {
  delete weights_input_;
  weights_input_ = weights_input;
  if (weights_input) {
    set_has_weights_input();
  } else {
    clear_has_weights_input();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.LSTMParameter.weights_input)
}

// optional .apollo.prediction.TensorParameter weights_forget = 16;
inline bool LSTMParameter::has_weights_forget() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LSTMParameter::set_has_weights_forget() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LSTMParameter::clear_has_weights_forget() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LSTMParameter::clear_weights_forget() {
  if (weights_forget_ != NULL) weights_forget_->::apollo::prediction::TensorParameter::Clear();
  clear_has_weights_forget();
}
inline const ::apollo::prediction::TensorParameter& LSTMParameter::weights_forget() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LSTMParameter.weights_forget)
  return weights_forget_ != NULL ? *weights_forget_ : *default_instance_->weights_forget_;
}
inline ::apollo::prediction::TensorParameter* LSTMParameter::mutable_weights_forget() {
  set_has_weights_forget();
  if (weights_forget_ == NULL) {
    weights_forget_ = new ::apollo::prediction::TensorParameter;
  }
  // @@protoc_insertion_point(field_mutable:apollo.prediction.LSTMParameter.weights_forget)
  return weights_forget_;
}
inline ::apollo::prediction::TensorParameter* LSTMParameter::release_weights_forget() {
  // @@protoc_insertion_point(field_release:apollo.prediction.LSTMParameter.weights_forget)
  clear_has_weights_forget();
  ::apollo::prediction::TensorParameter* temp = weights_forget_;
  weights_forget_ = NULL;
  return temp;
}
inline void LSTMParameter::set_allocated_weights_forget(::apollo::prediction::TensorParameter* weights_forget) {
  delete weights_forget_;
  weights_forget_ = weights_forget;
  if (weights_forget) {
    set_has_weights_forget();
  } else {
    clear_has_weights_forget();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.LSTMParameter.weights_forget)
}

// optional .apollo.prediction.TensorParameter weights_cell = 17;
inline bool LSTMParameter::has_weights_cell() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LSTMParameter::set_has_weights_cell() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LSTMParameter::clear_has_weights_cell() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LSTMParameter::clear_weights_cell() {
  if (weights_cell_ != NULL) weights_cell_->::apollo::prediction::TensorParameter::Clear();
  clear_has_weights_cell();
}
inline const ::apollo::prediction::TensorParameter& LSTMParameter::weights_cell() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LSTMParameter.weights_cell)
  return weights_cell_ != NULL ? *weights_cell_ : *default_instance_->weights_cell_;
}
inline ::apollo::prediction::TensorParameter* LSTMParameter::mutable_weights_cell() {
  set_has_weights_cell();
  if (weights_cell_ == NULL) {
    weights_cell_ = new ::apollo::prediction::TensorParameter;
  }
  // @@protoc_insertion_point(field_mutable:apollo.prediction.LSTMParameter.weights_cell)
  return weights_cell_;
}
inline ::apollo::prediction::TensorParameter* LSTMParameter::release_weights_cell() {
  // @@protoc_insertion_point(field_release:apollo.prediction.LSTMParameter.weights_cell)
  clear_has_weights_cell();
  ::apollo::prediction::TensorParameter* temp = weights_cell_;
  weights_cell_ = NULL;
  return temp;
}
inline void LSTMParameter::set_allocated_weights_cell(::apollo::prediction::TensorParameter* weights_cell) {
  delete weights_cell_;
  weights_cell_ = weights_cell;
  if (weights_cell) {
    set_has_weights_cell();
  } else {
    clear_has_weights_cell();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.LSTMParameter.weights_cell)
}

// optional .apollo.prediction.TensorParameter weights_output = 18;
inline bool LSTMParameter::has_weights_output() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LSTMParameter::set_has_weights_output() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LSTMParameter::clear_has_weights_output() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LSTMParameter::clear_weights_output() {
  if (weights_output_ != NULL) weights_output_->::apollo::prediction::TensorParameter::Clear();
  clear_has_weights_output();
}
inline const ::apollo::prediction::TensorParameter& LSTMParameter::weights_output() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LSTMParameter.weights_output)
  return weights_output_ != NULL ? *weights_output_ : *default_instance_->weights_output_;
}
inline ::apollo::prediction::TensorParameter* LSTMParameter::mutable_weights_output() {
  set_has_weights_output();
  if (weights_output_ == NULL) {
    weights_output_ = new ::apollo::prediction::TensorParameter;
  }
  // @@protoc_insertion_point(field_mutable:apollo.prediction.LSTMParameter.weights_output)
  return weights_output_;
}
inline ::apollo::prediction::TensorParameter* LSTMParameter::release_weights_output() {
  // @@protoc_insertion_point(field_release:apollo.prediction.LSTMParameter.weights_output)
  clear_has_weights_output();
  ::apollo::prediction::TensorParameter* temp = weights_output_;
  weights_output_ = NULL;
  return temp;
}
inline void LSTMParameter::set_allocated_weights_output(::apollo::prediction::TensorParameter* weights_output) {
  delete weights_output_;
  weights_output_ = weights_output;
  if (weights_output) {
    set_has_weights_output();
  } else {
    clear_has_weights_output();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.LSTMParameter.weights_output)
}

// optional .apollo.prediction.TensorParameter bias_input = 19;
inline bool LSTMParameter::has_bias_input() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void LSTMParameter::set_has_bias_input() {
  _has_bits_[0] |= 0x00004000u;
}
inline void LSTMParameter::clear_has_bias_input() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void LSTMParameter::clear_bias_input() {
  if (bias_input_ != NULL) bias_input_->::apollo::prediction::TensorParameter::Clear();
  clear_has_bias_input();
}
inline const ::apollo::prediction::TensorParameter& LSTMParameter::bias_input() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LSTMParameter.bias_input)
  return bias_input_ != NULL ? *bias_input_ : *default_instance_->bias_input_;
}
inline ::apollo::prediction::TensorParameter* LSTMParameter::mutable_bias_input() {
  set_has_bias_input();
  if (bias_input_ == NULL) {
    bias_input_ = new ::apollo::prediction::TensorParameter;
  }
  // @@protoc_insertion_point(field_mutable:apollo.prediction.LSTMParameter.bias_input)
  return bias_input_;
}
inline ::apollo::prediction::TensorParameter* LSTMParameter::release_bias_input() {
  // @@protoc_insertion_point(field_release:apollo.prediction.LSTMParameter.bias_input)
  clear_has_bias_input();
  ::apollo::prediction::TensorParameter* temp = bias_input_;
  bias_input_ = NULL;
  return temp;
}
inline void LSTMParameter::set_allocated_bias_input(::apollo::prediction::TensorParameter* bias_input) {
  delete bias_input_;
  bias_input_ = bias_input;
  if (bias_input) {
    set_has_bias_input();
  } else {
    clear_has_bias_input();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.LSTMParameter.bias_input)
}

// optional .apollo.prediction.TensorParameter bias_forget = 20;
inline bool LSTMParameter::has_bias_forget() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void LSTMParameter::set_has_bias_forget() {
  _has_bits_[0] |= 0x00008000u;
}
inline void LSTMParameter::clear_has_bias_forget() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void LSTMParameter::clear_bias_forget() {
  if (bias_forget_ != NULL) bias_forget_->::apollo::prediction::TensorParameter::Clear();
  clear_has_bias_forget();
}
inline const ::apollo::prediction::TensorParameter& LSTMParameter::bias_forget() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LSTMParameter.bias_forget)
  return bias_forget_ != NULL ? *bias_forget_ : *default_instance_->bias_forget_;
}
inline ::apollo::prediction::TensorParameter* LSTMParameter::mutable_bias_forget() {
  set_has_bias_forget();
  if (bias_forget_ == NULL) {
    bias_forget_ = new ::apollo::prediction::TensorParameter;
  }
  // @@protoc_insertion_point(field_mutable:apollo.prediction.LSTMParameter.bias_forget)
  return bias_forget_;
}
inline ::apollo::prediction::TensorParameter* LSTMParameter::release_bias_forget() {
  // @@protoc_insertion_point(field_release:apollo.prediction.LSTMParameter.bias_forget)
  clear_has_bias_forget();
  ::apollo::prediction::TensorParameter* temp = bias_forget_;
  bias_forget_ = NULL;
  return temp;
}
inline void LSTMParameter::set_allocated_bias_forget(::apollo::prediction::TensorParameter* bias_forget) {
  delete bias_forget_;
  bias_forget_ = bias_forget;
  if (bias_forget) {
    set_has_bias_forget();
  } else {
    clear_has_bias_forget();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.LSTMParameter.bias_forget)
}

// optional .apollo.prediction.TensorParameter bias_cell = 21;
inline bool LSTMParameter::has_bias_cell() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void LSTMParameter::set_has_bias_cell() {
  _has_bits_[0] |= 0x00010000u;
}
inline void LSTMParameter::clear_has_bias_cell() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void LSTMParameter::clear_bias_cell() {
  if (bias_cell_ != NULL) bias_cell_->::apollo::prediction::TensorParameter::Clear();
  clear_has_bias_cell();
}
inline const ::apollo::prediction::TensorParameter& LSTMParameter::bias_cell() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LSTMParameter.bias_cell)
  return bias_cell_ != NULL ? *bias_cell_ : *default_instance_->bias_cell_;
}
inline ::apollo::prediction::TensorParameter* LSTMParameter::mutable_bias_cell() {
  set_has_bias_cell();
  if (bias_cell_ == NULL) {
    bias_cell_ = new ::apollo::prediction::TensorParameter;
  }
  // @@protoc_insertion_point(field_mutable:apollo.prediction.LSTMParameter.bias_cell)
  return bias_cell_;
}
inline ::apollo::prediction::TensorParameter* LSTMParameter::release_bias_cell() {
  // @@protoc_insertion_point(field_release:apollo.prediction.LSTMParameter.bias_cell)
  clear_has_bias_cell();
  ::apollo::prediction::TensorParameter* temp = bias_cell_;
  bias_cell_ = NULL;
  return temp;
}
inline void LSTMParameter::set_allocated_bias_cell(::apollo::prediction::TensorParameter* bias_cell) {
  delete bias_cell_;
  bias_cell_ = bias_cell;
  if (bias_cell) {
    set_has_bias_cell();
  } else {
    clear_has_bias_cell();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.LSTMParameter.bias_cell)
}

// optional .apollo.prediction.TensorParameter bias_output = 22;
inline bool LSTMParameter::has_bias_output() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void LSTMParameter::set_has_bias_output() {
  _has_bits_[0] |= 0x00020000u;
}
inline void LSTMParameter::clear_has_bias_output() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void LSTMParameter::clear_bias_output() {
  if (bias_output_ != NULL) bias_output_->::apollo::prediction::TensorParameter::Clear();
  clear_has_bias_output();
}
inline const ::apollo::prediction::TensorParameter& LSTMParameter::bias_output() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LSTMParameter.bias_output)
  return bias_output_ != NULL ? *bias_output_ : *default_instance_->bias_output_;
}
inline ::apollo::prediction::TensorParameter* LSTMParameter::mutable_bias_output() {
  set_has_bias_output();
  if (bias_output_ == NULL) {
    bias_output_ = new ::apollo::prediction::TensorParameter;
  }
  // @@protoc_insertion_point(field_mutable:apollo.prediction.LSTMParameter.bias_output)
  return bias_output_;
}
inline ::apollo::prediction::TensorParameter* LSTMParameter::release_bias_output() {
  // @@protoc_insertion_point(field_release:apollo.prediction.LSTMParameter.bias_output)
  clear_has_bias_output();
  ::apollo::prediction::TensorParameter* temp = bias_output_;
  bias_output_ = NULL;
  return temp;
}
inline void LSTMParameter::set_allocated_bias_output(::apollo::prediction::TensorParameter* bias_output) {
  delete bias_output_;
  bias_output_ = bias_output;
  if (bias_output) {
    set_has_bias_output();
  } else {
    clear_has_bias_output();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.LSTMParameter.bias_output)
}

// optional .apollo.prediction.TensorParameter recurrent_weights_input = 25;
inline bool LSTMParameter::has_recurrent_weights_input() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void LSTMParameter::set_has_recurrent_weights_input() {
  _has_bits_[0] |= 0x00040000u;
}
inline void LSTMParameter::clear_has_recurrent_weights_input() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void LSTMParameter::clear_recurrent_weights_input() {
  if (recurrent_weights_input_ != NULL) recurrent_weights_input_->::apollo::prediction::TensorParameter::Clear();
  clear_has_recurrent_weights_input();
}
inline const ::apollo::prediction::TensorParameter& LSTMParameter::recurrent_weights_input() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LSTMParameter.recurrent_weights_input)
  return recurrent_weights_input_ != NULL ? *recurrent_weights_input_ : *default_instance_->recurrent_weights_input_;
}
inline ::apollo::prediction::TensorParameter* LSTMParameter::mutable_recurrent_weights_input() {
  set_has_recurrent_weights_input();
  if (recurrent_weights_input_ == NULL) {
    recurrent_weights_input_ = new ::apollo::prediction::TensorParameter;
  }
  // @@protoc_insertion_point(field_mutable:apollo.prediction.LSTMParameter.recurrent_weights_input)
  return recurrent_weights_input_;
}
inline ::apollo::prediction::TensorParameter* LSTMParameter::release_recurrent_weights_input() {
  // @@protoc_insertion_point(field_release:apollo.prediction.LSTMParameter.recurrent_weights_input)
  clear_has_recurrent_weights_input();
  ::apollo::prediction::TensorParameter* temp = recurrent_weights_input_;
  recurrent_weights_input_ = NULL;
  return temp;
}
inline void LSTMParameter::set_allocated_recurrent_weights_input(::apollo::prediction::TensorParameter* recurrent_weights_input) {
  delete recurrent_weights_input_;
  recurrent_weights_input_ = recurrent_weights_input;
  if (recurrent_weights_input) {
    set_has_recurrent_weights_input();
  } else {
    clear_has_recurrent_weights_input();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.LSTMParameter.recurrent_weights_input)
}

// optional .apollo.prediction.TensorParameter recurrent_weights_forget = 26;
inline bool LSTMParameter::has_recurrent_weights_forget() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void LSTMParameter::set_has_recurrent_weights_forget() {
  _has_bits_[0] |= 0x00080000u;
}
inline void LSTMParameter::clear_has_recurrent_weights_forget() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void LSTMParameter::clear_recurrent_weights_forget() {
  if (recurrent_weights_forget_ != NULL) recurrent_weights_forget_->::apollo::prediction::TensorParameter::Clear();
  clear_has_recurrent_weights_forget();
}
inline const ::apollo::prediction::TensorParameter& LSTMParameter::recurrent_weights_forget() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LSTMParameter.recurrent_weights_forget)
  return recurrent_weights_forget_ != NULL ? *recurrent_weights_forget_ : *default_instance_->recurrent_weights_forget_;
}
inline ::apollo::prediction::TensorParameter* LSTMParameter::mutable_recurrent_weights_forget() {
  set_has_recurrent_weights_forget();
  if (recurrent_weights_forget_ == NULL) {
    recurrent_weights_forget_ = new ::apollo::prediction::TensorParameter;
  }
  // @@protoc_insertion_point(field_mutable:apollo.prediction.LSTMParameter.recurrent_weights_forget)
  return recurrent_weights_forget_;
}
inline ::apollo::prediction::TensorParameter* LSTMParameter::release_recurrent_weights_forget() {
  // @@protoc_insertion_point(field_release:apollo.prediction.LSTMParameter.recurrent_weights_forget)
  clear_has_recurrent_weights_forget();
  ::apollo::prediction::TensorParameter* temp = recurrent_weights_forget_;
  recurrent_weights_forget_ = NULL;
  return temp;
}
inline void LSTMParameter::set_allocated_recurrent_weights_forget(::apollo::prediction::TensorParameter* recurrent_weights_forget) {
  delete recurrent_weights_forget_;
  recurrent_weights_forget_ = recurrent_weights_forget;
  if (recurrent_weights_forget) {
    set_has_recurrent_weights_forget();
  } else {
    clear_has_recurrent_weights_forget();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.LSTMParameter.recurrent_weights_forget)
}

// optional .apollo.prediction.TensorParameter recurrent_weights_cell = 27;
inline bool LSTMParameter::has_recurrent_weights_cell() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void LSTMParameter::set_has_recurrent_weights_cell() {
  _has_bits_[0] |= 0x00100000u;
}
inline void LSTMParameter::clear_has_recurrent_weights_cell() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void LSTMParameter::clear_recurrent_weights_cell() {
  if (recurrent_weights_cell_ != NULL) recurrent_weights_cell_->::apollo::prediction::TensorParameter::Clear();
  clear_has_recurrent_weights_cell();
}
inline const ::apollo::prediction::TensorParameter& LSTMParameter::recurrent_weights_cell() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LSTMParameter.recurrent_weights_cell)
  return recurrent_weights_cell_ != NULL ? *recurrent_weights_cell_ : *default_instance_->recurrent_weights_cell_;
}
inline ::apollo::prediction::TensorParameter* LSTMParameter::mutable_recurrent_weights_cell() {
  set_has_recurrent_weights_cell();
  if (recurrent_weights_cell_ == NULL) {
    recurrent_weights_cell_ = new ::apollo::prediction::TensorParameter;
  }
  // @@protoc_insertion_point(field_mutable:apollo.prediction.LSTMParameter.recurrent_weights_cell)
  return recurrent_weights_cell_;
}
inline ::apollo::prediction::TensorParameter* LSTMParameter::release_recurrent_weights_cell() {
  // @@protoc_insertion_point(field_release:apollo.prediction.LSTMParameter.recurrent_weights_cell)
  clear_has_recurrent_weights_cell();
  ::apollo::prediction::TensorParameter* temp = recurrent_weights_cell_;
  recurrent_weights_cell_ = NULL;
  return temp;
}
inline void LSTMParameter::set_allocated_recurrent_weights_cell(::apollo::prediction::TensorParameter* recurrent_weights_cell) {
  delete recurrent_weights_cell_;
  recurrent_weights_cell_ = recurrent_weights_cell;
  if (recurrent_weights_cell) {
    set_has_recurrent_weights_cell();
  } else {
    clear_has_recurrent_weights_cell();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.LSTMParameter.recurrent_weights_cell)
}

// optional .apollo.prediction.TensorParameter recurrent_weights_output = 28;
inline bool LSTMParameter::has_recurrent_weights_output() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void LSTMParameter::set_has_recurrent_weights_output() {
  _has_bits_[0] |= 0x00200000u;
}
inline void LSTMParameter::clear_has_recurrent_weights_output() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void LSTMParameter::clear_recurrent_weights_output() {
  if (recurrent_weights_output_ != NULL) recurrent_weights_output_->::apollo::prediction::TensorParameter::Clear();
  clear_has_recurrent_weights_output();
}
inline const ::apollo::prediction::TensorParameter& LSTMParameter::recurrent_weights_output() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LSTMParameter.recurrent_weights_output)
  return recurrent_weights_output_ != NULL ? *recurrent_weights_output_ : *default_instance_->recurrent_weights_output_;
}
inline ::apollo::prediction::TensorParameter* LSTMParameter::mutable_recurrent_weights_output() {
  set_has_recurrent_weights_output();
  if (recurrent_weights_output_ == NULL) {
    recurrent_weights_output_ = new ::apollo::prediction::TensorParameter;
  }
  // @@protoc_insertion_point(field_mutable:apollo.prediction.LSTMParameter.recurrent_weights_output)
  return recurrent_weights_output_;
}
inline ::apollo::prediction::TensorParameter* LSTMParameter::release_recurrent_weights_output() {
  // @@protoc_insertion_point(field_release:apollo.prediction.LSTMParameter.recurrent_weights_output)
  clear_has_recurrent_weights_output();
  ::apollo::prediction::TensorParameter* temp = recurrent_weights_output_;
  recurrent_weights_output_ = NULL;
  return temp;
}
inline void LSTMParameter::set_allocated_recurrent_weights_output(::apollo::prediction::TensorParameter* recurrent_weights_output) {
  delete recurrent_weights_output_;
  recurrent_weights_output_ = recurrent_weights_output;
  if (recurrent_weights_output) {
    set_has_recurrent_weights_output();
  } else {
    clear_has_recurrent_weights_output();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.LSTMParameter.recurrent_weights_output)
}

// -------------------------------------------------------------------

// ActivationParameter

// optional string activation = 1;
inline bool ActivationParameter::has_activation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActivationParameter::set_has_activation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActivationParameter::clear_has_activation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActivationParameter::clear_activation() {
  activation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_activation();
}
inline const ::std::string& ActivationParameter::activation() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.ActivationParameter.activation)
  return activation_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ActivationParameter::set_activation(const ::std::string& value) {
  set_has_activation();
  activation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.prediction.ActivationParameter.activation)
}
inline void ActivationParameter::set_activation(const char* value) {
  set_has_activation();
  activation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.prediction.ActivationParameter.activation)
}
inline void ActivationParameter::set_activation(const char* value, size_t size) {
  set_has_activation();
  activation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.prediction.ActivationParameter.activation)
}
inline ::std::string* ActivationParameter::mutable_activation() {
  set_has_activation();
  // @@protoc_insertion_point(field_mutable:apollo.prediction.ActivationParameter.activation)
  return activation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ActivationParameter::release_activation() {
  // @@protoc_insertion_point(field_release:apollo.prediction.ActivationParameter.activation)
  clear_has_activation();
  return activation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ActivationParameter::set_allocated_activation(::std::string* activation) {
  if (activation != NULL) {
    set_has_activation();
  } else {
    clear_has_activation();
  }
  activation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), activation);
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.ActivationParameter.activation)
}

// -------------------------------------------------------------------

// FlattenParameter

// -------------------------------------------------------------------

// ConcatenateParameter

// optional int32 axis = 1;
inline bool ConcatenateParameter::has_axis() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConcatenateParameter::set_has_axis() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConcatenateParameter::clear_has_axis() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConcatenateParameter::clear_axis() {
  axis_ = 0;
  clear_has_axis();
}
inline ::google::protobuf::int32 ConcatenateParameter::axis() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.ConcatenateParameter.axis)
  return axis_;
}
inline void ConcatenateParameter::set_axis(::google::protobuf::int32 value) {
  set_has_axis();
  axis_ = value;
  // @@protoc_insertion_point(field_set:apollo.prediction.ConcatenateParameter.axis)
}

// -------------------------------------------------------------------

// LayerParameter

// optional string type = 1;
inline bool LayerParameter::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LayerParameter::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LayerParameter::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LayerParameter::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& LayerParameter::type() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LayerParameter.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LayerParameter::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.prediction.LayerParameter.type)
}
inline void LayerParameter::set_type(const char* value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.prediction.LayerParameter.type)
}
inline void LayerParameter::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.prediction.LayerParameter.type)
}
inline ::std::string* LayerParameter::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:apollo.prediction.LayerParameter.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LayerParameter::release_type() {
  // @@protoc_insertion_point(field_release:apollo.prediction.LayerParameter.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LayerParameter::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.LayerParameter.type)
}

// optional string name = 2;
inline bool LayerParameter::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LayerParameter::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LayerParameter::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LayerParameter::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& LayerParameter::name() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LayerParameter.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LayerParameter::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.prediction.LayerParameter.name)
}
inline void LayerParameter::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.prediction.LayerParameter.name)
}
inline void LayerParameter::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.prediction.LayerParameter.name)
}
inline ::std::string* LayerParameter::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:apollo.prediction.LayerParameter.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LayerParameter::release_name() {
  // @@protoc_insertion_point(field_release:apollo.prediction.LayerParameter.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LayerParameter::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.LayerParameter.name)
}

// optional int32 order_number = 3;
inline bool LayerParameter::has_order_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LayerParameter::set_has_order_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LayerParameter::clear_has_order_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LayerParameter::clear_order_number() {
  order_number_ = 0;
  clear_has_order_number();
}
inline ::google::protobuf::int32 LayerParameter::order_number() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LayerParameter.order_number)
  return order_number_;
}
inline void LayerParameter::set_order_number(::google::protobuf::int32 value) {
  set_has_order_number();
  order_number_ = value;
  // @@protoc_insertion_point(field_set:apollo.prediction.LayerParameter.order_number)
}

// optional .apollo.prediction.InputParameter input = 4;
inline bool LayerParameter::has_input() const {
  return oneof_layers_case() == kInput;
}
inline void LayerParameter::set_has_input() {
  _oneof_case_[0] = kInput;
}
inline void LayerParameter::clear_input() {
  if (has_input()) {
    delete oneof_layers_.input_;
    clear_has_oneof_layers();
  }
}
inline  const ::apollo::prediction::InputParameter& LayerParameter::input() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LayerParameter.input)
  return has_input()
      ? *oneof_layers_.input_
      : ::apollo::prediction::InputParameter::default_instance();
}
inline ::apollo::prediction::InputParameter* LayerParameter::mutable_input() {
  if (!has_input()) {
    clear_oneof_layers();
    set_has_input();
    oneof_layers_.input_ = new ::apollo::prediction::InputParameter;
  }
  // @@protoc_insertion_point(field_mutable:apollo.prediction.LayerParameter.input)
  return oneof_layers_.input_;
}
inline ::apollo::prediction::InputParameter* LayerParameter::release_input() {
  // @@protoc_insertion_point(field_release:apollo.prediction.LayerParameter.input)
  if (has_input()) {
    clear_has_oneof_layers();
    ::apollo::prediction::InputParameter* temp = oneof_layers_.input_;
    oneof_layers_.input_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LayerParameter::set_allocated_input(::apollo::prediction::InputParameter* input) {
  clear_oneof_layers();
  if (input) {
    set_has_input();
    oneof_layers_.input_ = input;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.LayerParameter.input)
}

// optional .apollo.prediction.ActivationParameter activation = 5;
inline bool LayerParameter::has_activation() const {
  return oneof_layers_case() == kActivation;
}
inline void LayerParameter::set_has_activation() {
  _oneof_case_[0] = kActivation;
}
inline void LayerParameter::clear_activation() {
  if (has_activation()) {
    delete oneof_layers_.activation_;
    clear_has_oneof_layers();
  }
}
inline  const ::apollo::prediction::ActivationParameter& LayerParameter::activation() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LayerParameter.activation)
  return has_activation()
      ? *oneof_layers_.activation_
      : ::apollo::prediction::ActivationParameter::default_instance();
}
inline ::apollo::prediction::ActivationParameter* LayerParameter::mutable_activation() {
  if (!has_activation()) {
    clear_oneof_layers();
    set_has_activation();
    oneof_layers_.activation_ = new ::apollo::prediction::ActivationParameter;
  }
  // @@protoc_insertion_point(field_mutable:apollo.prediction.LayerParameter.activation)
  return oneof_layers_.activation_;
}
inline ::apollo::prediction::ActivationParameter* LayerParameter::release_activation() {
  // @@protoc_insertion_point(field_release:apollo.prediction.LayerParameter.activation)
  if (has_activation()) {
    clear_has_oneof_layers();
    ::apollo::prediction::ActivationParameter* temp = oneof_layers_.activation_;
    oneof_layers_.activation_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LayerParameter::set_allocated_activation(::apollo::prediction::ActivationParameter* activation) {
  clear_oneof_layers();
  if (activation) {
    set_has_activation();
    oneof_layers_.activation_ = activation;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.LayerParameter.activation)
}

// optional .apollo.prediction.DenseParameter dense = 6;
inline bool LayerParameter::has_dense() const {
  return oneof_layers_case() == kDense;
}
inline void LayerParameter::set_has_dense() {
  _oneof_case_[0] = kDense;
}
inline void LayerParameter::clear_dense() {
  if (has_dense()) {
    delete oneof_layers_.dense_;
    clear_has_oneof_layers();
  }
}
inline  const ::apollo::prediction::DenseParameter& LayerParameter::dense() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LayerParameter.dense)
  return has_dense()
      ? *oneof_layers_.dense_
      : ::apollo::prediction::DenseParameter::default_instance();
}
inline ::apollo::prediction::DenseParameter* LayerParameter::mutable_dense() {
  if (!has_dense()) {
    clear_oneof_layers();
    set_has_dense();
    oneof_layers_.dense_ = new ::apollo::prediction::DenseParameter;
  }
  // @@protoc_insertion_point(field_mutable:apollo.prediction.LayerParameter.dense)
  return oneof_layers_.dense_;
}
inline ::apollo::prediction::DenseParameter* LayerParameter::release_dense() {
  // @@protoc_insertion_point(field_release:apollo.prediction.LayerParameter.dense)
  if (has_dense()) {
    clear_has_oneof_layers();
    ::apollo::prediction::DenseParameter* temp = oneof_layers_.dense_;
    oneof_layers_.dense_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LayerParameter::set_allocated_dense(::apollo::prediction::DenseParameter* dense) {
  clear_oneof_layers();
  if (dense) {
    set_has_dense();
    oneof_layers_.dense_ = dense;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.LayerParameter.dense)
}

// optional .apollo.prediction.BatchNormalizationParameter batch_normalization = 7;
inline bool LayerParameter::has_batch_normalization() const {
  return oneof_layers_case() == kBatchNormalization;
}
inline void LayerParameter::set_has_batch_normalization() {
  _oneof_case_[0] = kBatchNormalization;
}
inline void LayerParameter::clear_batch_normalization() {
  if (has_batch_normalization()) {
    delete oneof_layers_.batch_normalization_;
    clear_has_oneof_layers();
  }
}
inline  const ::apollo::prediction::BatchNormalizationParameter& LayerParameter::batch_normalization() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LayerParameter.batch_normalization)
  return has_batch_normalization()
      ? *oneof_layers_.batch_normalization_
      : ::apollo::prediction::BatchNormalizationParameter::default_instance();
}
inline ::apollo::prediction::BatchNormalizationParameter* LayerParameter::mutable_batch_normalization() {
  if (!has_batch_normalization()) {
    clear_oneof_layers();
    set_has_batch_normalization();
    oneof_layers_.batch_normalization_ = new ::apollo::prediction::BatchNormalizationParameter;
  }
  // @@protoc_insertion_point(field_mutable:apollo.prediction.LayerParameter.batch_normalization)
  return oneof_layers_.batch_normalization_;
}
inline ::apollo::prediction::BatchNormalizationParameter* LayerParameter::release_batch_normalization() {
  // @@protoc_insertion_point(field_release:apollo.prediction.LayerParameter.batch_normalization)
  if (has_batch_normalization()) {
    clear_has_oneof_layers();
    ::apollo::prediction::BatchNormalizationParameter* temp = oneof_layers_.batch_normalization_;
    oneof_layers_.batch_normalization_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LayerParameter::set_allocated_batch_normalization(::apollo::prediction::BatchNormalizationParameter* batch_normalization) {
  clear_oneof_layers();
  if (batch_normalization) {
    set_has_batch_normalization();
    oneof_layers_.batch_normalization_ = batch_normalization;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.LayerParameter.batch_normalization)
}

// optional .apollo.prediction.LSTMParameter lstm = 8;
inline bool LayerParameter::has_lstm() const {
  return oneof_layers_case() == kLstm;
}
inline void LayerParameter::set_has_lstm() {
  _oneof_case_[0] = kLstm;
}
inline void LayerParameter::clear_lstm() {
  if (has_lstm()) {
    delete oneof_layers_.lstm_;
    clear_has_oneof_layers();
  }
}
inline  const ::apollo::prediction::LSTMParameter& LayerParameter::lstm() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LayerParameter.lstm)
  return has_lstm()
      ? *oneof_layers_.lstm_
      : ::apollo::prediction::LSTMParameter::default_instance();
}
inline ::apollo::prediction::LSTMParameter* LayerParameter::mutable_lstm() {
  if (!has_lstm()) {
    clear_oneof_layers();
    set_has_lstm();
    oneof_layers_.lstm_ = new ::apollo::prediction::LSTMParameter;
  }
  // @@protoc_insertion_point(field_mutable:apollo.prediction.LayerParameter.lstm)
  return oneof_layers_.lstm_;
}
inline ::apollo::prediction::LSTMParameter* LayerParameter::release_lstm() {
  // @@protoc_insertion_point(field_release:apollo.prediction.LayerParameter.lstm)
  if (has_lstm()) {
    clear_has_oneof_layers();
    ::apollo::prediction::LSTMParameter* temp = oneof_layers_.lstm_;
    oneof_layers_.lstm_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LayerParameter::set_allocated_lstm(::apollo::prediction::LSTMParameter* lstm) {
  clear_oneof_layers();
  if (lstm) {
    set_has_lstm();
    oneof_layers_.lstm_ = lstm;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.LayerParameter.lstm)
}

// optional .apollo.prediction.FlattenParameter flatten = 9;
inline bool LayerParameter::has_flatten() const {
  return oneof_layers_case() == kFlatten;
}
inline void LayerParameter::set_has_flatten() {
  _oneof_case_[0] = kFlatten;
}
inline void LayerParameter::clear_flatten() {
  if (has_flatten()) {
    delete oneof_layers_.flatten_;
    clear_has_oneof_layers();
  }
}
inline  const ::apollo::prediction::FlattenParameter& LayerParameter::flatten() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LayerParameter.flatten)
  return has_flatten()
      ? *oneof_layers_.flatten_
      : ::apollo::prediction::FlattenParameter::default_instance();
}
inline ::apollo::prediction::FlattenParameter* LayerParameter::mutable_flatten() {
  if (!has_flatten()) {
    clear_oneof_layers();
    set_has_flatten();
    oneof_layers_.flatten_ = new ::apollo::prediction::FlattenParameter;
  }
  // @@protoc_insertion_point(field_mutable:apollo.prediction.LayerParameter.flatten)
  return oneof_layers_.flatten_;
}
inline ::apollo::prediction::FlattenParameter* LayerParameter::release_flatten() {
  // @@protoc_insertion_point(field_release:apollo.prediction.LayerParameter.flatten)
  if (has_flatten()) {
    clear_has_oneof_layers();
    ::apollo::prediction::FlattenParameter* temp = oneof_layers_.flatten_;
    oneof_layers_.flatten_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LayerParameter::set_allocated_flatten(::apollo::prediction::FlattenParameter* flatten) {
  clear_oneof_layers();
  if (flatten) {
    set_has_flatten();
    oneof_layers_.flatten_ = flatten;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.LayerParameter.flatten)
}

// optional .apollo.prediction.ConcatenateParameter concatenate = 10;
inline bool LayerParameter::has_concatenate() const {
  return oneof_layers_case() == kConcatenate;
}
inline void LayerParameter::set_has_concatenate() {
  _oneof_case_[0] = kConcatenate;
}
inline void LayerParameter::clear_concatenate() {
  if (has_concatenate()) {
    delete oneof_layers_.concatenate_;
    clear_has_oneof_layers();
  }
}
inline  const ::apollo::prediction::ConcatenateParameter& LayerParameter::concatenate() const {
  // @@protoc_insertion_point(field_get:apollo.prediction.LayerParameter.concatenate)
  return has_concatenate()
      ? *oneof_layers_.concatenate_
      : ::apollo::prediction::ConcatenateParameter::default_instance();
}
inline ::apollo::prediction::ConcatenateParameter* LayerParameter::mutable_concatenate() {
  if (!has_concatenate()) {
    clear_oneof_layers();
    set_has_concatenate();
    oneof_layers_.concatenate_ = new ::apollo::prediction::ConcatenateParameter;
  }
  // @@protoc_insertion_point(field_mutable:apollo.prediction.LayerParameter.concatenate)
  return oneof_layers_.concatenate_;
}
inline ::apollo::prediction::ConcatenateParameter* LayerParameter::release_concatenate() {
  // @@protoc_insertion_point(field_release:apollo.prediction.LayerParameter.concatenate)
  if (has_concatenate()) {
    clear_has_oneof_layers();
    ::apollo::prediction::ConcatenateParameter* temp = oneof_layers_.concatenate_;
    oneof_layers_.concatenate_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void LayerParameter::set_allocated_concatenate(::apollo::prediction::ConcatenateParameter* concatenate) {
  clear_oneof_layers();
  if (concatenate) {
    set_has_concatenate();
    oneof_layers_.concatenate_ = concatenate;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.prediction.LayerParameter.concatenate)
}

inline bool LayerParameter::has_oneof_layers() const {
  return oneof_layers_case() != ONEOF_LAYERS_NOT_SET;
}
inline void LayerParameter::clear_has_oneof_layers() {
  _oneof_case_[0] = ONEOF_LAYERS_NOT_SET;
}
inline LayerParameter::OneofLayersCase LayerParameter::oneof_layers_case() const {
  return LayerParameter::OneofLayersCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace prediction
}  // namespace apollo

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_prediction_2fnetwork_5flayers_2eproto__INCLUDED
