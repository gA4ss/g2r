// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: data/recorder_info.proto

#ifndef PROTOBUF_data_2frecorder_5finfo_2eproto__INCLUDED
#define PROTOBUF_data_2frecorder_5finfo_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace apollo {
namespace data {
namespace recorder {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_data_2frecorder_5finfo_2eproto();
void protobuf_AssignDesc_data_2frecorder_5finfo_2eproto();
void protobuf_ShutdownFile_data_2frecorder_5finfo_2eproto();

class Bag;
class Data;
class Disk;
class RecorderInfo;
class Resources;
class Task;

enum StatusType {
  DATA_RECORDER_INIT = 0,
  DATA_RECORDER_RUNNING = 1,
  DATA_RECORD_ENABLE = 2,
  DATA_SYNC_ENABLE = 4,
  DISK_SPACE_WARNNING = 8,
  DISK_SPACE_ALERT = 16,
  DELETING_OLD_DATA = 32,
  DATA_RECORDER_EXIT = 64,
  UNDEFINED = 128
};
bool StatusType_IsValid(int value);
const StatusType StatusType_MIN = DATA_RECORDER_INIT;
const StatusType StatusType_MAX = UNDEFINED;
const int StatusType_ARRAYSIZE = StatusType_MAX + 1;

const ::google::protobuf::EnumDescriptor* StatusType_descriptor();
inline const ::std::string& StatusType_Name(StatusType value) {
  return ::google::protobuf::internal::NameOfEnum(
    StatusType_descriptor(), value);
}
inline bool StatusType_Parse(
    const ::std::string& name, StatusType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StatusType>(
    StatusType_descriptor(), name, value);
}
// ===================================================================

class RecorderInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.data.recorder.RecorderInfo) */ {
 public:
  RecorderInfo();
  virtual ~RecorderInfo();

  RecorderInfo(const RecorderInfo& from);

  inline RecorderInfo& operator=(const RecorderInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecorderInfo& default_instance();

  void Swap(RecorderInfo* other);

  // implements Message ----------------------------------------------

  inline RecorderInfo* New() const { return New(NULL); }

  RecorderInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RecorderInfo& from);
  void MergeFrom(const RecorderInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RecorderInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::google::protobuf::uint32 status() const;
  void set_status(::google::protobuf::uint32 value);

  // optional .apollo.data.recorder.Task task = 2;
  bool has_task() const;
  void clear_task();
  static const int kTaskFieldNumber = 2;
  const ::apollo::data::recorder::Task& task() const;
  ::apollo::data::recorder::Task* mutable_task();
  ::apollo::data::recorder::Task* release_task();
  void set_allocated_task(::apollo::data::recorder::Task* task);

  // optional .apollo.data.recorder.Disk writing_disk = 3;
  bool has_writing_disk() const;
  void clear_writing_disk();
  static const int kWritingDiskFieldNumber = 3;
  const ::apollo::data::recorder::Disk& writing_disk() const;
  ::apollo::data::recorder::Disk* mutable_writing_disk();
  ::apollo::data::recorder::Disk* release_writing_disk();
  void set_allocated_writing_disk(::apollo::data::recorder::Disk* writing_disk);

  // optional .apollo.data.recorder.Data data = 4;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 4;
  const ::apollo::data::recorder::Data& data() const;
  ::apollo::data::recorder::Data* mutable_data();
  ::apollo::data::recorder::Data* release_data();
  void set_allocated_data(::apollo::data::recorder::Data* data);

  // optional .apollo.data.recorder.Resources resources = 5;
  bool has_resources() const;
  void clear_resources();
  static const int kResourcesFieldNumber = 5;
  const ::apollo::data::recorder::Resources& resources() const;
  ::apollo::data::recorder::Resources* mutable_resources();
  ::apollo::data::recorder::Resources* release_resources();
  void set_allocated_resources(::apollo::data::recorder::Resources* resources);

  // @@protoc_insertion_point(class_scope:apollo.data.recorder.RecorderInfo)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_task();
  inline void clear_has_task();
  inline void set_has_writing_disk();
  inline void clear_has_writing_disk();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_resources();
  inline void clear_has_resources();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::apollo::data::recorder::Task* task_;
  ::apollo::data::recorder::Disk* writing_disk_;
  ::apollo::data::recorder::Data* data_;
  ::apollo::data::recorder::Resources* resources_;
  ::google::protobuf::uint32 status_;
  friend void  protobuf_AddDesc_data_2frecorder_5finfo_2eproto();
  friend void protobuf_AssignDesc_data_2frecorder_5finfo_2eproto();
  friend void protobuf_ShutdownFile_data_2frecorder_5finfo_2eproto();

  void InitAsDefaultInstance();
  static RecorderInfo* default_instance_;
};
// -------------------------------------------------------------------

class Task : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.data.recorder.Task) */ {
 public:
  Task();
  virtual ~Task();

  Task(const Task& from);

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Task& default_instance();

  void Swap(Task* other);

  // implements Message ----------------------------------------------

  inline Task* New() const { return New(NULL); }

  Task* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Task& from);
  void MergeFrom(const Task& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Task* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional uint32 sequence = 2;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  ::google::protobuf::uint32 sequence() const;
  void set_sequence(::google::protobuf::uint32 value);

  // optional double duration = 3;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 3;
  double duration() const;
  void set_duration(double value);

  // @@protoc_insertion_point(class_scope:apollo.data.recorder.Task)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_duration();
  inline void clear_has_duration();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  double duration_;
  ::google::protobuf::uint32 sequence_;
  friend void  protobuf_AddDesc_data_2frecorder_5finfo_2eproto();
  friend void protobuf_AssignDesc_data_2frecorder_5finfo_2eproto();
  friend void protobuf_ShutdownFile_data_2frecorder_5finfo_2eproto();

  void InitAsDefaultInstance();
  static Task* default_instance_;
};
// -------------------------------------------------------------------

class Disk : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.data.recorder.Disk) */ {
 public:
  Disk();
  virtual ~Disk();

  Disk(const Disk& from);

  inline Disk& operator=(const Disk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Disk& default_instance();

  void Swap(Disk* other);

  // implements Message ----------------------------------------------

  inline Disk* New() const { return New(NULL); }

  Disk* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Disk& from);
  void MergeFrom(const Disk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Disk* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sn = 1;
  bool has_sn() const;
  void clear_sn();
  static const int kSnFieldNumber = 1;
  const ::std::string& sn() const;
  void set_sn(const ::std::string& value);
  void set_sn(const char* value);
  void set_sn(const char* value, size_t size);
  ::std::string* mutable_sn();
  ::std::string* release_sn();
  void set_allocated_sn(::std::string* sn);

  // optional string fs = 2;
  bool has_fs() const;
  void clear_fs();
  static const int kFsFieldNumber = 2;
  const ::std::string& fs() const;
  void set_fs(const ::std::string& value);
  void set_fs(const char* value);
  void set_fs(const char* value, size_t size);
  ::std::string* mutable_fs();
  ::std::string* release_fs();
  void set_allocated_fs(::std::string* fs);

  // optional double size = 3;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  double size() const;
  void set_size(double value);

  // optional double used = 4;
  bool has_used() const;
  void clear_used();
  static const int kUsedFieldNumber = 4;
  double used() const;
  void set_used(double value);

  // optional double avail = 5;
  bool has_avail() const;
  void clear_avail();
  static const int kAvailFieldNumber = 5;
  double avail() const;
  void set_avail(double value);

  // optional double use_percent = 6;
  bool has_use_percent() const;
  void clear_use_percent();
  static const int kUsePercentFieldNumber = 6;
  double use_percent() const;
  void set_use_percent(double value);

  // optional string mount = 7;
  bool has_mount() const;
  void clear_mount();
  static const int kMountFieldNumber = 7;
  const ::std::string& mount() const;
  void set_mount(const ::std::string& value);
  void set_mount(const char* value);
  void set_mount(const char* value, size_t size);
  ::std::string* mutable_mount();
  ::std::string* release_mount();
  void set_allocated_mount(::std::string* mount);

  // optional string slot = 8;
  bool has_slot() const;
  void clear_slot();
  static const int kSlotFieldNumber = 8;
  const ::std::string& slot() const;
  void set_slot(const ::std::string& value);
  void set_slot(const char* value);
  void set_slot(const char* value, size_t size);
  ::std::string* mutable_slot();
  ::std::string* release_slot();
  void set_allocated_slot(::std::string* slot);

  // @@protoc_insertion_point(class_scope:apollo.data.recorder.Disk)
 private:
  inline void set_has_sn();
  inline void clear_has_sn();
  inline void set_has_fs();
  inline void clear_has_fs();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_used();
  inline void clear_has_used();
  inline void set_has_avail();
  inline void clear_has_avail();
  inline void set_has_use_percent();
  inline void clear_has_use_percent();
  inline void set_has_mount();
  inline void clear_has_mount();
  inline void set_has_slot();
  inline void clear_has_slot();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sn_;
  ::google::protobuf::internal::ArenaStringPtr fs_;
  double size_;
  double used_;
  double avail_;
  double use_percent_;
  ::google::protobuf::internal::ArenaStringPtr mount_;
  ::google::protobuf::internal::ArenaStringPtr slot_;
  friend void  protobuf_AddDesc_data_2frecorder_5finfo_2eproto();
  friend void protobuf_AssignDesc_data_2frecorder_5finfo_2eproto();
  friend void protobuf_ShutdownFile_data_2frecorder_5finfo_2eproto();

  void InitAsDefaultInstance();
  static Disk* default_instance_;
};
// -------------------------------------------------------------------

class Resources : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.data.recorder.Resources) */ {
 public:
  Resources();
  virtual ~Resources();

  Resources(const Resources& from);

  inline Resources& operator=(const Resources& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Resources& default_instance();

  void Swap(Resources* other);

  // implements Message ----------------------------------------------

  inline Resources* New() const { return New(NULL); }

  Resources* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Resources& from);
  void MergeFrom(const Resources& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Resources* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .apollo.data.recorder.Disk disks = 1;
  int disks_size() const;
  void clear_disks();
  static const int kDisksFieldNumber = 1;
  const ::apollo::data::recorder::Disk& disks(int index) const;
  ::apollo::data::recorder::Disk* mutable_disks(int index);
  ::apollo::data::recorder::Disk* add_disks();
  ::google::protobuf::RepeatedPtrField< ::apollo::data::recorder::Disk >*
      mutable_disks();
  const ::google::protobuf::RepeatedPtrField< ::apollo::data::recorder::Disk >&
      disks() const;

  // @@protoc_insertion_point(class_scope:apollo.data.recorder.Resources)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::apollo::data::recorder::Disk > disks_;
  friend void  protobuf_AddDesc_data_2frecorder_5finfo_2eproto();
  friend void protobuf_AssignDesc_data_2frecorder_5finfo_2eproto();
  friend void protobuf_ShutdownFile_data_2frecorder_5finfo_2eproto();

  void InitAsDefaultInstance();
  static Resources* default_instance_;
};
// -------------------------------------------------------------------

class Data : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.data.recorder.Data) */ {
 public:
  Data();
  virtual ~Data();

  Data(const Data& from);

  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Data& default_instance();

  void Swap(Data* other);

  // implements Message ----------------------------------------------

  inline Data* New() const { return New(NULL); }

  Data* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Data& from);
  void MergeFrom(const Data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Data* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .apollo.data.recorder.Bag bags = 1;
  int bags_size() const;
  void clear_bags();
  static const int kBagsFieldNumber = 1;
  const ::apollo::data::recorder::Bag& bags(int index) const;
  ::apollo::data::recorder::Bag* mutable_bags(int index);
  ::apollo::data::recorder::Bag* add_bags();
  ::google::protobuf::RepeatedPtrField< ::apollo::data::recorder::Bag >*
      mutable_bags();
  const ::google::protobuf::RepeatedPtrField< ::apollo::data::recorder::Bag >&
      bags() const;

  // @@protoc_insertion_point(class_scope:apollo.data.recorder.Data)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::apollo::data::recorder::Bag > bags_;
  friend void  protobuf_AddDesc_data_2frecorder_5finfo_2eproto();
  friend void protobuf_AssignDesc_data_2frecorder_5finfo_2eproto();
  friend void protobuf_ShutdownFile_data_2frecorder_5finfo_2eproto();

  void InitAsDefaultInstance();
  static Data* default_instance_;
};
// -------------------------------------------------------------------

class Bag : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.data.recorder.Bag) */ {
 public:
  Bag();
  virtual ~Bag();

  Bag(const Bag& from);

  inline Bag& operator=(const Bag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Bag& default_instance();

  void Swap(Bag* other);

  // implements Message ----------------------------------------------

  inline Bag* New() const { return New(NULL); }

  Bag* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Bag& from);
  void MergeFrom(const Bag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Bag* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string writing_filename = 1;
  bool has_writing_filename() const;
  void clear_writing_filename();
  static const int kWritingFilenameFieldNumber = 1;
  const ::std::string& writing_filename() const;
  void set_writing_filename(const ::std::string& value);
  void set_writing_filename(const char* value);
  void set_writing_filename(const char* value, size_t size);
  ::std::string* mutable_writing_filename();
  ::std::string* release_writing_filename();
  void set_allocated_writing_filename(::std::string* writing_filename);

  // @@protoc_insertion_point(class_scope:apollo.data.recorder.Bag)
 private:
  inline void set_has_writing_filename();
  inline void clear_has_writing_filename();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr writing_filename_;
  friend void  protobuf_AddDesc_data_2frecorder_5finfo_2eproto();
  friend void protobuf_AssignDesc_data_2frecorder_5finfo_2eproto();
  friend void protobuf_ShutdownFile_data_2frecorder_5finfo_2eproto();

  void InitAsDefaultInstance();
  static Bag* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// RecorderInfo

// optional uint32 status = 1;
inline bool RecorderInfo::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecorderInfo::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecorderInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecorderInfo::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 RecorderInfo::status() const {
  // @@protoc_insertion_point(field_get:apollo.data.recorder.RecorderInfo.status)
  return status_;
}
inline void RecorderInfo::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:apollo.data.recorder.RecorderInfo.status)
}

// optional .apollo.data.recorder.Task task = 2;
inline bool RecorderInfo::has_task() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RecorderInfo::set_has_task() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RecorderInfo::clear_has_task() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RecorderInfo::clear_task() {
  if (task_ != NULL) task_->::apollo::data::recorder::Task::Clear();
  clear_has_task();
}
inline const ::apollo::data::recorder::Task& RecorderInfo::task() const {
  // @@protoc_insertion_point(field_get:apollo.data.recorder.RecorderInfo.task)
  return task_ != NULL ? *task_ : *default_instance_->task_;
}
inline ::apollo::data::recorder::Task* RecorderInfo::mutable_task() {
  set_has_task();
  if (task_ == NULL) {
    task_ = new ::apollo::data::recorder::Task;
  }
  // @@protoc_insertion_point(field_mutable:apollo.data.recorder.RecorderInfo.task)
  return task_;
}
inline ::apollo::data::recorder::Task* RecorderInfo::release_task() {
  // @@protoc_insertion_point(field_release:apollo.data.recorder.RecorderInfo.task)
  clear_has_task();
  ::apollo::data::recorder::Task* temp = task_;
  task_ = NULL;
  return temp;
}
inline void RecorderInfo::set_allocated_task(::apollo::data::recorder::Task* task) {
  delete task_;
  task_ = task;
  if (task) {
    set_has_task();
  } else {
    clear_has_task();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.data.recorder.RecorderInfo.task)
}

// optional .apollo.data.recorder.Disk writing_disk = 3;
inline bool RecorderInfo::has_writing_disk() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RecorderInfo::set_has_writing_disk() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RecorderInfo::clear_has_writing_disk() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RecorderInfo::clear_writing_disk() {
  if (writing_disk_ != NULL) writing_disk_->::apollo::data::recorder::Disk::Clear();
  clear_has_writing_disk();
}
inline const ::apollo::data::recorder::Disk& RecorderInfo::writing_disk() const {
  // @@protoc_insertion_point(field_get:apollo.data.recorder.RecorderInfo.writing_disk)
  return writing_disk_ != NULL ? *writing_disk_ : *default_instance_->writing_disk_;
}
inline ::apollo::data::recorder::Disk* RecorderInfo::mutable_writing_disk() {
  set_has_writing_disk();
  if (writing_disk_ == NULL) {
    writing_disk_ = new ::apollo::data::recorder::Disk;
  }
  // @@protoc_insertion_point(field_mutable:apollo.data.recorder.RecorderInfo.writing_disk)
  return writing_disk_;
}
inline ::apollo::data::recorder::Disk* RecorderInfo::release_writing_disk() {
  // @@protoc_insertion_point(field_release:apollo.data.recorder.RecorderInfo.writing_disk)
  clear_has_writing_disk();
  ::apollo::data::recorder::Disk* temp = writing_disk_;
  writing_disk_ = NULL;
  return temp;
}
inline void RecorderInfo::set_allocated_writing_disk(::apollo::data::recorder::Disk* writing_disk) {
  delete writing_disk_;
  writing_disk_ = writing_disk;
  if (writing_disk) {
    set_has_writing_disk();
  } else {
    clear_has_writing_disk();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.data.recorder.RecorderInfo.writing_disk)
}

// optional .apollo.data.recorder.Data data = 4;
inline bool RecorderInfo::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RecorderInfo::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RecorderInfo::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RecorderInfo::clear_data() {
  if (data_ != NULL) data_->::apollo::data::recorder::Data::Clear();
  clear_has_data();
}
inline const ::apollo::data::recorder::Data& RecorderInfo::data() const {
  // @@protoc_insertion_point(field_get:apollo.data.recorder.RecorderInfo.data)
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::apollo::data::recorder::Data* RecorderInfo::mutable_data() {
  set_has_data();
  if (data_ == NULL) {
    data_ = new ::apollo::data::recorder::Data;
  }
  // @@protoc_insertion_point(field_mutable:apollo.data.recorder.RecorderInfo.data)
  return data_;
}
inline ::apollo::data::recorder::Data* RecorderInfo::release_data() {
  // @@protoc_insertion_point(field_release:apollo.data.recorder.RecorderInfo.data)
  clear_has_data();
  ::apollo::data::recorder::Data* temp = data_;
  data_ = NULL;
  return temp;
}
inline void RecorderInfo::set_allocated_data(::apollo::data::recorder::Data* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.data.recorder.RecorderInfo.data)
}

// optional .apollo.data.recorder.Resources resources = 5;
inline bool RecorderInfo::has_resources() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RecorderInfo::set_has_resources() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RecorderInfo::clear_has_resources() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RecorderInfo::clear_resources() {
  if (resources_ != NULL) resources_->::apollo::data::recorder::Resources::Clear();
  clear_has_resources();
}
inline const ::apollo::data::recorder::Resources& RecorderInfo::resources() const {
  // @@protoc_insertion_point(field_get:apollo.data.recorder.RecorderInfo.resources)
  return resources_ != NULL ? *resources_ : *default_instance_->resources_;
}
inline ::apollo::data::recorder::Resources* RecorderInfo::mutable_resources() {
  set_has_resources();
  if (resources_ == NULL) {
    resources_ = new ::apollo::data::recorder::Resources;
  }
  // @@protoc_insertion_point(field_mutable:apollo.data.recorder.RecorderInfo.resources)
  return resources_;
}
inline ::apollo::data::recorder::Resources* RecorderInfo::release_resources() {
  // @@protoc_insertion_point(field_release:apollo.data.recorder.RecorderInfo.resources)
  clear_has_resources();
  ::apollo::data::recorder::Resources* temp = resources_;
  resources_ = NULL;
  return temp;
}
inline void RecorderInfo::set_allocated_resources(::apollo::data::recorder::Resources* resources) {
  delete resources_;
  resources_ = resources;
  if (resources) {
    set_has_resources();
  } else {
    clear_has_resources();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.data.recorder.RecorderInfo.resources)
}

// -------------------------------------------------------------------

// Task

// optional string id = 1;
inline bool Task::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Task::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Task::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Task::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& Task::id() const {
  // @@protoc_insertion_point(field_get:apollo.data.recorder.Task.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Task::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.data.recorder.Task.id)
}
inline void Task::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.data.recorder.Task.id)
}
inline void Task::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.data.recorder.Task.id)
}
inline ::std::string* Task::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:apollo.data.recorder.Task.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Task::release_id() {
  // @@protoc_insertion_point(field_release:apollo.data.recorder.Task.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Task::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:apollo.data.recorder.Task.id)
}

// optional uint32 sequence = 2;
inline bool Task::has_sequence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Task::set_has_sequence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Task::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Task::clear_sequence() {
  sequence_ = 0u;
  clear_has_sequence();
}
inline ::google::protobuf::uint32 Task::sequence() const {
  // @@protoc_insertion_point(field_get:apollo.data.recorder.Task.sequence)
  return sequence_;
}
inline void Task::set_sequence(::google::protobuf::uint32 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:apollo.data.recorder.Task.sequence)
}

// optional double duration = 3;
inline bool Task::has_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Task::set_has_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Task::clear_has_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Task::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline double Task::duration() const {
  // @@protoc_insertion_point(field_get:apollo.data.recorder.Task.duration)
  return duration_;
}
inline void Task::set_duration(double value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:apollo.data.recorder.Task.duration)
}

// -------------------------------------------------------------------

// Disk

// optional string sn = 1;
inline bool Disk::has_sn() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Disk::set_has_sn() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Disk::clear_has_sn() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Disk::clear_sn() {
  sn_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sn();
}
inline const ::std::string& Disk::sn() const {
  // @@protoc_insertion_point(field_get:apollo.data.recorder.Disk.sn)
  return sn_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Disk::set_sn(const ::std::string& value) {
  set_has_sn();
  sn_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.data.recorder.Disk.sn)
}
inline void Disk::set_sn(const char* value) {
  set_has_sn();
  sn_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.data.recorder.Disk.sn)
}
inline void Disk::set_sn(const char* value, size_t size) {
  set_has_sn();
  sn_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.data.recorder.Disk.sn)
}
inline ::std::string* Disk::mutable_sn() {
  set_has_sn();
  // @@protoc_insertion_point(field_mutable:apollo.data.recorder.Disk.sn)
  return sn_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Disk::release_sn() {
  // @@protoc_insertion_point(field_release:apollo.data.recorder.Disk.sn)
  clear_has_sn();
  return sn_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Disk::set_allocated_sn(::std::string* sn) {
  if (sn != NULL) {
    set_has_sn();
  } else {
    clear_has_sn();
  }
  sn_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sn);
  // @@protoc_insertion_point(field_set_allocated:apollo.data.recorder.Disk.sn)
}

// optional string fs = 2;
inline bool Disk::has_fs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Disk::set_has_fs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Disk::clear_has_fs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Disk::clear_fs() {
  fs_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fs();
}
inline const ::std::string& Disk::fs() const {
  // @@protoc_insertion_point(field_get:apollo.data.recorder.Disk.fs)
  return fs_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Disk::set_fs(const ::std::string& value) {
  set_has_fs();
  fs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.data.recorder.Disk.fs)
}
inline void Disk::set_fs(const char* value) {
  set_has_fs();
  fs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.data.recorder.Disk.fs)
}
inline void Disk::set_fs(const char* value, size_t size) {
  set_has_fs();
  fs_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.data.recorder.Disk.fs)
}
inline ::std::string* Disk::mutable_fs() {
  set_has_fs();
  // @@protoc_insertion_point(field_mutable:apollo.data.recorder.Disk.fs)
  return fs_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Disk::release_fs() {
  // @@protoc_insertion_point(field_release:apollo.data.recorder.Disk.fs)
  clear_has_fs();
  return fs_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Disk::set_allocated_fs(::std::string* fs) {
  if (fs != NULL) {
    set_has_fs();
  } else {
    clear_has_fs();
  }
  fs_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fs);
  // @@protoc_insertion_point(field_set_allocated:apollo.data.recorder.Disk.fs)
}

// optional double size = 3;
inline bool Disk::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Disk::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Disk::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Disk::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline double Disk::size() const {
  // @@protoc_insertion_point(field_get:apollo.data.recorder.Disk.size)
  return size_;
}
inline void Disk::set_size(double value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:apollo.data.recorder.Disk.size)
}

// optional double used = 4;
inline bool Disk::has_used() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Disk::set_has_used() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Disk::clear_has_used() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Disk::clear_used() {
  used_ = 0;
  clear_has_used();
}
inline double Disk::used() const {
  // @@protoc_insertion_point(field_get:apollo.data.recorder.Disk.used)
  return used_;
}
inline void Disk::set_used(double value) {
  set_has_used();
  used_ = value;
  // @@protoc_insertion_point(field_set:apollo.data.recorder.Disk.used)
}

// optional double avail = 5;
inline bool Disk::has_avail() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Disk::set_has_avail() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Disk::clear_has_avail() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Disk::clear_avail() {
  avail_ = 0;
  clear_has_avail();
}
inline double Disk::avail() const {
  // @@protoc_insertion_point(field_get:apollo.data.recorder.Disk.avail)
  return avail_;
}
inline void Disk::set_avail(double value) {
  set_has_avail();
  avail_ = value;
  // @@protoc_insertion_point(field_set:apollo.data.recorder.Disk.avail)
}

// optional double use_percent = 6;
inline bool Disk::has_use_percent() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Disk::set_has_use_percent() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Disk::clear_has_use_percent() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Disk::clear_use_percent() {
  use_percent_ = 0;
  clear_has_use_percent();
}
inline double Disk::use_percent() const {
  // @@protoc_insertion_point(field_get:apollo.data.recorder.Disk.use_percent)
  return use_percent_;
}
inline void Disk::set_use_percent(double value) {
  set_has_use_percent();
  use_percent_ = value;
  // @@protoc_insertion_point(field_set:apollo.data.recorder.Disk.use_percent)
}

// optional string mount = 7;
inline bool Disk::has_mount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Disk::set_has_mount() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Disk::clear_has_mount() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Disk::clear_mount() {
  mount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mount();
}
inline const ::std::string& Disk::mount() const {
  // @@protoc_insertion_point(field_get:apollo.data.recorder.Disk.mount)
  return mount_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Disk::set_mount(const ::std::string& value) {
  set_has_mount();
  mount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.data.recorder.Disk.mount)
}
inline void Disk::set_mount(const char* value) {
  set_has_mount();
  mount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.data.recorder.Disk.mount)
}
inline void Disk::set_mount(const char* value, size_t size) {
  set_has_mount();
  mount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.data.recorder.Disk.mount)
}
inline ::std::string* Disk::mutable_mount() {
  set_has_mount();
  // @@protoc_insertion_point(field_mutable:apollo.data.recorder.Disk.mount)
  return mount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Disk::release_mount() {
  // @@protoc_insertion_point(field_release:apollo.data.recorder.Disk.mount)
  clear_has_mount();
  return mount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Disk::set_allocated_mount(::std::string* mount) {
  if (mount != NULL) {
    set_has_mount();
  } else {
    clear_has_mount();
  }
  mount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mount);
  // @@protoc_insertion_point(field_set_allocated:apollo.data.recorder.Disk.mount)
}

// optional string slot = 8;
inline bool Disk::has_slot() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Disk::set_has_slot() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Disk::clear_has_slot() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Disk::clear_slot() {
  slot_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_slot();
}
inline const ::std::string& Disk::slot() const {
  // @@protoc_insertion_point(field_get:apollo.data.recorder.Disk.slot)
  return slot_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Disk::set_slot(const ::std::string& value) {
  set_has_slot();
  slot_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.data.recorder.Disk.slot)
}
inline void Disk::set_slot(const char* value) {
  set_has_slot();
  slot_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.data.recorder.Disk.slot)
}
inline void Disk::set_slot(const char* value, size_t size) {
  set_has_slot();
  slot_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.data.recorder.Disk.slot)
}
inline ::std::string* Disk::mutable_slot() {
  set_has_slot();
  // @@protoc_insertion_point(field_mutable:apollo.data.recorder.Disk.slot)
  return slot_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Disk::release_slot() {
  // @@protoc_insertion_point(field_release:apollo.data.recorder.Disk.slot)
  clear_has_slot();
  return slot_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Disk::set_allocated_slot(::std::string* slot) {
  if (slot != NULL) {
    set_has_slot();
  } else {
    clear_has_slot();
  }
  slot_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), slot);
  // @@protoc_insertion_point(field_set_allocated:apollo.data.recorder.Disk.slot)
}

// -------------------------------------------------------------------

// Resources

// repeated .apollo.data.recorder.Disk disks = 1;
inline int Resources::disks_size() const {
  return disks_.size();
}
inline void Resources::clear_disks() {
  disks_.Clear();
}
inline const ::apollo::data::recorder::Disk& Resources::disks(int index) const {
  // @@protoc_insertion_point(field_get:apollo.data.recorder.Resources.disks)
  return disks_.Get(index);
}
inline ::apollo::data::recorder::Disk* Resources::mutable_disks(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.data.recorder.Resources.disks)
  return disks_.Mutable(index);
}
inline ::apollo::data::recorder::Disk* Resources::add_disks() {
  // @@protoc_insertion_point(field_add:apollo.data.recorder.Resources.disks)
  return disks_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::data::recorder::Disk >*
Resources::mutable_disks() {
  // @@protoc_insertion_point(field_mutable_list:apollo.data.recorder.Resources.disks)
  return &disks_;
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::data::recorder::Disk >&
Resources::disks() const {
  // @@protoc_insertion_point(field_list:apollo.data.recorder.Resources.disks)
  return disks_;
}

// -------------------------------------------------------------------

// Data

// repeated .apollo.data.recorder.Bag bags = 1;
inline int Data::bags_size() const {
  return bags_.size();
}
inline void Data::clear_bags() {
  bags_.Clear();
}
inline const ::apollo::data::recorder::Bag& Data::bags(int index) const {
  // @@protoc_insertion_point(field_get:apollo.data.recorder.Data.bags)
  return bags_.Get(index);
}
inline ::apollo::data::recorder::Bag* Data::mutable_bags(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.data.recorder.Data.bags)
  return bags_.Mutable(index);
}
inline ::apollo::data::recorder::Bag* Data::add_bags() {
  // @@protoc_insertion_point(field_add:apollo.data.recorder.Data.bags)
  return bags_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::data::recorder::Bag >*
Data::mutable_bags() {
  // @@protoc_insertion_point(field_mutable_list:apollo.data.recorder.Data.bags)
  return &bags_;
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::data::recorder::Bag >&
Data::bags() const {
  // @@protoc_insertion_point(field_list:apollo.data.recorder.Data.bags)
  return bags_;
}

// -------------------------------------------------------------------

// Bag

// optional string writing_filename = 1;
inline bool Bag::has_writing_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Bag::set_has_writing_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Bag::clear_has_writing_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Bag::clear_writing_filename() {
  writing_filename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_writing_filename();
}
inline const ::std::string& Bag::writing_filename() const {
  // @@protoc_insertion_point(field_get:apollo.data.recorder.Bag.writing_filename)
  return writing_filename_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Bag::set_writing_filename(const ::std::string& value) {
  set_has_writing_filename();
  writing_filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.data.recorder.Bag.writing_filename)
}
inline void Bag::set_writing_filename(const char* value) {
  set_has_writing_filename();
  writing_filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.data.recorder.Bag.writing_filename)
}
inline void Bag::set_writing_filename(const char* value, size_t size) {
  set_has_writing_filename();
  writing_filename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.data.recorder.Bag.writing_filename)
}
inline ::std::string* Bag::mutable_writing_filename() {
  set_has_writing_filename();
  // @@protoc_insertion_point(field_mutable:apollo.data.recorder.Bag.writing_filename)
  return writing_filename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Bag::release_writing_filename() {
  // @@protoc_insertion_point(field_release:apollo.data.recorder.Bag.writing_filename)
  clear_has_writing_filename();
  return writing_filename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Bag::set_allocated_writing_filename(::std::string* writing_filename) {
  if (writing_filename != NULL) {
    set_has_writing_filename();
  } else {
    clear_has_writing_filename();
  }
  writing_filename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), writing_filename);
  // @@protoc_insertion_point(field_set_allocated:apollo.data.recorder.Bag.writing_filename)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace recorder
}  // namespace data
}  // namespace apollo

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::apollo::data::recorder::StatusType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::data::recorder::StatusType>() {
  return ::apollo::data::recorder::StatusType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_data_2frecorder_5finfo_2eproto__INCLUDED
