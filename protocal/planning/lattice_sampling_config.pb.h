// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: planning/lattice_sampling_config.proto

#ifndef PROTOBUF_planning_2flattice_5fsampling_5fconfig_2eproto__INCLUDED
#define PROTOBUF_planning_2flattice_5fsampling_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace apollo {
namespace planning {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_planning_2flattice_5fsampling_5fconfig_2eproto();
void protobuf_AssignDesc_planning_2flattice_5fsampling_5fconfig_2eproto();
void protobuf_ShutdownFile_planning_2flattice_5fsampling_5fconfig_2eproto();

class LatCondition;
class LatSampleConfig;
class LatticeSamplingConfig;
class LonCondition;
class LonSampleConfig;
class SStrategy;
class TStrategy;

// ===================================================================

class LonCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.LonCondition) */ {
 public:
  LonCondition();
  virtual ~LonCondition();

  LonCondition(const LonCondition& from);

  inline LonCondition& operator=(const LonCondition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LonCondition& default_instance();

  void Swap(LonCondition* other);

  // implements Message ----------------------------------------------

  inline LonCondition* New() const { return New(NULL); }

  LonCondition* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LonCondition& from);
  void MergeFrom(const LonCondition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LonCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double s = 1 [default = 0];
  bool has_s() const;
  void clear_s();
  static const int kSFieldNumber = 1;
  double s() const;
  void set_s(double value);

  // optional double ds = 2 [default = 0];
  bool has_ds() const;
  void clear_ds();
  static const int kDsFieldNumber = 2;
  double ds() const;
  void set_ds(double value);

  // optional double dds = 3 [default = 0];
  bool has_dds() const;
  void clear_dds();
  static const int kDdsFieldNumber = 3;
  double dds() const;
  void set_dds(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.LonCondition)
 private:
  inline void set_has_s();
  inline void clear_has_s();
  inline void set_has_ds();
  inline void clear_has_ds();
  inline void set_has_dds();
  inline void clear_has_dds();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double s_;
  double ds_;
  double dds_;
  friend void  protobuf_AddDesc_planning_2flattice_5fsampling_5fconfig_2eproto();
  friend void protobuf_AssignDesc_planning_2flattice_5fsampling_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_planning_2flattice_5fsampling_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static LonCondition* default_instance_;
};
// -------------------------------------------------------------------

class LatCondition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.LatCondition) */ {
 public:
  LatCondition();
  virtual ~LatCondition();

  LatCondition(const LatCondition& from);

  inline LatCondition& operator=(const LatCondition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LatCondition& default_instance();

  void Swap(LatCondition* other);

  // implements Message ----------------------------------------------

  inline LatCondition* New() const { return New(NULL); }

  LatCondition* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LatCondition& from);
  void MergeFrom(const LatCondition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LatCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double l = 1 [default = 0];
  bool has_l() const;
  void clear_l();
  static const int kLFieldNumber = 1;
  double l() const;
  void set_l(double value);

  // optional double dl = 2 [default = 0];
  bool has_dl() const;
  void clear_dl();
  static const int kDlFieldNumber = 2;
  double dl() const;
  void set_dl(double value);

  // optional double ddl = 3 [default = 0];
  bool has_ddl() const;
  void clear_ddl();
  static const int kDdlFieldNumber = 3;
  double ddl() const;
  void set_ddl(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.LatCondition)
 private:
  inline void set_has_l();
  inline void clear_has_l();
  inline void set_has_dl();
  inline void clear_has_dl();
  inline void set_has_ddl();
  inline void clear_has_ddl();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double l_;
  double dl_;
  double ddl_;
  friend void  protobuf_AddDesc_planning_2flattice_5fsampling_5fconfig_2eproto();
  friend void protobuf_AssignDesc_planning_2flattice_5fsampling_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_planning_2flattice_5fsampling_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static LatCondition* default_instance_;
};
// -------------------------------------------------------------------

class TStrategy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.TStrategy) */ {
 public:
  TStrategy();
  virtual ~TStrategy();

  TStrategy(const TStrategy& from);

  inline TStrategy& operator=(const TStrategy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TStrategy& default_instance();

  void Swap(TStrategy* other);

  // implements Message ----------------------------------------------

  inline TStrategy* New() const { return New(NULL); }

  TStrategy* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TStrategy& from);
  void MergeFrom(const TStrategy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TStrategy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double t_markers = 1;
  int t_markers_size() const;
  void clear_t_markers();
  static const int kTMarkersFieldNumber = 1;
  double t_markers(int index) const;
  void set_t_markers(int index, double value);
  void add_t_markers(double value);
  const ::google::protobuf::RepeatedField< double >&
      t_markers() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_t_markers();

  // optional double t_step = 2 [default = 0.5];
  bool has_t_step() const;
  void clear_t_step();
  static const int kTStepFieldNumber = 2;
  double t_step() const;
  void set_t_step(double value);

  // optional string strategy = 3;
  bool has_strategy() const;
  void clear_strategy();
  static const int kStrategyFieldNumber = 3;
  const ::std::string& strategy() const;
  void set_strategy(const ::std::string& value);
  void set_strategy(const char* value);
  void set_strategy(const char* value, size_t size);
  ::std::string* mutable_strategy();
  ::std::string* release_strategy();
  void set_allocated_strategy(::std::string* strategy);

  // @@protoc_insertion_point(class_scope:apollo.planning.TStrategy)
 private:
  inline void set_has_t_step();
  inline void clear_has_t_step();
  inline void set_has_strategy();
  inline void clear_has_strategy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > t_markers_;
  double t_step_;
  ::google::protobuf::internal::ArenaStringPtr strategy_;
  friend void  protobuf_AddDesc_planning_2flattice_5fsampling_5fconfig_2eproto();
  friend void protobuf_AssignDesc_planning_2flattice_5fsampling_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_planning_2flattice_5fsampling_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TStrategy* default_instance_;
};
// -------------------------------------------------------------------

class SStrategy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.SStrategy) */ {
 public:
  SStrategy();
  virtual ~SStrategy();

  SStrategy(const SStrategy& from);

  inline SStrategy& operator=(const SStrategy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SStrategy& default_instance();

  void Swap(SStrategy* other);

  // implements Message ----------------------------------------------

  inline SStrategy* New() const { return New(NULL); }

  SStrategy* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SStrategy& from);
  void MergeFrom(const SStrategy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SStrategy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double s_markers = 1;
  int s_markers_size() const;
  void clear_s_markers();
  static const int kSMarkersFieldNumber = 1;
  double s_markers(int index) const;
  void set_s_markers(int index, double value);
  void add_s_markers(double value);
  const ::google::protobuf::RepeatedField< double >&
      s_markers() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_s_markers();

  // optional double s_step = 2 [default = 0.5];
  bool has_s_step() const;
  void clear_s_step();
  static const int kSStepFieldNumber = 2;
  double s_step() const;
  void set_s_step(double value);

  // optional string strategy = 3;
  bool has_strategy() const;
  void clear_strategy();
  static const int kStrategyFieldNumber = 3;
  const ::std::string& strategy() const;
  void set_strategy(const ::std::string& value);
  void set_strategy(const char* value);
  void set_strategy(const char* value, size_t size);
  ::std::string* mutable_strategy();
  ::std::string* release_strategy();
  void set_allocated_strategy(::std::string* strategy);

  // @@protoc_insertion_point(class_scope:apollo.planning.SStrategy)
 private:
  inline void set_has_s_step();
  inline void clear_has_s_step();
  inline void set_has_strategy();
  inline void clear_has_strategy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > s_markers_;
  double s_step_;
  ::google::protobuf::internal::ArenaStringPtr strategy_;
  friend void  protobuf_AddDesc_planning_2flattice_5fsampling_5fconfig_2eproto();
  friend void protobuf_AssignDesc_planning_2flattice_5fsampling_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_planning_2flattice_5fsampling_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static SStrategy* default_instance_;
};
// -------------------------------------------------------------------

class LonSampleConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.LonSampleConfig) */ {
 public:
  LonSampleConfig();
  virtual ~LonSampleConfig();

  LonSampleConfig(const LonSampleConfig& from);

  inline LonSampleConfig& operator=(const LonSampleConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LonSampleConfig& default_instance();

  void Swap(LonSampleConfig* other);

  // implements Message ----------------------------------------------

  inline LonSampleConfig* New() const { return New(NULL); }

  LonSampleConfig* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LonSampleConfig& from);
  void MergeFrom(const LonSampleConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LonSampleConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .apollo.planning.LonCondition lon_end_condition = 1;
  bool has_lon_end_condition() const;
  void clear_lon_end_condition();
  static const int kLonEndConditionFieldNumber = 1;
  const ::apollo::planning::LonCondition& lon_end_condition() const;
  ::apollo::planning::LonCondition* mutable_lon_end_condition();
  ::apollo::planning::LonCondition* release_lon_end_condition();
  void set_allocated_lon_end_condition(::apollo::planning::LonCondition* lon_end_condition);

  // optional .apollo.planning.TStrategy t_strategy = 2;
  bool has_t_strategy() const;
  void clear_t_strategy();
  static const int kTStrategyFieldNumber = 2;
  const ::apollo::planning::TStrategy& t_strategy() const;
  ::apollo::planning::TStrategy* mutable_t_strategy();
  ::apollo::planning::TStrategy* release_t_strategy();
  void set_allocated_t_strategy(::apollo::planning::TStrategy* t_strategy);

  // @@protoc_insertion_point(class_scope:apollo.planning.LonSampleConfig)
 private:
  inline void set_has_lon_end_condition();
  inline void clear_has_lon_end_condition();
  inline void set_has_t_strategy();
  inline void clear_has_t_strategy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::apollo::planning::LonCondition* lon_end_condition_;
  ::apollo::planning::TStrategy* t_strategy_;
  friend void  protobuf_AddDesc_planning_2flattice_5fsampling_5fconfig_2eproto();
  friend void protobuf_AssignDesc_planning_2flattice_5fsampling_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_planning_2flattice_5fsampling_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static LonSampleConfig* default_instance_;
};
// -------------------------------------------------------------------

class LatSampleConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.LatSampleConfig) */ {
 public:
  LatSampleConfig();
  virtual ~LatSampleConfig();

  LatSampleConfig(const LatSampleConfig& from);

  inline LatSampleConfig& operator=(const LatSampleConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LatSampleConfig& default_instance();

  void Swap(LatSampleConfig* other);

  // implements Message ----------------------------------------------

  inline LatSampleConfig* New() const { return New(NULL); }

  LatSampleConfig* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LatSampleConfig& from);
  void MergeFrom(const LatSampleConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LatSampleConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .apollo.planning.LatCondition lat_end_condition = 1;
  bool has_lat_end_condition() const;
  void clear_lat_end_condition();
  static const int kLatEndConditionFieldNumber = 1;
  const ::apollo::planning::LatCondition& lat_end_condition() const;
  ::apollo::planning::LatCondition* mutable_lat_end_condition();
  ::apollo::planning::LatCondition* release_lat_end_condition();
  void set_allocated_lat_end_condition(::apollo::planning::LatCondition* lat_end_condition);

  // optional .apollo.planning.SStrategy s_strategy = 2;
  bool has_s_strategy() const;
  void clear_s_strategy();
  static const int kSStrategyFieldNumber = 2;
  const ::apollo::planning::SStrategy& s_strategy() const;
  ::apollo::planning::SStrategy* mutable_s_strategy();
  ::apollo::planning::SStrategy* release_s_strategy();
  void set_allocated_s_strategy(::apollo::planning::SStrategy* s_strategy);

  // @@protoc_insertion_point(class_scope:apollo.planning.LatSampleConfig)
 private:
  inline void set_has_lat_end_condition();
  inline void clear_has_lat_end_condition();
  inline void set_has_s_strategy();
  inline void clear_has_s_strategy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::apollo::planning::LatCondition* lat_end_condition_;
  ::apollo::planning::SStrategy* s_strategy_;
  friend void  protobuf_AddDesc_planning_2flattice_5fsampling_5fconfig_2eproto();
  friend void protobuf_AssignDesc_planning_2flattice_5fsampling_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_planning_2flattice_5fsampling_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static LatSampleConfig* default_instance_;
};
// -------------------------------------------------------------------

class LatticeSamplingConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.LatticeSamplingConfig) */ {
 public:
  LatticeSamplingConfig();
  virtual ~LatticeSamplingConfig();

  LatticeSamplingConfig(const LatticeSamplingConfig& from);

  inline LatticeSamplingConfig& operator=(const LatticeSamplingConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LatticeSamplingConfig& default_instance();

  void Swap(LatticeSamplingConfig* other);

  // implements Message ----------------------------------------------

  inline LatticeSamplingConfig* New() const { return New(NULL); }

  LatticeSamplingConfig* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LatticeSamplingConfig& from);
  void MergeFrom(const LatticeSamplingConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LatticeSamplingConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .apollo.planning.LonSampleConfig lon_sample_config = 1;
  bool has_lon_sample_config() const;
  void clear_lon_sample_config();
  static const int kLonSampleConfigFieldNumber = 1;
  const ::apollo::planning::LonSampleConfig& lon_sample_config() const;
  ::apollo::planning::LonSampleConfig* mutable_lon_sample_config();
  ::apollo::planning::LonSampleConfig* release_lon_sample_config();
  void set_allocated_lon_sample_config(::apollo::planning::LonSampleConfig* lon_sample_config);

  // optional .apollo.planning.LatSampleConfig lat_sample_config = 2;
  bool has_lat_sample_config() const;
  void clear_lat_sample_config();
  static const int kLatSampleConfigFieldNumber = 2;
  const ::apollo::planning::LatSampleConfig& lat_sample_config() const;
  ::apollo::planning::LatSampleConfig* mutable_lat_sample_config();
  ::apollo::planning::LatSampleConfig* release_lat_sample_config();
  void set_allocated_lat_sample_config(::apollo::planning::LatSampleConfig* lat_sample_config);

  // @@protoc_insertion_point(class_scope:apollo.planning.LatticeSamplingConfig)
 private:
  inline void set_has_lon_sample_config();
  inline void clear_has_lon_sample_config();
  inline void set_has_lat_sample_config();
  inline void clear_has_lat_sample_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::apollo::planning::LonSampleConfig* lon_sample_config_;
  ::apollo::planning::LatSampleConfig* lat_sample_config_;
  friend void  protobuf_AddDesc_planning_2flattice_5fsampling_5fconfig_2eproto();
  friend void protobuf_AssignDesc_planning_2flattice_5fsampling_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_planning_2flattice_5fsampling_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static LatticeSamplingConfig* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// LonCondition

// optional double s = 1 [default = 0];
inline bool LonCondition::has_s() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LonCondition::set_has_s() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LonCondition::clear_has_s() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LonCondition::clear_s() {
  s_ = 0;
  clear_has_s();
}
inline double LonCondition::s() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LonCondition.s)
  return s_;
}
inline void LonCondition::set_s(double value) {
  set_has_s();
  s_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.LonCondition.s)
}

// optional double ds = 2 [default = 0];
inline bool LonCondition::has_ds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LonCondition::set_has_ds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LonCondition::clear_has_ds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LonCondition::clear_ds() {
  ds_ = 0;
  clear_has_ds();
}
inline double LonCondition::ds() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LonCondition.ds)
  return ds_;
}
inline void LonCondition::set_ds(double value) {
  set_has_ds();
  ds_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.LonCondition.ds)
}

// optional double dds = 3 [default = 0];
inline bool LonCondition::has_dds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LonCondition::set_has_dds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LonCondition::clear_has_dds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LonCondition::clear_dds() {
  dds_ = 0;
  clear_has_dds();
}
inline double LonCondition::dds() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LonCondition.dds)
  return dds_;
}
inline void LonCondition::set_dds(double value) {
  set_has_dds();
  dds_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.LonCondition.dds)
}

// -------------------------------------------------------------------

// LatCondition

// optional double l = 1 [default = 0];
inline bool LatCondition::has_l() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LatCondition::set_has_l() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LatCondition::clear_has_l() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LatCondition::clear_l() {
  l_ = 0;
  clear_has_l();
}
inline double LatCondition::l() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LatCondition.l)
  return l_;
}
inline void LatCondition::set_l(double value) {
  set_has_l();
  l_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.LatCondition.l)
}

// optional double dl = 2 [default = 0];
inline bool LatCondition::has_dl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LatCondition::set_has_dl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LatCondition::clear_has_dl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LatCondition::clear_dl() {
  dl_ = 0;
  clear_has_dl();
}
inline double LatCondition::dl() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LatCondition.dl)
  return dl_;
}
inline void LatCondition::set_dl(double value) {
  set_has_dl();
  dl_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.LatCondition.dl)
}

// optional double ddl = 3 [default = 0];
inline bool LatCondition::has_ddl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LatCondition::set_has_ddl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LatCondition::clear_has_ddl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LatCondition::clear_ddl() {
  ddl_ = 0;
  clear_has_ddl();
}
inline double LatCondition::ddl() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LatCondition.ddl)
  return ddl_;
}
inline void LatCondition::set_ddl(double value) {
  set_has_ddl();
  ddl_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.LatCondition.ddl)
}

// -------------------------------------------------------------------

// TStrategy

// repeated double t_markers = 1;
inline int TStrategy::t_markers_size() const {
  return t_markers_.size();
}
inline void TStrategy::clear_t_markers() {
  t_markers_.Clear();
}
inline double TStrategy::t_markers(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.TStrategy.t_markers)
  return t_markers_.Get(index);
}
inline void TStrategy::set_t_markers(int index, double value) {
  t_markers_.Set(index, value);
  // @@protoc_insertion_point(field_set:apollo.planning.TStrategy.t_markers)
}
inline void TStrategy::add_t_markers(double value) {
  t_markers_.Add(value);
  // @@protoc_insertion_point(field_add:apollo.planning.TStrategy.t_markers)
}
inline const ::google::protobuf::RepeatedField< double >&
TStrategy::t_markers() const {
  // @@protoc_insertion_point(field_list:apollo.planning.TStrategy.t_markers)
  return t_markers_;
}
inline ::google::protobuf::RepeatedField< double >*
TStrategy::mutable_t_markers() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.TStrategy.t_markers)
  return &t_markers_;
}

// optional double t_step = 2 [default = 0.5];
inline bool TStrategy::has_t_step() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TStrategy::set_has_t_step() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TStrategy::clear_has_t_step() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TStrategy::clear_t_step() {
  t_step_ = 0.5;
  clear_has_t_step();
}
inline double TStrategy::t_step() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TStrategy.t_step)
  return t_step_;
}
inline void TStrategy::set_t_step(double value) {
  set_has_t_step();
  t_step_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.TStrategy.t_step)
}

// optional string strategy = 3;
inline bool TStrategy::has_strategy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TStrategy::set_has_strategy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TStrategy::clear_has_strategy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TStrategy::clear_strategy() {
  strategy_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_strategy();
}
inline const ::std::string& TStrategy::strategy() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TStrategy.strategy)
  return strategy_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStrategy::set_strategy(const ::std::string& value) {
  set_has_strategy();
  strategy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.planning.TStrategy.strategy)
}
inline void TStrategy::set_strategy(const char* value) {
  set_has_strategy();
  strategy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.TStrategy.strategy)
}
inline void TStrategy::set_strategy(const char* value, size_t size) {
  set_has_strategy();
  strategy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.TStrategy.strategy)
}
inline ::std::string* TStrategy::mutable_strategy() {
  set_has_strategy();
  // @@protoc_insertion_point(field_mutable:apollo.planning.TStrategy.strategy)
  return strategy_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TStrategy::release_strategy() {
  // @@protoc_insertion_point(field_release:apollo.planning.TStrategy.strategy)
  clear_has_strategy();
  return strategy_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TStrategy::set_allocated_strategy(::std::string* strategy) {
  if (strategy != NULL) {
    set_has_strategy();
  } else {
    clear_has_strategy();
  }
  strategy_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), strategy);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TStrategy.strategy)
}

// -------------------------------------------------------------------

// SStrategy

// repeated double s_markers = 1;
inline int SStrategy::s_markers_size() const {
  return s_markers_.size();
}
inline void SStrategy::clear_s_markers() {
  s_markers_.Clear();
}
inline double SStrategy::s_markers(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.SStrategy.s_markers)
  return s_markers_.Get(index);
}
inline void SStrategy::set_s_markers(int index, double value) {
  s_markers_.Set(index, value);
  // @@protoc_insertion_point(field_set:apollo.planning.SStrategy.s_markers)
}
inline void SStrategy::add_s_markers(double value) {
  s_markers_.Add(value);
  // @@protoc_insertion_point(field_add:apollo.planning.SStrategy.s_markers)
}
inline const ::google::protobuf::RepeatedField< double >&
SStrategy::s_markers() const {
  // @@protoc_insertion_point(field_list:apollo.planning.SStrategy.s_markers)
  return s_markers_;
}
inline ::google::protobuf::RepeatedField< double >*
SStrategy::mutable_s_markers() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.SStrategy.s_markers)
  return &s_markers_;
}

// optional double s_step = 2 [default = 0.5];
inline bool SStrategy::has_s_step() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SStrategy::set_has_s_step() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SStrategy::clear_has_s_step() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SStrategy::clear_s_step() {
  s_step_ = 0.5;
  clear_has_s_step();
}
inline double SStrategy::s_step() const {
  // @@protoc_insertion_point(field_get:apollo.planning.SStrategy.s_step)
  return s_step_;
}
inline void SStrategy::set_s_step(double value) {
  set_has_s_step();
  s_step_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.SStrategy.s_step)
}

// optional string strategy = 3;
inline bool SStrategy::has_strategy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SStrategy::set_has_strategy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SStrategy::clear_has_strategy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SStrategy::clear_strategy() {
  strategy_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_strategy();
}
inline const ::std::string& SStrategy::strategy() const {
  // @@protoc_insertion_point(field_get:apollo.planning.SStrategy.strategy)
  return strategy_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SStrategy::set_strategy(const ::std::string& value) {
  set_has_strategy();
  strategy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.planning.SStrategy.strategy)
}
inline void SStrategy::set_strategy(const char* value) {
  set_has_strategy();
  strategy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.SStrategy.strategy)
}
inline void SStrategy::set_strategy(const char* value, size_t size) {
  set_has_strategy();
  strategy_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.SStrategy.strategy)
}
inline ::std::string* SStrategy::mutable_strategy() {
  set_has_strategy();
  // @@protoc_insertion_point(field_mutable:apollo.planning.SStrategy.strategy)
  return strategy_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SStrategy::release_strategy() {
  // @@protoc_insertion_point(field_release:apollo.planning.SStrategy.strategy)
  clear_has_strategy();
  return strategy_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SStrategy::set_allocated_strategy(::std::string* strategy) {
  if (strategy != NULL) {
    set_has_strategy();
  } else {
    clear_has_strategy();
  }
  strategy_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), strategy);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.SStrategy.strategy)
}

// -------------------------------------------------------------------

// LonSampleConfig

// optional .apollo.planning.LonCondition lon_end_condition = 1;
inline bool LonSampleConfig::has_lon_end_condition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LonSampleConfig::set_has_lon_end_condition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LonSampleConfig::clear_has_lon_end_condition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LonSampleConfig::clear_lon_end_condition() {
  if (lon_end_condition_ != NULL) lon_end_condition_->::apollo::planning::LonCondition::Clear();
  clear_has_lon_end_condition();
}
inline const ::apollo::planning::LonCondition& LonSampleConfig::lon_end_condition() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LonSampleConfig.lon_end_condition)
  return lon_end_condition_ != NULL ? *lon_end_condition_ : *default_instance_->lon_end_condition_;
}
inline ::apollo::planning::LonCondition* LonSampleConfig::mutable_lon_end_condition() {
  set_has_lon_end_condition();
  if (lon_end_condition_ == NULL) {
    lon_end_condition_ = new ::apollo::planning::LonCondition;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.LonSampleConfig.lon_end_condition)
  return lon_end_condition_;
}
inline ::apollo::planning::LonCondition* LonSampleConfig::release_lon_end_condition() {
  // @@protoc_insertion_point(field_release:apollo.planning.LonSampleConfig.lon_end_condition)
  clear_has_lon_end_condition();
  ::apollo::planning::LonCondition* temp = lon_end_condition_;
  lon_end_condition_ = NULL;
  return temp;
}
inline void LonSampleConfig::set_allocated_lon_end_condition(::apollo::planning::LonCondition* lon_end_condition) {
  delete lon_end_condition_;
  lon_end_condition_ = lon_end_condition;
  if (lon_end_condition) {
    set_has_lon_end_condition();
  } else {
    clear_has_lon_end_condition();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LonSampleConfig.lon_end_condition)
}

// optional .apollo.planning.TStrategy t_strategy = 2;
inline bool LonSampleConfig::has_t_strategy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LonSampleConfig::set_has_t_strategy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LonSampleConfig::clear_has_t_strategy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LonSampleConfig::clear_t_strategy() {
  if (t_strategy_ != NULL) t_strategy_->::apollo::planning::TStrategy::Clear();
  clear_has_t_strategy();
}
inline const ::apollo::planning::TStrategy& LonSampleConfig::t_strategy() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LonSampleConfig.t_strategy)
  return t_strategy_ != NULL ? *t_strategy_ : *default_instance_->t_strategy_;
}
inline ::apollo::planning::TStrategy* LonSampleConfig::mutable_t_strategy() {
  set_has_t_strategy();
  if (t_strategy_ == NULL) {
    t_strategy_ = new ::apollo::planning::TStrategy;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.LonSampleConfig.t_strategy)
  return t_strategy_;
}
inline ::apollo::planning::TStrategy* LonSampleConfig::release_t_strategy() {
  // @@protoc_insertion_point(field_release:apollo.planning.LonSampleConfig.t_strategy)
  clear_has_t_strategy();
  ::apollo::planning::TStrategy* temp = t_strategy_;
  t_strategy_ = NULL;
  return temp;
}
inline void LonSampleConfig::set_allocated_t_strategy(::apollo::planning::TStrategy* t_strategy) {
  delete t_strategy_;
  t_strategy_ = t_strategy;
  if (t_strategy) {
    set_has_t_strategy();
  } else {
    clear_has_t_strategy();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LonSampleConfig.t_strategy)
}

// -------------------------------------------------------------------

// LatSampleConfig

// optional .apollo.planning.LatCondition lat_end_condition = 1;
inline bool LatSampleConfig::has_lat_end_condition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LatSampleConfig::set_has_lat_end_condition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LatSampleConfig::clear_has_lat_end_condition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LatSampleConfig::clear_lat_end_condition() {
  if (lat_end_condition_ != NULL) lat_end_condition_->::apollo::planning::LatCondition::Clear();
  clear_has_lat_end_condition();
}
inline const ::apollo::planning::LatCondition& LatSampleConfig::lat_end_condition() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LatSampleConfig.lat_end_condition)
  return lat_end_condition_ != NULL ? *lat_end_condition_ : *default_instance_->lat_end_condition_;
}
inline ::apollo::planning::LatCondition* LatSampleConfig::mutable_lat_end_condition() {
  set_has_lat_end_condition();
  if (lat_end_condition_ == NULL) {
    lat_end_condition_ = new ::apollo::planning::LatCondition;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.LatSampleConfig.lat_end_condition)
  return lat_end_condition_;
}
inline ::apollo::planning::LatCondition* LatSampleConfig::release_lat_end_condition() {
  // @@protoc_insertion_point(field_release:apollo.planning.LatSampleConfig.lat_end_condition)
  clear_has_lat_end_condition();
  ::apollo::planning::LatCondition* temp = lat_end_condition_;
  lat_end_condition_ = NULL;
  return temp;
}
inline void LatSampleConfig::set_allocated_lat_end_condition(::apollo::planning::LatCondition* lat_end_condition) {
  delete lat_end_condition_;
  lat_end_condition_ = lat_end_condition;
  if (lat_end_condition) {
    set_has_lat_end_condition();
  } else {
    clear_has_lat_end_condition();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LatSampleConfig.lat_end_condition)
}

// optional .apollo.planning.SStrategy s_strategy = 2;
inline bool LatSampleConfig::has_s_strategy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LatSampleConfig::set_has_s_strategy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LatSampleConfig::clear_has_s_strategy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LatSampleConfig::clear_s_strategy() {
  if (s_strategy_ != NULL) s_strategy_->::apollo::planning::SStrategy::Clear();
  clear_has_s_strategy();
}
inline const ::apollo::planning::SStrategy& LatSampleConfig::s_strategy() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LatSampleConfig.s_strategy)
  return s_strategy_ != NULL ? *s_strategy_ : *default_instance_->s_strategy_;
}
inline ::apollo::planning::SStrategy* LatSampleConfig::mutable_s_strategy() {
  set_has_s_strategy();
  if (s_strategy_ == NULL) {
    s_strategy_ = new ::apollo::planning::SStrategy;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.LatSampleConfig.s_strategy)
  return s_strategy_;
}
inline ::apollo::planning::SStrategy* LatSampleConfig::release_s_strategy() {
  // @@protoc_insertion_point(field_release:apollo.planning.LatSampleConfig.s_strategy)
  clear_has_s_strategy();
  ::apollo::planning::SStrategy* temp = s_strategy_;
  s_strategy_ = NULL;
  return temp;
}
inline void LatSampleConfig::set_allocated_s_strategy(::apollo::planning::SStrategy* s_strategy) {
  delete s_strategy_;
  s_strategy_ = s_strategy;
  if (s_strategy) {
    set_has_s_strategy();
  } else {
    clear_has_s_strategy();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LatSampleConfig.s_strategy)
}

// -------------------------------------------------------------------

// LatticeSamplingConfig

// optional .apollo.planning.LonSampleConfig lon_sample_config = 1;
inline bool LatticeSamplingConfig::has_lon_sample_config() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LatticeSamplingConfig::set_has_lon_sample_config() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LatticeSamplingConfig::clear_has_lon_sample_config() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LatticeSamplingConfig::clear_lon_sample_config() {
  if (lon_sample_config_ != NULL) lon_sample_config_->::apollo::planning::LonSampleConfig::Clear();
  clear_has_lon_sample_config();
}
inline const ::apollo::planning::LonSampleConfig& LatticeSamplingConfig::lon_sample_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LatticeSamplingConfig.lon_sample_config)
  return lon_sample_config_ != NULL ? *lon_sample_config_ : *default_instance_->lon_sample_config_;
}
inline ::apollo::planning::LonSampleConfig* LatticeSamplingConfig::mutable_lon_sample_config() {
  set_has_lon_sample_config();
  if (lon_sample_config_ == NULL) {
    lon_sample_config_ = new ::apollo::planning::LonSampleConfig;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.LatticeSamplingConfig.lon_sample_config)
  return lon_sample_config_;
}
inline ::apollo::planning::LonSampleConfig* LatticeSamplingConfig::release_lon_sample_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.LatticeSamplingConfig.lon_sample_config)
  clear_has_lon_sample_config();
  ::apollo::planning::LonSampleConfig* temp = lon_sample_config_;
  lon_sample_config_ = NULL;
  return temp;
}
inline void LatticeSamplingConfig::set_allocated_lon_sample_config(::apollo::planning::LonSampleConfig* lon_sample_config) {
  delete lon_sample_config_;
  lon_sample_config_ = lon_sample_config;
  if (lon_sample_config) {
    set_has_lon_sample_config();
  } else {
    clear_has_lon_sample_config();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LatticeSamplingConfig.lon_sample_config)
}

// optional .apollo.planning.LatSampleConfig lat_sample_config = 2;
inline bool LatticeSamplingConfig::has_lat_sample_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LatticeSamplingConfig::set_has_lat_sample_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LatticeSamplingConfig::clear_has_lat_sample_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LatticeSamplingConfig::clear_lat_sample_config() {
  if (lat_sample_config_ != NULL) lat_sample_config_->::apollo::planning::LatSampleConfig::Clear();
  clear_has_lat_sample_config();
}
inline const ::apollo::planning::LatSampleConfig& LatticeSamplingConfig::lat_sample_config() const {
  // @@protoc_insertion_point(field_get:apollo.planning.LatticeSamplingConfig.lat_sample_config)
  return lat_sample_config_ != NULL ? *lat_sample_config_ : *default_instance_->lat_sample_config_;
}
inline ::apollo::planning::LatSampleConfig* LatticeSamplingConfig::mutable_lat_sample_config() {
  set_has_lat_sample_config();
  if (lat_sample_config_ == NULL) {
    lat_sample_config_ = new ::apollo::planning::LatSampleConfig;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.LatticeSamplingConfig.lat_sample_config)
  return lat_sample_config_;
}
inline ::apollo::planning::LatSampleConfig* LatticeSamplingConfig::release_lat_sample_config() {
  // @@protoc_insertion_point(field_release:apollo.planning.LatticeSamplingConfig.lat_sample_config)
  clear_has_lat_sample_config();
  ::apollo::planning::LatSampleConfig* temp = lat_sample_config_;
  lat_sample_config_ = NULL;
  return temp;
}
inline void LatticeSamplingConfig::set_allocated_lat_sample_config(::apollo::planning::LatSampleConfig* lat_sample_config) {
  delete lat_sample_config_;
  lat_sample_config_ = lat_sample_config;
  if (lat_sample_config) {
    set_has_lat_sample_config();
  } else {
    clear_has_lat_sample_config();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.LatticeSamplingConfig.lat_sample_config)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace planning
}  // namespace apollo

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_planning_2flattice_5fsampling_5fconfig_2eproto__INCLUDED
