// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: planning/traffic_rule_config.proto

#ifndef PROTOBUF_planning_2ftraffic_5frule_5fconfig_2eproto__INCLUDED
#define PROTOBUF_planning_2ftraffic_5frule_5fconfig_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace apollo {
namespace planning {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
void protobuf_AssignDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
void protobuf_ShutdownFile_planning_2ftraffic_5frule_5fconfig_2eproto();

class BacksideVehicleConfig;
class ChangeLaneConfig;
class CreepConfig;
class CrosswalkConfig;
class DestinationConfig;
class FrontVehicleConfig;
class KeepClearConfig;
class PullOverConfig;
class ReferenceLineEndConfig;
class ReroutingConfig;
class SignalLightConfig;
class StopSignConfig;
class TrafficRuleConfig;
class TrafficRuleConfigs;

enum TrafficRuleConfig_RuleId {
  TrafficRuleConfig_RuleId_BACKSIDE_VEHICLE = 1,
  TrafficRuleConfig_RuleId_CHANGE_LANE = 2,
  TrafficRuleConfig_RuleId_CROSSWALK = 3,
  TrafficRuleConfig_RuleId_DESTINATION = 4,
  TrafficRuleConfig_RuleId_FRONT_VEHICLE = 5,
  TrafficRuleConfig_RuleId_KEEP_CLEAR = 6,
  TrafficRuleConfig_RuleId_PULL_OVER = 7,
  TrafficRuleConfig_RuleId_REFERENCE_LINE_END = 8,
  TrafficRuleConfig_RuleId_REROUTING = 9,
  TrafficRuleConfig_RuleId_SIGNAL_LIGHT = 10,
  TrafficRuleConfig_RuleId_STOP_SIGN = 11
};
bool TrafficRuleConfig_RuleId_IsValid(int value);
const TrafficRuleConfig_RuleId TrafficRuleConfig_RuleId_RuleId_MIN = TrafficRuleConfig_RuleId_BACKSIDE_VEHICLE;
const TrafficRuleConfig_RuleId TrafficRuleConfig_RuleId_RuleId_MAX = TrafficRuleConfig_RuleId_STOP_SIGN;
const int TrafficRuleConfig_RuleId_RuleId_ARRAYSIZE = TrafficRuleConfig_RuleId_RuleId_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficRuleConfig_RuleId_descriptor();
inline const ::std::string& TrafficRuleConfig_RuleId_Name(TrafficRuleConfig_RuleId value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficRuleConfig_RuleId_descriptor(), value);
}
inline bool TrafficRuleConfig_RuleId_Parse(
    const ::std::string& name, TrafficRuleConfig_RuleId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficRuleConfig_RuleId>(
    TrafficRuleConfig_RuleId_descriptor(), name, value);
}
// ===================================================================

class BacksideVehicleConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.BacksideVehicleConfig) */ {
 public:
  BacksideVehicleConfig();
  virtual ~BacksideVehicleConfig();

  BacksideVehicleConfig(const BacksideVehicleConfig& from);

  inline BacksideVehicleConfig& operator=(const BacksideVehicleConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BacksideVehicleConfig& default_instance();

  void Swap(BacksideVehicleConfig* other);

  // implements Message ----------------------------------------------

  inline BacksideVehicleConfig* New() const { return New(NULL); }

  BacksideVehicleConfig* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BacksideVehicleConfig& from);
  void MergeFrom(const BacksideVehicleConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BacksideVehicleConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double backside_lane_width = 1 [default = 4];
  bool has_backside_lane_width() const;
  void clear_backside_lane_width();
  static const int kBacksideLaneWidthFieldNumber = 1;
  double backside_lane_width() const;
  void set_backside_lane_width(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.BacksideVehicleConfig)
 private:
  inline void set_has_backside_lane_width();
  inline void clear_has_backside_lane_width();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double backside_lane_width_;
  friend void  protobuf_AddDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_AssignDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_planning_2ftraffic_5frule_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static BacksideVehicleConfig* default_instance_;
};
// -------------------------------------------------------------------

class ChangeLaneConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ChangeLaneConfig) */ {
 public:
  ChangeLaneConfig();
  virtual ~ChangeLaneConfig();

  ChangeLaneConfig(const ChangeLaneConfig& from);

  inline ChangeLaneConfig& operator=(const ChangeLaneConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeLaneConfig& default_instance();

  void Swap(ChangeLaneConfig* other);

  // implements Message ----------------------------------------------

  inline ChangeLaneConfig* New() const { return New(NULL); }

  ChangeLaneConfig* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeLaneConfig& from);
  void MergeFrom(const ChangeLaneConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChangeLaneConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double min_overtake_distance = 1 [default = 10];
  bool has_min_overtake_distance() const;
  void clear_min_overtake_distance();
  static const int kMinOvertakeDistanceFieldNumber = 1;
  double min_overtake_distance() const;
  void set_min_overtake_distance(double value);

  // optional double min_overtake_time = 2 [default = 2];
  bool has_min_overtake_time() const;
  void clear_min_overtake_time();
  static const int kMinOvertakeTimeFieldNumber = 2;
  double min_overtake_time() const;
  void set_min_overtake_time(double value);

  // optional bool enable_guard_obstacle = 3 [default = false];
  bool has_enable_guard_obstacle() const;
  void clear_enable_guard_obstacle();
  static const int kEnableGuardObstacleFieldNumber = 3;
  bool enable_guard_obstacle() const;
  void set_enable_guard_obstacle(bool value);

  // optional double guard_distance = 4 [default = 100];
  bool has_guard_distance() const;
  void clear_guard_distance();
  static const int kGuardDistanceFieldNumber = 4;
  double guard_distance() const;
  void set_guard_distance(double value);

  // optional double min_guard_speed = 5 [default = 1];
  bool has_min_guard_speed() const;
  void clear_min_guard_speed();
  static const int kMinGuardSpeedFieldNumber = 5;
  double min_guard_speed() const;
  void set_min_guard_speed(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.ChangeLaneConfig)
 private:
  inline void set_has_min_overtake_distance();
  inline void clear_has_min_overtake_distance();
  inline void set_has_min_overtake_time();
  inline void clear_has_min_overtake_time();
  inline void set_has_enable_guard_obstacle();
  inline void clear_has_enable_guard_obstacle();
  inline void set_has_guard_distance();
  inline void clear_has_guard_distance();
  inline void set_has_min_guard_speed();
  inline void clear_has_min_guard_speed();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double min_overtake_distance_;
  double min_overtake_time_;
  double guard_distance_;
  double min_guard_speed_;
  bool enable_guard_obstacle_;
  friend void  protobuf_AddDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_AssignDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_planning_2ftraffic_5frule_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static ChangeLaneConfig* default_instance_;
};
// -------------------------------------------------------------------

class CreepConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.CreepConfig) */ {
 public:
  CreepConfig();
  virtual ~CreepConfig();

  CreepConfig(const CreepConfig& from);

  inline CreepConfig& operator=(const CreepConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreepConfig& default_instance();

  void Swap(CreepConfig* other);

  // implements Message ----------------------------------------------

  inline CreepConfig* New() const { return New(NULL); }

  CreepConfig* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreepConfig& from);
  void MergeFrom(const CreepConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreepConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enabled = 1;
  bool has_enabled() const;
  void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  bool enabled() const;
  void set_enabled(bool value);

  // optional double creep_distance_to_stop_line = 2 [default = 1];
  bool has_creep_distance_to_stop_line() const;
  void clear_creep_distance_to_stop_line();
  static const int kCreepDistanceToStopLineFieldNumber = 2;
  double creep_distance_to_stop_line() const;
  void set_creep_distance_to_stop_line(double value);

  // optional double stop_distance = 3 [default = 0.5];
  bool has_stop_distance() const;
  void clear_stop_distance();
  static const int kStopDistanceFieldNumber = 3;
  double stop_distance() const;
  void set_stop_distance(double value);

  // optional double speed_limit = 4 [default = 1];
  bool has_speed_limit() const;
  void clear_speed_limit();
  static const int kSpeedLimitFieldNumber = 4;
  double speed_limit() const;
  void set_speed_limit(double value);

  // optional double max_valid_stop_distance = 5 [default = 0.3];
  bool has_max_valid_stop_distance() const;
  void clear_max_valid_stop_distance();
  static const int kMaxValidStopDistanceFieldNumber = 5;
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);

  // optional double min_boundary_t = 6 [default = 6];
  bool has_min_boundary_t() const;
  void clear_min_boundary_t();
  static const int kMinBoundaryTFieldNumber = 6;
  double min_boundary_t() const;
  void set_min_boundary_t(double value);

  // optional double min_boundary_s = 7 [default = 3];
  bool has_min_boundary_s() const;
  void clear_min_boundary_s();
  static const int kMinBoundarySFieldNumber = 7;
  double min_boundary_s() const;
  void set_min_boundary_s(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.CreepConfig)
 private:
  inline void set_has_enabled();
  inline void clear_has_enabled();
  inline void set_has_creep_distance_to_stop_line();
  inline void clear_has_creep_distance_to_stop_line();
  inline void set_has_stop_distance();
  inline void clear_has_stop_distance();
  inline void set_has_speed_limit();
  inline void clear_has_speed_limit();
  inline void set_has_max_valid_stop_distance();
  inline void clear_has_max_valid_stop_distance();
  inline void set_has_min_boundary_t();
  inline void clear_has_min_boundary_t();
  inline void set_has_min_boundary_s();
  inline void clear_has_min_boundary_s();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double creep_distance_to_stop_line_;
  double stop_distance_;
  double speed_limit_;
  double max_valid_stop_distance_;
  double min_boundary_t_;
  double min_boundary_s_;
  bool enabled_;
  friend void  protobuf_AddDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_AssignDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_planning_2ftraffic_5frule_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static CreepConfig* default_instance_;
};
// -------------------------------------------------------------------

class CrosswalkConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.CrosswalkConfig) */ {
 public:
  CrosswalkConfig();
  virtual ~CrosswalkConfig();

  CrosswalkConfig(const CrosswalkConfig& from);

  inline CrosswalkConfig& operator=(const CrosswalkConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CrosswalkConfig& default_instance();

  void Swap(CrosswalkConfig* other);

  // implements Message ----------------------------------------------

  inline CrosswalkConfig* New() const { return New(NULL); }

  CrosswalkConfig* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CrosswalkConfig& from);
  void MergeFrom(const CrosswalkConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CrosswalkConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double stop_distance = 1 [default = 1];
  bool has_stop_distance() const;
  void clear_stop_distance();
  static const int kStopDistanceFieldNumber = 1;
  double stop_distance() const;
  void set_stop_distance(double value);

  // optional double max_stop_deceleration = 2 [default = 4];
  bool has_max_stop_deceleration() const;
  void clear_max_stop_deceleration();
  static const int kMaxStopDecelerationFieldNumber = 2;
  double max_stop_deceleration() const;
  void set_max_stop_deceleration(double value);

  // optional double min_pass_s_distance = 3 [default = 1];
  bool has_min_pass_s_distance() const;
  void clear_min_pass_s_distance();
  static const int kMinPassSDistanceFieldNumber = 3;
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);

  // optional double max_stop_speed = 4 [default = 0.3];
  bool has_max_stop_speed() const;
  void clear_max_stop_speed();
  static const int kMaxStopSpeedFieldNumber = 4;
  double max_stop_speed() const;
  void set_max_stop_speed(double value);

  // optional double max_valid_stop_distance = 5 [default = 3];
  bool has_max_valid_stop_distance() const;
  void clear_max_valid_stop_distance();
  static const int kMaxValidStopDistanceFieldNumber = 5;
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);

  // optional double expand_s_distance = 6 [default = 2];
  bool has_expand_s_distance() const;
  void clear_expand_s_distance();
  static const int kExpandSDistanceFieldNumber = 6;
  double expand_s_distance() const;
  void set_expand_s_distance(double value);

  // optional double stop_strick_l_distance = 7 [default = 4];
  bool has_stop_strick_l_distance() const;
  void clear_stop_strick_l_distance();
  static const int kStopStrickLDistanceFieldNumber = 7;
  double stop_strick_l_distance() const;
  void set_stop_strick_l_distance(double value);

  // optional double stop_loose_l_distance = 8 [default = 5];
  bool has_stop_loose_l_distance() const;
  void clear_stop_loose_l_distance();
  static const int kStopLooseLDistanceFieldNumber = 8;
  double stop_loose_l_distance() const;
  void set_stop_loose_l_distance(double value);

  // optional double stop_timeout = 9 [default = 10];
  bool has_stop_timeout() const;
  void clear_stop_timeout();
  static const int kStopTimeoutFieldNumber = 9;
  double stop_timeout() const;
  void set_stop_timeout(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.CrosswalkConfig)
 private:
  inline void set_has_stop_distance();
  inline void clear_has_stop_distance();
  inline void set_has_max_stop_deceleration();
  inline void clear_has_max_stop_deceleration();
  inline void set_has_min_pass_s_distance();
  inline void clear_has_min_pass_s_distance();
  inline void set_has_max_stop_speed();
  inline void clear_has_max_stop_speed();
  inline void set_has_max_valid_stop_distance();
  inline void clear_has_max_valid_stop_distance();
  inline void set_has_expand_s_distance();
  inline void clear_has_expand_s_distance();
  inline void set_has_stop_strick_l_distance();
  inline void clear_has_stop_strick_l_distance();
  inline void set_has_stop_loose_l_distance();
  inline void clear_has_stop_loose_l_distance();
  inline void set_has_stop_timeout();
  inline void clear_has_stop_timeout();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double stop_distance_;
  double max_stop_deceleration_;
  double min_pass_s_distance_;
  double max_stop_speed_;
  double max_valid_stop_distance_;
  double expand_s_distance_;
  double stop_strick_l_distance_;
  double stop_loose_l_distance_;
  double stop_timeout_;
  friend void  protobuf_AddDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_AssignDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_planning_2ftraffic_5frule_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static CrosswalkConfig* default_instance_;
};
// -------------------------------------------------------------------

class DestinationConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.DestinationConfig) */ {
 public:
  DestinationConfig();
  virtual ~DestinationConfig();

  DestinationConfig(const DestinationConfig& from);

  inline DestinationConfig& operator=(const DestinationConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DestinationConfig& default_instance();

  void Swap(DestinationConfig* other);

  // implements Message ----------------------------------------------

  inline DestinationConfig* New() const { return New(NULL); }

  DestinationConfig* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DestinationConfig& from);
  void MergeFrom(const DestinationConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DestinationConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable_pull_over = 1 [default = false];
  bool has_enable_pull_over() const;
  void clear_enable_pull_over();
  static const int kEnablePullOverFieldNumber = 1;
  bool enable_pull_over() const;
  void set_enable_pull_over(bool value);

  // optional double stop_distance = 2 [default = 0.5];
  bool has_stop_distance() const;
  void clear_stop_distance();
  static const int kStopDistanceFieldNumber = 2;
  double stop_distance() const;
  void set_stop_distance(double value);

  // optional double pull_over_plan_distance = 3 [default = 35];
  bool has_pull_over_plan_distance() const;
  void clear_pull_over_plan_distance();
  static const int kPullOverPlanDistanceFieldNumber = 3;
  double pull_over_plan_distance() const;
  void set_pull_over_plan_distance(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.DestinationConfig)
 private:
  inline void set_has_enable_pull_over();
  inline void clear_has_enable_pull_over();
  inline void set_has_stop_distance();
  inline void clear_has_stop_distance();
  inline void set_has_pull_over_plan_distance();
  inline void clear_has_pull_over_plan_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double stop_distance_;
  double pull_over_plan_distance_;
  bool enable_pull_over_;
  friend void  protobuf_AddDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_AssignDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_planning_2ftraffic_5frule_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static DestinationConfig* default_instance_;
};
// -------------------------------------------------------------------

class FrontVehicleConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.FrontVehicleConfig) */ {
 public:
  FrontVehicleConfig();
  virtual ~FrontVehicleConfig();

  FrontVehicleConfig(const FrontVehicleConfig& from);

  inline FrontVehicleConfig& operator=(const FrontVehicleConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FrontVehicleConfig& default_instance();

  void Swap(FrontVehicleConfig* other);

  // implements Message ----------------------------------------------

  inline FrontVehicleConfig* New() const { return New(NULL); }

  FrontVehicleConfig* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FrontVehicleConfig& from);
  void MergeFrom(const FrontVehicleConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FrontVehicleConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable_side_pass = 1 [default = true];
  bool has_enable_side_pass() const;
  void clear_enable_side_pass();
  static const int kEnableSidePassFieldNumber = 1;
  bool enable_side_pass() const;
  void set_enable_side_pass(bool value);

  // optional double side_pass_s_threshold = 2 [default = 15];
  bool has_side_pass_s_threshold() const;
  void clear_side_pass_s_threshold();
  static const int kSidePassSThresholdFieldNumber = 2;
  double side_pass_s_threshold() const;
  void set_side_pass_s_threshold(double value);

  // optional double side_pass_l_threshold = 3 [default = 1];
  bool has_side_pass_l_threshold() const;
  void clear_side_pass_l_threshold();
  static const int kSidePassLThresholdFieldNumber = 3;
  double side_pass_l_threshold() const;
  void set_side_pass_l_threshold(double value);

  // optional double side_pass_wait_time = 4 [default = 30];
  bool has_side_pass_wait_time() const;
  void clear_side_pass_wait_time();
  static const int kSidePassWaitTimeFieldNumber = 4;
  double side_pass_wait_time() const;
  void set_side_pass_wait_time(double value);

  // optional double nudge_l_buffer = 5 [default = 0.5];
  bool has_nudge_l_buffer() const;
  void clear_nudge_l_buffer();
  static const int kNudgeLBufferFieldNumber = 5;
  double nudge_l_buffer() const;
  void set_nudge_l_buffer(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.FrontVehicleConfig)
 private:
  inline void set_has_enable_side_pass();
  inline void clear_has_enable_side_pass();
  inline void set_has_side_pass_s_threshold();
  inline void clear_has_side_pass_s_threshold();
  inline void set_has_side_pass_l_threshold();
  inline void clear_has_side_pass_l_threshold();
  inline void set_has_side_pass_wait_time();
  inline void clear_has_side_pass_wait_time();
  inline void set_has_nudge_l_buffer();
  inline void clear_has_nudge_l_buffer();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double side_pass_s_threshold_;
  double side_pass_l_threshold_;
  double side_pass_wait_time_;
  double nudge_l_buffer_;
  bool enable_side_pass_;
  friend void  protobuf_AddDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_AssignDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_planning_2ftraffic_5frule_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static FrontVehicleConfig* default_instance_;
};
// -------------------------------------------------------------------

class KeepClearConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.KeepClearConfig) */ {
 public:
  KeepClearConfig();
  virtual ~KeepClearConfig();

  KeepClearConfig(const KeepClearConfig& from);

  inline KeepClearConfig& operator=(const KeepClearConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeepClearConfig& default_instance();

  void Swap(KeepClearConfig* other);

  // implements Message ----------------------------------------------

  inline KeepClearConfig* New() const { return New(NULL); }

  KeepClearConfig* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeepClearConfig& from);
  void MergeFrom(const KeepClearConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(KeepClearConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enable_keep_clear_zone = 1 [default = true];
  bool has_enable_keep_clear_zone() const;
  void clear_enable_keep_clear_zone();
  static const int kEnableKeepClearZoneFieldNumber = 1;
  bool enable_keep_clear_zone() const;
  void set_enable_keep_clear_zone(bool value);

  // optional bool enable_junction = 2 [default = true];
  bool has_enable_junction() const;
  void clear_enable_junction();
  static const int kEnableJunctionFieldNumber = 2;
  bool enable_junction() const;
  void set_enable_junction(bool value);

  // optional double min_pass_s_distance = 3 [default = 2];
  bool has_min_pass_s_distance() const;
  void clear_min_pass_s_distance();
  static const int kMinPassSDistanceFieldNumber = 3;
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.KeepClearConfig)
 private:
  inline void set_has_enable_keep_clear_zone();
  inline void clear_has_enable_keep_clear_zone();
  inline void set_has_enable_junction();
  inline void clear_has_enable_junction();
  inline void set_has_min_pass_s_distance();
  inline void clear_has_min_pass_s_distance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double min_pass_s_distance_;
  bool enable_keep_clear_zone_;
  bool enable_junction_;
  friend void  protobuf_AddDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_AssignDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_planning_2ftraffic_5frule_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static KeepClearConfig* default_instance_;
};
// -------------------------------------------------------------------

class PullOverConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PullOverConfig) */ {
 public:
  PullOverConfig();
  virtual ~PullOverConfig();

  PullOverConfig(const PullOverConfig& from);

  inline PullOverConfig& operator=(const PullOverConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PullOverConfig& default_instance();

  void Swap(PullOverConfig* other);

  // implements Message ----------------------------------------------

  inline PullOverConfig* New() const { return New(NULL); }

  PullOverConfig* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PullOverConfig& from);
  void MergeFrom(const PullOverConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PullOverConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double stop_distance = 1 [default = 0.5];
  bool has_stop_distance() const;
  void clear_stop_distance();
  static const int kStopDistanceFieldNumber = 1;
  double stop_distance() const;
  void set_stop_distance(double value);

  // optional double max_stop_speed = 2 [default = 0.3];
  bool has_max_stop_speed() const;
  void clear_max_stop_speed();
  static const int kMaxStopSpeedFieldNumber = 2;
  double max_stop_speed() const;
  void set_max_stop_speed(double value);

  // optional double max_valid_stop_distance = 3 [default = 3];
  bool has_max_valid_stop_distance() const;
  void clear_max_valid_stop_distance();
  static const int kMaxValidStopDistanceFieldNumber = 3;
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);

  // optional double max_stop_deceleration = 4 [default = 2.5];
  bool has_max_stop_deceleration() const;
  void clear_max_stop_deceleration();
  static const int kMaxStopDecelerationFieldNumber = 4;
  double max_stop_deceleration() const;
  void set_max_stop_deceleration(double value);

  // optional double min_pass_s_distance = 5 [default = 1];
  bool has_min_pass_s_distance() const;
  void clear_min_pass_s_distance();
  static const int kMinPassSDistanceFieldNumber = 5;
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);

  // optional double buffer_to_boundary = 6 [default = 0.5];
  bool has_buffer_to_boundary() const;
  void clear_buffer_to_boundary();
  static const int kBufferToBoundaryFieldNumber = 6;
  double buffer_to_boundary() const;
  void set_buffer_to_boundary(double value);

  // optional double plan_distance = 7 [default = 35];
  bool has_plan_distance() const;
  void clear_plan_distance();
  static const int kPlanDistanceFieldNumber = 7;
  double plan_distance() const;
  void set_plan_distance(double value);

  // optional double operation_length = 8 [default = 30];
  bool has_operation_length() const;
  void clear_operation_length();
  static const int kOperationLengthFieldNumber = 8;
  double operation_length() const;
  void set_operation_length(double value);

  // optional double max_check_distance = 9 [default = 60];
  bool has_max_check_distance() const;
  void clear_max_check_distance();
  static const int kMaxCheckDistanceFieldNumber = 9;
  double max_check_distance() const;
  void set_max_check_distance(double value);

  // optional uint32 max_failure_count = 10 [default = 10];
  bool has_max_failure_count() const;
  void clear_max_failure_count();
  static const int kMaxFailureCountFieldNumber = 10;
  ::google::protobuf::uint32 max_failure_count() const;
  void set_max_failure_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:apollo.planning.PullOverConfig)
 private:
  inline void set_has_stop_distance();
  inline void clear_has_stop_distance();
  inline void set_has_max_stop_speed();
  inline void clear_has_max_stop_speed();
  inline void set_has_max_valid_stop_distance();
  inline void clear_has_max_valid_stop_distance();
  inline void set_has_max_stop_deceleration();
  inline void clear_has_max_stop_deceleration();
  inline void set_has_min_pass_s_distance();
  inline void clear_has_min_pass_s_distance();
  inline void set_has_buffer_to_boundary();
  inline void clear_has_buffer_to_boundary();
  inline void set_has_plan_distance();
  inline void clear_has_plan_distance();
  inline void set_has_operation_length();
  inline void clear_has_operation_length();
  inline void set_has_max_check_distance();
  inline void clear_has_max_check_distance();
  inline void set_has_max_failure_count();
  inline void clear_has_max_failure_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double stop_distance_;
  double max_stop_speed_;
  double max_valid_stop_distance_;
  double max_stop_deceleration_;
  double min_pass_s_distance_;
  double buffer_to_boundary_;
  double plan_distance_;
  double operation_length_;
  double max_check_distance_;
  ::google::protobuf::uint32 max_failure_count_;
  friend void  protobuf_AddDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_AssignDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_planning_2ftraffic_5frule_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static PullOverConfig* default_instance_;
};
// -------------------------------------------------------------------

class ReferenceLineEndConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ReferenceLineEndConfig) */ {
 public:
  ReferenceLineEndConfig();
  virtual ~ReferenceLineEndConfig();

  ReferenceLineEndConfig(const ReferenceLineEndConfig& from);

  inline ReferenceLineEndConfig& operator=(const ReferenceLineEndConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReferenceLineEndConfig& default_instance();

  void Swap(ReferenceLineEndConfig* other);

  // implements Message ----------------------------------------------

  inline ReferenceLineEndConfig* New() const { return New(NULL); }

  ReferenceLineEndConfig* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReferenceLineEndConfig& from);
  void MergeFrom(const ReferenceLineEndConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReferenceLineEndConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double stop_distance = 1 [default = 0.5];
  bool has_stop_distance() const;
  void clear_stop_distance();
  static const int kStopDistanceFieldNumber = 1;
  double stop_distance() const;
  void set_stop_distance(double value);

  // optional double min_reference_line_remain_length = 2 [default = 50];
  bool has_min_reference_line_remain_length() const;
  void clear_min_reference_line_remain_length();
  static const int kMinReferenceLineRemainLengthFieldNumber = 2;
  double min_reference_line_remain_length() const;
  void set_min_reference_line_remain_length(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.ReferenceLineEndConfig)
 private:
  inline void set_has_stop_distance();
  inline void clear_has_stop_distance();
  inline void set_has_min_reference_line_remain_length();
  inline void clear_has_min_reference_line_remain_length();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double stop_distance_;
  double min_reference_line_remain_length_;
  friend void  protobuf_AddDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_AssignDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_planning_2ftraffic_5frule_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static ReferenceLineEndConfig* default_instance_;
};
// -------------------------------------------------------------------

class ReroutingConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ReroutingConfig) */ {
 public:
  ReroutingConfig();
  virtual ~ReroutingConfig();

  ReroutingConfig(const ReroutingConfig& from);

  inline ReroutingConfig& operator=(const ReroutingConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReroutingConfig& default_instance();

  void Swap(ReroutingConfig* other);

  // implements Message ----------------------------------------------

  inline ReroutingConfig* New() const { return New(NULL); }

  ReroutingConfig* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReroutingConfig& from);
  void MergeFrom(const ReroutingConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReroutingConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double cooldown_time = 1 [default = 3];
  bool has_cooldown_time() const;
  void clear_cooldown_time();
  static const int kCooldownTimeFieldNumber = 1;
  double cooldown_time() const;
  void set_cooldown_time(double value);

  // optional double prepare_rerouting_time = 2 [default = 2];
  bool has_prepare_rerouting_time() const;
  void clear_prepare_rerouting_time();
  static const int kPrepareReroutingTimeFieldNumber = 2;
  double prepare_rerouting_time() const;
  void set_prepare_rerouting_time(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.ReroutingConfig)
 private:
  inline void set_has_cooldown_time();
  inline void clear_has_cooldown_time();
  inline void set_has_prepare_rerouting_time();
  inline void clear_has_prepare_rerouting_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double cooldown_time_;
  double prepare_rerouting_time_;
  friend void  protobuf_AddDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_AssignDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_planning_2ftraffic_5frule_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static ReroutingConfig* default_instance_;
};
// -------------------------------------------------------------------

class SignalLightConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.SignalLightConfig) */ {
 public:
  SignalLightConfig();
  virtual ~SignalLightConfig();

  SignalLightConfig(const SignalLightConfig& from);

  inline SignalLightConfig& operator=(const SignalLightConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignalLightConfig& default_instance();

  void Swap(SignalLightConfig* other);

  // implements Message ----------------------------------------------

  inline SignalLightConfig* New() const { return New(NULL); }

  SignalLightConfig* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignalLightConfig& from);
  void MergeFrom(const SignalLightConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SignalLightConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double stop_distance = 1 [default = 1];
  bool has_stop_distance() const;
  void clear_stop_distance();
  static const int kStopDistanceFieldNumber = 1;
  double stop_distance() const;
  void set_stop_distance(double value);

  // optional double max_stop_deceleration = 2 [default = 4];
  bool has_max_stop_deceleration() const;
  void clear_max_stop_deceleration();
  static const int kMaxStopDecelerationFieldNumber = 2;
  double max_stop_deceleration() const;
  void set_max_stop_deceleration(double value);

  // optional double min_pass_s_distance = 3 [default = 4];
  bool has_min_pass_s_distance() const;
  void clear_min_pass_s_distance();
  static const int kMinPassSDistanceFieldNumber = 3;
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);

  // optional double max_stop_deacceleration_yellow_light = 4 [default = 3];
  bool has_max_stop_deacceleration_yellow_light() const;
  void clear_max_stop_deacceleration_yellow_light();
  static const int kMaxStopDeaccelerationYellowLightFieldNumber = 4;
  double max_stop_deacceleration_yellow_light() const;
  void set_max_stop_deacceleration_yellow_light(double value);

  // optional double signal_expire_time_sec = 5 [default = 5];
  bool has_signal_expire_time_sec() const;
  void clear_signal_expire_time_sec();
  static const int kSignalExpireTimeSecFieldNumber = 5;
  double signal_expire_time_sec() const;
  void set_signal_expire_time_sec(double value);

  // optional .apollo.planning.CreepConfig righ_turn_creep = 6;
  bool has_righ_turn_creep() const;
  void clear_righ_turn_creep();
  static const int kRighTurnCreepFieldNumber = 6;
  const ::apollo::planning::CreepConfig& righ_turn_creep() const;
  ::apollo::planning::CreepConfig* mutable_righ_turn_creep();
  ::apollo::planning::CreepConfig* release_righ_turn_creep();
  void set_allocated_righ_turn_creep(::apollo::planning::CreepConfig* righ_turn_creep);

  // @@protoc_insertion_point(class_scope:apollo.planning.SignalLightConfig)
 private:
  inline void set_has_stop_distance();
  inline void clear_has_stop_distance();
  inline void set_has_max_stop_deceleration();
  inline void clear_has_max_stop_deceleration();
  inline void set_has_min_pass_s_distance();
  inline void clear_has_min_pass_s_distance();
  inline void set_has_max_stop_deacceleration_yellow_light();
  inline void clear_has_max_stop_deacceleration_yellow_light();
  inline void set_has_signal_expire_time_sec();
  inline void clear_has_signal_expire_time_sec();
  inline void set_has_righ_turn_creep();
  inline void clear_has_righ_turn_creep();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double stop_distance_;
  double max_stop_deceleration_;
  double min_pass_s_distance_;
  double max_stop_deacceleration_yellow_light_;
  double signal_expire_time_sec_;
  ::apollo::planning::CreepConfig* righ_turn_creep_;
  friend void  protobuf_AddDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_AssignDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_planning_2ftraffic_5frule_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static SignalLightConfig* default_instance_;
};
// -------------------------------------------------------------------

class StopSignConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.StopSignConfig) */ {
 public:
  StopSignConfig();
  virtual ~StopSignConfig();

  StopSignConfig(const StopSignConfig& from);

  inline StopSignConfig& operator=(const StopSignConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopSignConfig& default_instance();

  void Swap(StopSignConfig* other);

  // implements Message ----------------------------------------------

  inline StopSignConfig* New() const { return New(NULL); }

  StopSignConfig* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StopSignConfig& from);
  void MergeFrom(const StopSignConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StopSignConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double stop_distance = 1 [default = 1];
  bool has_stop_distance() const;
  void clear_stop_distance();
  static const int kStopDistanceFieldNumber = 1;
  double stop_distance() const;
  void set_stop_distance(double value);

  // optional double min_pass_s_distance = 2 [default = 1];
  bool has_min_pass_s_distance() const;
  void clear_min_pass_s_distance();
  static const int kMinPassSDistanceFieldNumber = 2;
  double min_pass_s_distance() const;
  void set_min_pass_s_distance(double value);

  // optional double max_stop_speed = 3 [default = 0.3];
  bool has_max_stop_speed() const;
  void clear_max_stop_speed();
  static const int kMaxStopSpeedFieldNumber = 3;
  double max_stop_speed() const;
  void set_max_stop_speed(double value);

  // optional double max_valid_stop_distance = 4 [default = 3];
  bool has_max_valid_stop_distance() const;
  void clear_max_valid_stop_distance();
  static const int kMaxValidStopDistanceFieldNumber = 4;
  double max_valid_stop_distance() const;
  void set_max_valid_stop_distance(double value);

  // optional double stop_duration = 5 [default = 1];
  bool has_stop_duration() const;
  void clear_stop_duration();
  static const int kStopDurationFieldNumber = 5;
  double stop_duration() const;
  void set_stop_duration(double value);

  // optional double watch_vehicle_max_valid_stop_speed = 6 [default = 0.5];
  bool has_watch_vehicle_max_valid_stop_speed() const;
  void clear_watch_vehicle_max_valid_stop_speed();
  static const int kWatchVehicleMaxValidStopSpeedFieldNumber = 6;
  double watch_vehicle_max_valid_stop_speed() const;
  void set_watch_vehicle_max_valid_stop_speed(double value);

  // optional double watch_vehicle_max_valid_stop_distance = 7 [default = 5];
  bool has_watch_vehicle_max_valid_stop_distance() const;
  void clear_watch_vehicle_max_valid_stop_distance();
  static const int kWatchVehicleMaxValidStopDistanceFieldNumber = 7;
  double watch_vehicle_max_valid_stop_distance() const;
  void set_watch_vehicle_max_valid_stop_distance(double value);

  // optional double wait_timeout = 8 [default = 8];
  bool has_wait_timeout() const;
  void clear_wait_timeout();
  static const int kWaitTimeoutFieldNumber = 8;
  double wait_timeout() const;
  void set_wait_timeout(double value);

  // optional .apollo.planning.CreepConfig creep = 9;
  bool has_creep() const;
  void clear_creep();
  static const int kCreepFieldNumber = 9;
  const ::apollo::planning::CreepConfig& creep() const;
  ::apollo::planning::CreepConfig* mutable_creep();
  ::apollo::planning::CreepConfig* release_creep();
  void set_allocated_creep(::apollo::planning::CreepConfig* creep);

  // @@protoc_insertion_point(class_scope:apollo.planning.StopSignConfig)
 private:
  inline void set_has_stop_distance();
  inline void clear_has_stop_distance();
  inline void set_has_min_pass_s_distance();
  inline void clear_has_min_pass_s_distance();
  inline void set_has_max_stop_speed();
  inline void clear_has_max_stop_speed();
  inline void set_has_max_valid_stop_distance();
  inline void clear_has_max_valid_stop_distance();
  inline void set_has_stop_duration();
  inline void clear_has_stop_duration();
  inline void set_has_watch_vehicle_max_valid_stop_speed();
  inline void clear_has_watch_vehicle_max_valid_stop_speed();
  inline void set_has_watch_vehicle_max_valid_stop_distance();
  inline void clear_has_watch_vehicle_max_valid_stop_distance();
  inline void set_has_wait_timeout();
  inline void clear_has_wait_timeout();
  inline void set_has_creep();
  inline void clear_has_creep();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double stop_distance_;
  double min_pass_s_distance_;
  double max_stop_speed_;
  double max_valid_stop_distance_;
  double stop_duration_;
  double watch_vehicle_max_valid_stop_speed_;
  double watch_vehicle_max_valid_stop_distance_;
  double wait_timeout_;
  ::apollo::planning::CreepConfig* creep_;
  friend void  protobuf_AddDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_AssignDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_planning_2ftraffic_5frule_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static StopSignConfig* default_instance_;
};
// -------------------------------------------------------------------

class TrafficRuleConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.TrafficRuleConfig) */ {
 public:
  TrafficRuleConfig();
  virtual ~TrafficRuleConfig();

  TrafficRuleConfig(const TrafficRuleConfig& from);

  inline TrafficRuleConfig& operator=(const TrafficRuleConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficRuleConfig& default_instance();

  enum ConfigCase {
    kBacksideVehicle = 3,
    kChangeLane = 4,
    kCrosswalk = 5,
    kDestination = 6,
    kFrontVehicle = 7,
    kKeepClear = 8,
    kPullOver = 9,
    kReferenceLineEnd = 10,
    kRerouting = 11,
    kSignalLight = 12,
    kStopSign = 13,
    CONFIG_NOT_SET = 0,
  };

  void Swap(TrafficRuleConfig* other);

  // implements Message ----------------------------------------------

  inline TrafficRuleConfig* New() const { return New(NULL); }

  TrafficRuleConfig* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrafficRuleConfig& from);
  void MergeFrom(const TrafficRuleConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TrafficRuleConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TrafficRuleConfig_RuleId RuleId;
  static const RuleId BACKSIDE_VEHICLE =
    TrafficRuleConfig_RuleId_BACKSIDE_VEHICLE;
  static const RuleId CHANGE_LANE =
    TrafficRuleConfig_RuleId_CHANGE_LANE;
  static const RuleId CROSSWALK =
    TrafficRuleConfig_RuleId_CROSSWALK;
  static const RuleId DESTINATION =
    TrafficRuleConfig_RuleId_DESTINATION;
  static const RuleId FRONT_VEHICLE =
    TrafficRuleConfig_RuleId_FRONT_VEHICLE;
  static const RuleId KEEP_CLEAR =
    TrafficRuleConfig_RuleId_KEEP_CLEAR;
  static const RuleId PULL_OVER =
    TrafficRuleConfig_RuleId_PULL_OVER;
  static const RuleId REFERENCE_LINE_END =
    TrafficRuleConfig_RuleId_REFERENCE_LINE_END;
  static const RuleId REROUTING =
    TrafficRuleConfig_RuleId_REROUTING;
  static const RuleId SIGNAL_LIGHT =
    TrafficRuleConfig_RuleId_SIGNAL_LIGHT;
  static const RuleId STOP_SIGN =
    TrafficRuleConfig_RuleId_STOP_SIGN;
  static inline bool RuleId_IsValid(int value) {
    return TrafficRuleConfig_RuleId_IsValid(value);
  }
  static const RuleId RuleId_MIN =
    TrafficRuleConfig_RuleId_RuleId_MIN;
  static const RuleId RuleId_MAX =
    TrafficRuleConfig_RuleId_RuleId_MAX;
  static const int RuleId_ARRAYSIZE =
    TrafficRuleConfig_RuleId_RuleId_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RuleId_descriptor() {
    return TrafficRuleConfig_RuleId_descriptor();
  }
  static inline const ::std::string& RuleId_Name(RuleId value) {
    return TrafficRuleConfig_RuleId_Name(value);
  }
  static inline bool RuleId_Parse(const ::std::string& name,
      RuleId* value) {
    return TrafficRuleConfig_RuleId_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .apollo.planning.TrafficRuleConfig.RuleId rule_id = 1;
  bool has_rule_id() const;
  void clear_rule_id();
  static const int kRuleIdFieldNumber = 1;
  ::apollo::planning::TrafficRuleConfig_RuleId rule_id() const;
  void set_rule_id(::apollo::planning::TrafficRuleConfig_RuleId value);

  // optional bool enabled = 2;
  bool has_enabled() const;
  void clear_enabled();
  static const int kEnabledFieldNumber = 2;
  bool enabled() const;
  void set_enabled(bool value);

  // optional .apollo.planning.BacksideVehicleConfig backside_vehicle = 3;
  bool has_backside_vehicle() const;
  void clear_backside_vehicle();
  static const int kBacksideVehicleFieldNumber = 3;
  const ::apollo::planning::BacksideVehicleConfig& backside_vehicle() const;
  ::apollo::planning::BacksideVehicleConfig* mutable_backside_vehicle();
  ::apollo::planning::BacksideVehicleConfig* release_backside_vehicle();
  void set_allocated_backside_vehicle(::apollo::planning::BacksideVehicleConfig* backside_vehicle);

  // optional .apollo.planning.ChangeLaneConfig change_lane = 4;
  bool has_change_lane() const;
  void clear_change_lane();
  static const int kChangeLaneFieldNumber = 4;
  const ::apollo::planning::ChangeLaneConfig& change_lane() const;
  ::apollo::planning::ChangeLaneConfig* mutable_change_lane();
  ::apollo::planning::ChangeLaneConfig* release_change_lane();
  void set_allocated_change_lane(::apollo::planning::ChangeLaneConfig* change_lane);

  // optional .apollo.planning.CrosswalkConfig crosswalk = 5;
  bool has_crosswalk() const;
  void clear_crosswalk();
  static const int kCrosswalkFieldNumber = 5;
  const ::apollo::planning::CrosswalkConfig& crosswalk() const;
  ::apollo::planning::CrosswalkConfig* mutable_crosswalk();
  ::apollo::planning::CrosswalkConfig* release_crosswalk();
  void set_allocated_crosswalk(::apollo::planning::CrosswalkConfig* crosswalk);

  // optional .apollo.planning.DestinationConfig destination = 6;
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 6;
  const ::apollo::planning::DestinationConfig& destination() const;
  ::apollo::planning::DestinationConfig* mutable_destination();
  ::apollo::planning::DestinationConfig* release_destination();
  void set_allocated_destination(::apollo::planning::DestinationConfig* destination);

  // optional .apollo.planning.FrontVehicleConfig front_vehicle = 7;
  bool has_front_vehicle() const;
  void clear_front_vehicle();
  static const int kFrontVehicleFieldNumber = 7;
  const ::apollo::planning::FrontVehicleConfig& front_vehicle() const;
  ::apollo::planning::FrontVehicleConfig* mutable_front_vehicle();
  ::apollo::planning::FrontVehicleConfig* release_front_vehicle();
  void set_allocated_front_vehicle(::apollo::planning::FrontVehicleConfig* front_vehicle);

  // optional .apollo.planning.KeepClearConfig keep_clear = 8;
  bool has_keep_clear() const;
  void clear_keep_clear();
  static const int kKeepClearFieldNumber = 8;
  const ::apollo::planning::KeepClearConfig& keep_clear() const;
  ::apollo::planning::KeepClearConfig* mutable_keep_clear();
  ::apollo::planning::KeepClearConfig* release_keep_clear();
  void set_allocated_keep_clear(::apollo::planning::KeepClearConfig* keep_clear);

  // optional .apollo.planning.PullOverConfig pull_over = 9;
  bool has_pull_over() const;
  void clear_pull_over();
  static const int kPullOverFieldNumber = 9;
  const ::apollo::planning::PullOverConfig& pull_over() const;
  ::apollo::planning::PullOverConfig* mutable_pull_over();
  ::apollo::planning::PullOverConfig* release_pull_over();
  void set_allocated_pull_over(::apollo::planning::PullOverConfig* pull_over);

  // optional .apollo.planning.ReferenceLineEndConfig reference_line_end = 10;
  bool has_reference_line_end() const;
  void clear_reference_line_end();
  static const int kReferenceLineEndFieldNumber = 10;
  const ::apollo::planning::ReferenceLineEndConfig& reference_line_end() const;
  ::apollo::planning::ReferenceLineEndConfig* mutable_reference_line_end();
  ::apollo::planning::ReferenceLineEndConfig* release_reference_line_end();
  void set_allocated_reference_line_end(::apollo::planning::ReferenceLineEndConfig* reference_line_end);

  // optional .apollo.planning.ReroutingConfig rerouting = 11;
  bool has_rerouting() const;
  void clear_rerouting();
  static const int kReroutingFieldNumber = 11;
  const ::apollo::planning::ReroutingConfig& rerouting() const;
  ::apollo::planning::ReroutingConfig* mutable_rerouting();
  ::apollo::planning::ReroutingConfig* release_rerouting();
  void set_allocated_rerouting(::apollo::planning::ReroutingConfig* rerouting);

  // optional .apollo.planning.SignalLightConfig signal_light = 12;
  bool has_signal_light() const;
  void clear_signal_light();
  static const int kSignalLightFieldNumber = 12;
  const ::apollo::planning::SignalLightConfig& signal_light() const;
  ::apollo::planning::SignalLightConfig* mutable_signal_light();
  ::apollo::planning::SignalLightConfig* release_signal_light();
  void set_allocated_signal_light(::apollo::planning::SignalLightConfig* signal_light);

  // optional .apollo.planning.StopSignConfig stop_sign = 13;
  bool has_stop_sign() const;
  void clear_stop_sign();
  static const int kStopSignFieldNumber = 13;
  const ::apollo::planning::StopSignConfig& stop_sign() const;
  ::apollo::planning::StopSignConfig* mutable_stop_sign();
  ::apollo::planning::StopSignConfig* release_stop_sign();
  void set_allocated_stop_sign(::apollo::planning::StopSignConfig* stop_sign);

  ConfigCase config_case() const;
  // @@protoc_insertion_point(class_scope:apollo.planning.TrafficRuleConfig)
 private:
  inline void set_has_rule_id();
  inline void clear_has_rule_id();
  inline void set_has_enabled();
  inline void clear_has_enabled();
  inline void set_has_backside_vehicle();
  inline void set_has_change_lane();
  inline void set_has_crosswalk();
  inline void set_has_destination();
  inline void set_has_front_vehicle();
  inline void set_has_keep_clear();
  inline void set_has_pull_over();
  inline void set_has_reference_line_end();
  inline void set_has_rerouting();
  inline void set_has_signal_light();
  inline void set_has_stop_sign();

  inline bool has_config() const;
  void clear_config();
  inline void clear_has_config();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int rule_id_;
  bool enabled_;
  union ConfigUnion {
    ConfigUnion() {}
    ::apollo::planning::BacksideVehicleConfig* backside_vehicle_;
    ::apollo::planning::ChangeLaneConfig* change_lane_;
    ::apollo::planning::CrosswalkConfig* crosswalk_;
    ::apollo::planning::DestinationConfig* destination_;
    ::apollo::planning::FrontVehicleConfig* front_vehicle_;
    ::apollo::planning::KeepClearConfig* keep_clear_;
    ::apollo::planning::PullOverConfig* pull_over_;
    ::apollo::planning::ReferenceLineEndConfig* reference_line_end_;
    ::apollo::planning::ReroutingConfig* rerouting_;
    ::apollo::planning::SignalLightConfig* signal_light_;
    ::apollo::planning::StopSignConfig* stop_sign_;
  } config_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_AssignDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_planning_2ftraffic_5frule_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TrafficRuleConfig* default_instance_;
};
// -------------------------------------------------------------------

class TrafficRuleConfigs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.TrafficRuleConfigs) */ {
 public:
  TrafficRuleConfigs();
  virtual ~TrafficRuleConfigs();

  TrafficRuleConfigs(const TrafficRuleConfigs& from);

  inline TrafficRuleConfigs& operator=(const TrafficRuleConfigs& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficRuleConfigs& default_instance();

  void Swap(TrafficRuleConfigs* other);

  // implements Message ----------------------------------------------

  inline TrafficRuleConfigs* New() const { return New(NULL); }

  TrafficRuleConfigs* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrafficRuleConfigs& from);
  void MergeFrom(const TrafficRuleConfigs& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TrafficRuleConfigs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .apollo.planning.TrafficRuleConfig config = 1;
  int config_size() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  const ::apollo::planning::TrafficRuleConfig& config(int index) const;
  ::apollo::planning::TrafficRuleConfig* mutable_config(int index);
  ::apollo::planning::TrafficRuleConfig* add_config();
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::TrafficRuleConfig >*
      mutable_config();
  const ::google::protobuf::RepeatedPtrField< ::apollo::planning::TrafficRuleConfig >&
      config() const;

  // @@protoc_insertion_point(class_scope:apollo.planning.TrafficRuleConfigs)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::TrafficRuleConfig > config_;
  friend void  protobuf_AddDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_AssignDesc_planning_2ftraffic_5frule_5fconfig_2eproto();
  friend void protobuf_ShutdownFile_planning_2ftraffic_5frule_5fconfig_2eproto();

  void InitAsDefaultInstance();
  static TrafficRuleConfigs* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// BacksideVehicleConfig

// optional double backside_lane_width = 1 [default = 4];
inline bool BacksideVehicleConfig::has_backside_lane_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BacksideVehicleConfig::set_has_backside_lane_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BacksideVehicleConfig::clear_has_backside_lane_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BacksideVehicleConfig::clear_backside_lane_width() {
  backside_lane_width_ = 4;
  clear_has_backside_lane_width();
}
inline double BacksideVehicleConfig::backside_lane_width() const {
  // @@protoc_insertion_point(field_get:apollo.planning.BacksideVehicleConfig.backside_lane_width)
  return backside_lane_width_;
}
inline void BacksideVehicleConfig::set_backside_lane_width(double value) {
  set_has_backside_lane_width();
  backside_lane_width_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.BacksideVehicleConfig.backside_lane_width)
}

// -------------------------------------------------------------------

// ChangeLaneConfig

// optional double min_overtake_distance = 1 [default = 10];
inline bool ChangeLaneConfig::has_min_overtake_distance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeLaneConfig::set_has_min_overtake_distance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeLaneConfig::clear_has_min_overtake_distance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeLaneConfig::clear_min_overtake_distance() {
  min_overtake_distance_ = 10;
  clear_has_min_overtake_distance();
}
inline double ChangeLaneConfig::min_overtake_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneConfig.min_overtake_distance)
  return min_overtake_distance_;
}
inline void ChangeLaneConfig::set_min_overtake_distance(double value) {
  set_has_min_overtake_distance();
  min_overtake_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneConfig.min_overtake_distance)
}

// optional double min_overtake_time = 2 [default = 2];
inline bool ChangeLaneConfig::has_min_overtake_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeLaneConfig::set_has_min_overtake_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeLaneConfig::clear_has_min_overtake_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeLaneConfig::clear_min_overtake_time() {
  min_overtake_time_ = 2;
  clear_has_min_overtake_time();
}
inline double ChangeLaneConfig::min_overtake_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneConfig.min_overtake_time)
  return min_overtake_time_;
}
inline void ChangeLaneConfig::set_min_overtake_time(double value) {
  set_has_min_overtake_time();
  min_overtake_time_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneConfig.min_overtake_time)
}

// optional bool enable_guard_obstacle = 3 [default = false];
inline bool ChangeLaneConfig::has_enable_guard_obstacle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangeLaneConfig::set_has_enable_guard_obstacle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangeLaneConfig::clear_has_enable_guard_obstacle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangeLaneConfig::clear_enable_guard_obstacle() {
  enable_guard_obstacle_ = false;
  clear_has_enable_guard_obstacle();
}
inline bool ChangeLaneConfig::enable_guard_obstacle() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneConfig.enable_guard_obstacle)
  return enable_guard_obstacle_;
}
inline void ChangeLaneConfig::set_enable_guard_obstacle(bool value) {
  set_has_enable_guard_obstacle();
  enable_guard_obstacle_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneConfig.enable_guard_obstacle)
}

// optional double guard_distance = 4 [default = 100];
inline bool ChangeLaneConfig::has_guard_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ChangeLaneConfig::set_has_guard_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ChangeLaneConfig::clear_has_guard_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ChangeLaneConfig::clear_guard_distance() {
  guard_distance_ = 100;
  clear_has_guard_distance();
}
inline double ChangeLaneConfig::guard_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneConfig.guard_distance)
  return guard_distance_;
}
inline void ChangeLaneConfig::set_guard_distance(double value) {
  set_has_guard_distance();
  guard_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneConfig.guard_distance)
}

// optional double min_guard_speed = 5 [default = 1];
inline bool ChangeLaneConfig::has_min_guard_speed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ChangeLaneConfig::set_has_min_guard_speed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ChangeLaneConfig::clear_has_min_guard_speed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ChangeLaneConfig::clear_min_guard_speed() {
  min_guard_speed_ = 1;
  clear_has_min_guard_speed();
}
inline double ChangeLaneConfig::min_guard_speed() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneConfig.min_guard_speed)
  return min_guard_speed_;
}
inline void ChangeLaneConfig::set_min_guard_speed(double value) {
  set_has_min_guard_speed();
  min_guard_speed_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneConfig.min_guard_speed)
}

// -------------------------------------------------------------------

// CreepConfig

// optional bool enabled = 1;
inline bool CreepConfig::has_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreepConfig::set_has_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreepConfig::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreepConfig::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool CreepConfig::enabled() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CreepConfig.enabled)
  return enabled_;
}
inline void CreepConfig::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.CreepConfig.enabled)
}

// optional double creep_distance_to_stop_line = 2 [default = 1];
inline bool CreepConfig::has_creep_distance_to_stop_line() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreepConfig::set_has_creep_distance_to_stop_line() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreepConfig::clear_has_creep_distance_to_stop_line() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreepConfig::clear_creep_distance_to_stop_line() {
  creep_distance_to_stop_line_ = 1;
  clear_has_creep_distance_to_stop_line();
}
inline double CreepConfig::creep_distance_to_stop_line() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CreepConfig.creep_distance_to_stop_line)
  return creep_distance_to_stop_line_;
}
inline void CreepConfig::set_creep_distance_to_stop_line(double value) {
  set_has_creep_distance_to_stop_line();
  creep_distance_to_stop_line_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.CreepConfig.creep_distance_to_stop_line)
}

// optional double stop_distance = 3 [default = 0.5];
inline bool CreepConfig::has_stop_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreepConfig::set_has_stop_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreepConfig::clear_has_stop_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreepConfig::clear_stop_distance() {
  stop_distance_ = 0.5;
  clear_has_stop_distance();
}
inline double CreepConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CreepConfig.stop_distance)
  return stop_distance_;
}
inline void CreepConfig::set_stop_distance(double value) {
  set_has_stop_distance();
  stop_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.CreepConfig.stop_distance)
}

// optional double speed_limit = 4 [default = 1];
inline bool CreepConfig::has_speed_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreepConfig::set_has_speed_limit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreepConfig::clear_has_speed_limit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreepConfig::clear_speed_limit() {
  speed_limit_ = 1;
  clear_has_speed_limit();
}
inline double CreepConfig::speed_limit() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CreepConfig.speed_limit)
  return speed_limit_;
}
inline void CreepConfig::set_speed_limit(double value) {
  set_has_speed_limit();
  speed_limit_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.CreepConfig.speed_limit)
}

// optional double max_valid_stop_distance = 5 [default = 0.3];
inline bool CreepConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreepConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreepConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreepConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 0.3;
  clear_has_max_valid_stop_distance();
}
inline double CreepConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CreepConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
inline void CreepConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.CreepConfig.max_valid_stop_distance)
}

// optional double min_boundary_t = 6 [default = 6];
inline bool CreepConfig::has_min_boundary_t() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CreepConfig::set_has_min_boundary_t() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CreepConfig::clear_has_min_boundary_t() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CreepConfig::clear_min_boundary_t() {
  min_boundary_t_ = 6;
  clear_has_min_boundary_t();
}
inline double CreepConfig::min_boundary_t() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CreepConfig.min_boundary_t)
  return min_boundary_t_;
}
inline void CreepConfig::set_min_boundary_t(double value) {
  set_has_min_boundary_t();
  min_boundary_t_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.CreepConfig.min_boundary_t)
}

// optional double min_boundary_s = 7 [default = 3];
inline bool CreepConfig::has_min_boundary_s() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CreepConfig::set_has_min_boundary_s() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CreepConfig::clear_has_min_boundary_s() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CreepConfig::clear_min_boundary_s() {
  min_boundary_s_ = 3;
  clear_has_min_boundary_s();
}
inline double CreepConfig::min_boundary_s() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CreepConfig.min_boundary_s)
  return min_boundary_s_;
}
inline void CreepConfig::set_min_boundary_s(double value) {
  set_has_min_boundary_s();
  min_boundary_s_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.CreepConfig.min_boundary_s)
}

// -------------------------------------------------------------------

// CrosswalkConfig

// optional double stop_distance = 1 [default = 1];
inline bool CrosswalkConfig::has_stop_distance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CrosswalkConfig::set_has_stop_distance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CrosswalkConfig::clear_has_stop_distance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CrosswalkConfig::clear_stop_distance() {
  stop_distance_ = 1;
  clear_has_stop_distance();
}
inline double CrosswalkConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.stop_distance)
  return stop_distance_;
}
inline void CrosswalkConfig::set_stop_distance(double value) {
  set_has_stop_distance();
  stop_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.stop_distance)
}

// optional double max_stop_deceleration = 2 [default = 4];
inline bool CrosswalkConfig::has_max_stop_deceleration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CrosswalkConfig::set_has_max_stop_deceleration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CrosswalkConfig::clear_has_max_stop_deceleration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CrosswalkConfig::clear_max_stop_deceleration() {
  max_stop_deceleration_ = 4;
  clear_has_max_stop_deceleration();
}
inline double CrosswalkConfig::max_stop_deceleration() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.max_stop_deceleration)
  return max_stop_deceleration_;
}
inline void CrosswalkConfig::set_max_stop_deceleration(double value) {
  set_has_max_stop_deceleration();
  max_stop_deceleration_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.max_stop_deceleration)
}

// optional double min_pass_s_distance = 3 [default = 1];
inline bool CrosswalkConfig::has_min_pass_s_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CrosswalkConfig::set_has_min_pass_s_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CrosswalkConfig::clear_has_min_pass_s_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CrosswalkConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 1;
  clear_has_min_pass_s_distance();
}
inline double CrosswalkConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.min_pass_s_distance)
  return min_pass_s_distance_;
}
inline void CrosswalkConfig::set_min_pass_s_distance(double value) {
  set_has_min_pass_s_distance();
  min_pass_s_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.min_pass_s_distance)
}

// optional double max_stop_speed = 4 [default = 0.3];
inline bool CrosswalkConfig::has_max_stop_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CrosswalkConfig::set_has_max_stop_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CrosswalkConfig::clear_has_max_stop_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CrosswalkConfig::clear_max_stop_speed() {
  max_stop_speed_ = 0.3;
  clear_has_max_stop_speed();
}
inline double CrosswalkConfig::max_stop_speed() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.max_stop_speed)
  return max_stop_speed_;
}
inline void CrosswalkConfig::set_max_stop_speed(double value) {
  set_has_max_stop_speed();
  max_stop_speed_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.max_stop_speed)
}

// optional double max_valid_stop_distance = 5 [default = 3];
inline bool CrosswalkConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CrosswalkConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CrosswalkConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CrosswalkConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 3;
  clear_has_max_valid_stop_distance();
}
inline double CrosswalkConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
inline void CrosswalkConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.max_valid_stop_distance)
}

// optional double expand_s_distance = 6 [default = 2];
inline bool CrosswalkConfig::has_expand_s_distance() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CrosswalkConfig::set_has_expand_s_distance() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CrosswalkConfig::clear_has_expand_s_distance() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CrosswalkConfig::clear_expand_s_distance() {
  expand_s_distance_ = 2;
  clear_has_expand_s_distance();
}
inline double CrosswalkConfig::expand_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.expand_s_distance)
  return expand_s_distance_;
}
inline void CrosswalkConfig::set_expand_s_distance(double value) {
  set_has_expand_s_distance();
  expand_s_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.expand_s_distance)
}

// optional double stop_strick_l_distance = 7 [default = 4];
inline bool CrosswalkConfig::has_stop_strick_l_distance() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CrosswalkConfig::set_has_stop_strick_l_distance() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CrosswalkConfig::clear_has_stop_strick_l_distance() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CrosswalkConfig::clear_stop_strick_l_distance() {
  stop_strick_l_distance_ = 4;
  clear_has_stop_strick_l_distance();
}
inline double CrosswalkConfig::stop_strick_l_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.stop_strick_l_distance)
  return stop_strick_l_distance_;
}
inline void CrosswalkConfig::set_stop_strick_l_distance(double value) {
  set_has_stop_strick_l_distance();
  stop_strick_l_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.stop_strick_l_distance)
}

// optional double stop_loose_l_distance = 8 [default = 5];
inline bool CrosswalkConfig::has_stop_loose_l_distance() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CrosswalkConfig::set_has_stop_loose_l_distance() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CrosswalkConfig::clear_has_stop_loose_l_distance() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CrosswalkConfig::clear_stop_loose_l_distance() {
  stop_loose_l_distance_ = 5;
  clear_has_stop_loose_l_distance();
}
inline double CrosswalkConfig::stop_loose_l_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.stop_loose_l_distance)
  return stop_loose_l_distance_;
}
inline void CrosswalkConfig::set_stop_loose_l_distance(double value) {
  set_has_stop_loose_l_distance();
  stop_loose_l_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.stop_loose_l_distance)
}

// optional double stop_timeout = 9 [default = 10];
inline bool CrosswalkConfig::has_stop_timeout() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CrosswalkConfig::set_has_stop_timeout() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CrosswalkConfig::clear_has_stop_timeout() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CrosswalkConfig::clear_stop_timeout() {
  stop_timeout_ = 10;
  clear_has_stop_timeout();
}
inline double CrosswalkConfig::stop_timeout() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkConfig.stop_timeout)
  return stop_timeout_;
}
inline void CrosswalkConfig::set_stop_timeout(double value) {
  set_has_stop_timeout();
  stop_timeout_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkConfig.stop_timeout)
}

// -------------------------------------------------------------------

// DestinationConfig

// optional bool enable_pull_over = 1 [default = false];
inline bool DestinationConfig::has_enable_pull_over() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DestinationConfig::set_has_enable_pull_over() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DestinationConfig::clear_has_enable_pull_over() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DestinationConfig::clear_enable_pull_over() {
  enable_pull_over_ = false;
  clear_has_enable_pull_over();
}
inline bool DestinationConfig::enable_pull_over() const {
  // @@protoc_insertion_point(field_get:apollo.planning.DestinationConfig.enable_pull_over)
  return enable_pull_over_;
}
inline void DestinationConfig::set_enable_pull_over(bool value) {
  set_has_enable_pull_over();
  enable_pull_over_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.DestinationConfig.enable_pull_over)
}

// optional double stop_distance = 2 [default = 0.5];
inline bool DestinationConfig::has_stop_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DestinationConfig::set_has_stop_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DestinationConfig::clear_has_stop_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DestinationConfig::clear_stop_distance() {
  stop_distance_ = 0.5;
  clear_has_stop_distance();
}
inline double DestinationConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.DestinationConfig.stop_distance)
  return stop_distance_;
}
inline void DestinationConfig::set_stop_distance(double value) {
  set_has_stop_distance();
  stop_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.DestinationConfig.stop_distance)
}

// optional double pull_over_plan_distance = 3 [default = 35];
inline bool DestinationConfig::has_pull_over_plan_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DestinationConfig::set_has_pull_over_plan_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DestinationConfig::clear_has_pull_over_plan_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DestinationConfig::clear_pull_over_plan_distance() {
  pull_over_plan_distance_ = 35;
  clear_has_pull_over_plan_distance();
}
inline double DestinationConfig::pull_over_plan_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.DestinationConfig.pull_over_plan_distance)
  return pull_over_plan_distance_;
}
inline void DestinationConfig::set_pull_over_plan_distance(double value) {
  set_has_pull_over_plan_distance();
  pull_over_plan_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.DestinationConfig.pull_over_plan_distance)
}

// -------------------------------------------------------------------

// FrontVehicleConfig

// optional bool enable_side_pass = 1 [default = true];
inline bool FrontVehicleConfig::has_enable_side_pass() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FrontVehicleConfig::set_has_enable_side_pass() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FrontVehicleConfig::clear_has_enable_side_pass() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FrontVehicleConfig::clear_enable_side_pass() {
  enable_side_pass_ = true;
  clear_has_enable_side_pass();
}
inline bool FrontVehicleConfig::enable_side_pass() const {
  // @@protoc_insertion_point(field_get:apollo.planning.FrontVehicleConfig.enable_side_pass)
  return enable_side_pass_;
}
inline void FrontVehicleConfig::set_enable_side_pass(bool value) {
  set_has_enable_side_pass();
  enable_side_pass_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.FrontVehicleConfig.enable_side_pass)
}

// optional double side_pass_s_threshold = 2 [default = 15];
inline bool FrontVehicleConfig::has_side_pass_s_threshold() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FrontVehicleConfig::set_has_side_pass_s_threshold() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FrontVehicleConfig::clear_has_side_pass_s_threshold() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FrontVehicleConfig::clear_side_pass_s_threshold() {
  side_pass_s_threshold_ = 15;
  clear_has_side_pass_s_threshold();
}
inline double FrontVehicleConfig::side_pass_s_threshold() const {
  // @@protoc_insertion_point(field_get:apollo.planning.FrontVehicleConfig.side_pass_s_threshold)
  return side_pass_s_threshold_;
}
inline void FrontVehicleConfig::set_side_pass_s_threshold(double value) {
  set_has_side_pass_s_threshold();
  side_pass_s_threshold_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.FrontVehicleConfig.side_pass_s_threshold)
}

// optional double side_pass_l_threshold = 3 [default = 1];
inline bool FrontVehicleConfig::has_side_pass_l_threshold() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FrontVehicleConfig::set_has_side_pass_l_threshold() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FrontVehicleConfig::clear_has_side_pass_l_threshold() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FrontVehicleConfig::clear_side_pass_l_threshold() {
  side_pass_l_threshold_ = 1;
  clear_has_side_pass_l_threshold();
}
inline double FrontVehicleConfig::side_pass_l_threshold() const {
  // @@protoc_insertion_point(field_get:apollo.planning.FrontVehicleConfig.side_pass_l_threshold)
  return side_pass_l_threshold_;
}
inline void FrontVehicleConfig::set_side_pass_l_threshold(double value) {
  set_has_side_pass_l_threshold();
  side_pass_l_threshold_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.FrontVehicleConfig.side_pass_l_threshold)
}

// optional double side_pass_wait_time = 4 [default = 30];
inline bool FrontVehicleConfig::has_side_pass_wait_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FrontVehicleConfig::set_has_side_pass_wait_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FrontVehicleConfig::clear_has_side_pass_wait_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FrontVehicleConfig::clear_side_pass_wait_time() {
  side_pass_wait_time_ = 30;
  clear_has_side_pass_wait_time();
}
inline double FrontVehicleConfig::side_pass_wait_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.FrontVehicleConfig.side_pass_wait_time)
  return side_pass_wait_time_;
}
inline void FrontVehicleConfig::set_side_pass_wait_time(double value) {
  set_has_side_pass_wait_time();
  side_pass_wait_time_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.FrontVehicleConfig.side_pass_wait_time)
}

// optional double nudge_l_buffer = 5 [default = 0.5];
inline bool FrontVehicleConfig::has_nudge_l_buffer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FrontVehicleConfig::set_has_nudge_l_buffer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FrontVehicleConfig::clear_has_nudge_l_buffer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FrontVehicleConfig::clear_nudge_l_buffer() {
  nudge_l_buffer_ = 0.5;
  clear_has_nudge_l_buffer();
}
inline double FrontVehicleConfig::nudge_l_buffer() const {
  // @@protoc_insertion_point(field_get:apollo.planning.FrontVehicleConfig.nudge_l_buffer)
  return nudge_l_buffer_;
}
inline void FrontVehicleConfig::set_nudge_l_buffer(double value) {
  set_has_nudge_l_buffer();
  nudge_l_buffer_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.FrontVehicleConfig.nudge_l_buffer)
}

// -------------------------------------------------------------------

// KeepClearConfig

// optional bool enable_keep_clear_zone = 1 [default = true];
inline bool KeepClearConfig::has_enable_keep_clear_zone() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeepClearConfig::set_has_enable_keep_clear_zone() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeepClearConfig::clear_has_enable_keep_clear_zone() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeepClearConfig::clear_enable_keep_clear_zone() {
  enable_keep_clear_zone_ = true;
  clear_has_enable_keep_clear_zone();
}
inline bool KeepClearConfig::enable_keep_clear_zone() const {
  // @@protoc_insertion_point(field_get:apollo.planning.KeepClearConfig.enable_keep_clear_zone)
  return enable_keep_clear_zone_;
}
inline void KeepClearConfig::set_enable_keep_clear_zone(bool value) {
  set_has_enable_keep_clear_zone();
  enable_keep_clear_zone_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.KeepClearConfig.enable_keep_clear_zone)
}

// optional bool enable_junction = 2 [default = true];
inline bool KeepClearConfig::has_enable_junction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeepClearConfig::set_has_enable_junction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeepClearConfig::clear_has_enable_junction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeepClearConfig::clear_enable_junction() {
  enable_junction_ = true;
  clear_has_enable_junction();
}
inline bool KeepClearConfig::enable_junction() const {
  // @@protoc_insertion_point(field_get:apollo.planning.KeepClearConfig.enable_junction)
  return enable_junction_;
}
inline void KeepClearConfig::set_enable_junction(bool value) {
  set_has_enable_junction();
  enable_junction_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.KeepClearConfig.enable_junction)
}

// optional double min_pass_s_distance = 3 [default = 2];
inline bool KeepClearConfig::has_min_pass_s_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KeepClearConfig::set_has_min_pass_s_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KeepClearConfig::clear_has_min_pass_s_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KeepClearConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 2;
  clear_has_min_pass_s_distance();
}
inline double KeepClearConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.KeepClearConfig.min_pass_s_distance)
  return min_pass_s_distance_;
}
inline void KeepClearConfig::set_min_pass_s_distance(double value) {
  set_has_min_pass_s_distance();
  min_pass_s_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.KeepClearConfig.min_pass_s_distance)
}

// -------------------------------------------------------------------

// PullOverConfig

// optional double stop_distance = 1 [default = 0.5];
inline bool PullOverConfig::has_stop_distance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PullOverConfig::set_has_stop_distance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PullOverConfig::clear_has_stop_distance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PullOverConfig::clear_stop_distance() {
  stop_distance_ = 0.5;
  clear_has_stop_distance();
}
inline double PullOverConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverConfig.stop_distance)
  return stop_distance_;
}
inline void PullOverConfig::set_stop_distance(double value) {
  set_has_stop_distance();
  stop_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverConfig.stop_distance)
}

// optional double max_stop_speed = 2 [default = 0.3];
inline bool PullOverConfig::has_max_stop_speed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PullOverConfig::set_has_max_stop_speed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PullOverConfig::clear_has_max_stop_speed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PullOverConfig::clear_max_stop_speed() {
  max_stop_speed_ = 0.3;
  clear_has_max_stop_speed();
}
inline double PullOverConfig::max_stop_speed() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverConfig.max_stop_speed)
  return max_stop_speed_;
}
inline void PullOverConfig::set_max_stop_speed(double value) {
  set_has_max_stop_speed();
  max_stop_speed_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverConfig.max_stop_speed)
}

// optional double max_valid_stop_distance = 3 [default = 3];
inline bool PullOverConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PullOverConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PullOverConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PullOverConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 3;
  clear_has_max_valid_stop_distance();
}
inline double PullOverConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
inline void PullOverConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverConfig.max_valid_stop_distance)
}

// optional double max_stop_deceleration = 4 [default = 2.5];
inline bool PullOverConfig::has_max_stop_deceleration() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PullOverConfig::set_has_max_stop_deceleration() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PullOverConfig::clear_has_max_stop_deceleration() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PullOverConfig::clear_max_stop_deceleration() {
  max_stop_deceleration_ = 2.5;
  clear_has_max_stop_deceleration();
}
inline double PullOverConfig::max_stop_deceleration() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverConfig.max_stop_deceleration)
  return max_stop_deceleration_;
}
inline void PullOverConfig::set_max_stop_deceleration(double value) {
  set_has_max_stop_deceleration();
  max_stop_deceleration_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverConfig.max_stop_deceleration)
}

// optional double min_pass_s_distance = 5 [default = 1];
inline bool PullOverConfig::has_min_pass_s_distance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PullOverConfig::set_has_min_pass_s_distance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PullOverConfig::clear_has_min_pass_s_distance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PullOverConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 1;
  clear_has_min_pass_s_distance();
}
inline double PullOverConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverConfig.min_pass_s_distance)
  return min_pass_s_distance_;
}
inline void PullOverConfig::set_min_pass_s_distance(double value) {
  set_has_min_pass_s_distance();
  min_pass_s_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverConfig.min_pass_s_distance)
}

// optional double buffer_to_boundary = 6 [default = 0.5];
inline bool PullOverConfig::has_buffer_to_boundary() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PullOverConfig::set_has_buffer_to_boundary() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PullOverConfig::clear_has_buffer_to_boundary() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PullOverConfig::clear_buffer_to_boundary() {
  buffer_to_boundary_ = 0.5;
  clear_has_buffer_to_boundary();
}
inline double PullOverConfig::buffer_to_boundary() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverConfig.buffer_to_boundary)
  return buffer_to_boundary_;
}
inline void PullOverConfig::set_buffer_to_boundary(double value) {
  set_has_buffer_to_boundary();
  buffer_to_boundary_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverConfig.buffer_to_boundary)
}

// optional double plan_distance = 7 [default = 35];
inline bool PullOverConfig::has_plan_distance() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PullOverConfig::set_has_plan_distance() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PullOverConfig::clear_has_plan_distance() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PullOverConfig::clear_plan_distance() {
  plan_distance_ = 35;
  clear_has_plan_distance();
}
inline double PullOverConfig::plan_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverConfig.plan_distance)
  return plan_distance_;
}
inline void PullOverConfig::set_plan_distance(double value) {
  set_has_plan_distance();
  plan_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverConfig.plan_distance)
}

// optional double operation_length = 8 [default = 30];
inline bool PullOverConfig::has_operation_length() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PullOverConfig::set_has_operation_length() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PullOverConfig::clear_has_operation_length() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PullOverConfig::clear_operation_length() {
  operation_length_ = 30;
  clear_has_operation_length();
}
inline double PullOverConfig::operation_length() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverConfig.operation_length)
  return operation_length_;
}
inline void PullOverConfig::set_operation_length(double value) {
  set_has_operation_length();
  operation_length_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverConfig.operation_length)
}

// optional double max_check_distance = 9 [default = 60];
inline bool PullOverConfig::has_max_check_distance() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PullOverConfig::set_has_max_check_distance() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PullOverConfig::clear_has_max_check_distance() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PullOverConfig::clear_max_check_distance() {
  max_check_distance_ = 60;
  clear_has_max_check_distance();
}
inline double PullOverConfig::max_check_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverConfig.max_check_distance)
  return max_check_distance_;
}
inline void PullOverConfig::set_max_check_distance(double value) {
  set_has_max_check_distance();
  max_check_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverConfig.max_check_distance)
}

// optional uint32 max_failure_count = 10 [default = 10];
inline bool PullOverConfig::has_max_failure_count() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PullOverConfig::set_has_max_failure_count() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PullOverConfig::clear_has_max_failure_count() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PullOverConfig::clear_max_failure_count() {
  max_failure_count_ = 10u;
  clear_has_max_failure_count();
}
inline ::google::protobuf::uint32 PullOverConfig::max_failure_count() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverConfig.max_failure_count)
  return max_failure_count_;
}
inline void PullOverConfig::set_max_failure_count(::google::protobuf::uint32 value) {
  set_has_max_failure_count();
  max_failure_count_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverConfig.max_failure_count)
}

// -------------------------------------------------------------------

// ReferenceLineEndConfig

// optional double stop_distance = 1 [default = 0.5];
inline bool ReferenceLineEndConfig::has_stop_distance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReferenceLineEndConfig::set_has_stop_distance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReferenceLineEndConfig::clear_has_stop_distance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReferenceLineEndConfig::clear_stop_distance() {
  stop_distance_ = 0.5;
  clear_has_stop_distance();
}
inline double ReferenceLineEndConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ReferenceLineEndConfig.stop_distance)
  return stop_distance_;
}
inline void ReferenceLineEndConfig::set_stop_distance(double value) {
  set_has_stop_distance();
  stop_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ReferenceLineEndConfig.stop_distance)
}

// optional double min_reference_line_remain_length = 2 [default = 50];
inline bool ReferenceLineEndConfig::has_min_reference_line_remain_length() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReferenceLineEndConfig::set_has_min_reference_line_remain_length() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReferenceLineEndConfig::clear_has_min_reference_line_remain_length() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReferenceLineEndConfig::clear_min_reference_line_remain_length() {
  min_reference_line_remain_length_ = 50;
  clear_has_min_reference_line_remain_length();
}
inline double ReferenceLineEndConfig::min_reference_line_remain_length() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ReferenceLineEndConfig.min_reference_line_remain_length)
  return min_reference_line_remain_length_;
}
inline void ReferenceLineEndConfig::set_min_reference_line_remain_length(double value) {
  set_has_min_reference_line_remain_length();
  min_reference_line_remain_length_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ReferenceLineEndConfig.min_reference_line_remain_length)
}

// -------------------------------------------------------------------

// ReroutingConfig

// optional double cooldown_time = 1 [default = 3];
inline bool ReroutingConfig::has_cooldown_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReroutingConfig::set_has_cooldown_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReroutingConfig::clear_has_cooldown_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReroutingConfig::clear_cooldown_time() {
  cooldown_time_ = 3;
  clear_has_cooldown_time();
}
inline double ReroutingConfig::cooldown_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ReroutingConfig.cooldown_time)
  return cooldown_time_;
}
inline void ReroutingConfig::set_cooldown_time(double value) {
  set_has_cooldown_time();
  cooldown_time_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ReroutingConfig.cooldown_time)
}

// optional double prepare_rerouting_time = 2 [default = 2];
inline bool ReroutingConfig::has_prepare_rerouting_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReroutingConfig::set_has_prepare_rerouting_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReroutingConfig::clear_has_prepare_rerouting_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReroutingConfig::clear_prepare_rerouting_time() {
  prepare_rerouting_time_ = 2;
  clear_has_prepare_rerouting_time();
}
inline double ReroutingConfig::prepare_rerouting_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ReroutingConfig.prepare_rerouting_time)
  return prepare_rerouting_time_;
}
inline void ReroutingConfig::set_prepare_rerouting_time(double value) {
  set_has_prepare_rerouting_time();
  prepare_rerouting_time_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ReroutingConfig.prepare_rerouting_time)
}

// -------------------------------------------------------------------

// SignalLightConfig

// optional double stop_distance = 1 [default = 1];
inline bool SignalLightConfig::has_stop_distance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SignalLightConfig::set_has_stop_distance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SignalLightConfig::clear_has_stop_distance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SignalLightConfig::clear_stop_distance() {
  stop_distance_ = 1;
  clear_has_stop_distance();
}
inline double SignalLightConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.SignalLightConfig.stop_distance)
  return stop_distance_;
}
inline void SignalLightConfig::set_stop_distance(double value) {
  set_has_stop_distance();
  stop_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.SignalLightConfig.stop_distance)
}

// optional double max_stop_deceleration = 2 [default = 4];
inline bool SignalLightConfig::has_max_stop_deceleration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SignalLightConfig::set_has_max_stop_deceleration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SignalLightConfig::clear_has_max_stop_deceleration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SignalLightConfig::clear_max_stop_deceleration() {
  max_stop_deceleration_ = 4;
  clear_has_max_stop_deceleration();
}
inline double SignalLightConfig::max_stop_deceleration() const {
  // @@protoc_insertion_point(field_get:apollo.planning.SignalLightConfig.max_stop_deceleration)
  return max_stop_deceleration_;
}
inline void SignalLightConfig::set_max_stop_deceleration(double value) {
  set_has_max_stop_deceleration();
  max_stop_deceleration_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.SignalLightConfig.max_stop_deceleration)
}

// optional double min_pass_s_distance = 3 [default = 4];
inline bool SignalLightConfig::has_min_pass_s_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SignalLightConfig::set_has_min_pass_s_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SignalLightConfig::clear_has_min_pass_s_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SignalLightConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 4;
  clear_has_min_pass_s_distance();
}
inline double SignalLightConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.SignalLightConfig.min_pass_s_distance)
  return min_pass_s_distance_;
}
inline void SignalLightConfig::set_min_pass_s_distance(double value) {
  set_has_min_pass_s_distance();
  min_pass_s_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.SignalLightConfig.min_pass_s_distance)
}

// optional double max_stop_deacceleration_yellow_light = 4 [default = 3];
inline bool SignalLightConfig::has_max_stop_deacceleration_yellow_light() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SignalLightConfig::set_has_max_stop_deacceleration_yellow_light() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SignalLightConfig::clear_has_max_stop_deacceleration_yellow_light() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SignalLightConfig::clear_max_stop_deacceleration_yellow_light() {
  max_stop_deacceleration_yellow_light_ = 3;
  clear_has_max_stop_deacceleration_yellow_light();
}
inline double SignalLightConfig::max_stop_deacceleration_yellow_light() const {
  // @@protoc_insertion_point(field_get:apollo.planning.SignalLightConfig.max_stop_deacceleration_yellow_light)
  return max_stop_deacceleration_yellow_light_;
}
inline void SignalLightConfig::set_max_stop_deacceleration_yellow_light(double value) {
  set_has_max_stop_deacceleration_yellow_light();
  max_stop_deacceleration_yellow_light_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.SignalLightConfig.max_stop_deacceleration_yellow_light)
}

// optional double signal_expire_time_sec = 5 [default = 5];
inline bool SignalLightConfig::has_signal_expire_time_sec() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SignalLightConfig::set_has_signal_expire_time_sec() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SignalLightConfig::clear_has_signal_expire_time_sec() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SignalLightConfig::clear_signal_expire_time_sec() {
  signal_expire_time_sec_ = 5;
  clear_has_signal_expire_time_sec();
}
inline double SignalLightConfig::signal_expire_time_sec() const {
  // @@protoc_insertion_point(field_get:apollo.planning.SignalLightConfig.signal_expire_time_sec)
  return signal_expire_time_sec_;
}
inline void SignalLightConfig::set_signal_expire_time_sec(double value) {
  set_has_signal_expire_time_sec();
  signal_expire_time_sec_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.SignalLightConfig.signal_expire_time_sec)
}

// optional .apollo.planning.CreepConfig righ_turn_creep = 6;
inline bool SignalLightConfig::has_righ_turn_creep() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SignalLightConfig::set_has_righ_turn_creep() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SignalLightConfig::clear_has_righ_turn_creep() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SignalLightConfig::clear_righ_turn_creep() {
  if (righ_turn_creep_ != NULL) righ_turn_creep_->::apollo::planning::CreepConfig::Clear();
  clear_has_righ_turn_creep();
}
inline const ::apollo::planning::CreepConfig& SignalLightConfig::righ_turn_creep() const {
  // @@protoc_insertion_point(field_get:apollo.planning.SignalLightConfig.righ_turn_creep)
  return righ_turn_creep_ != NULL ? *righ_turn_creep_ : *default_instance_->righ_turn_creep_;
}
inline ::apollo::planning::CreepConfig* SignalLightConfig::mutable_righ_turn_creep() {
  set_has_righ_turn_creep();
  if (righ_turn_creep_ == NULL) {
    righ_turn_creep_ = new ::apollo::planning::CreepConfig;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.SignalLightConfig.righ_turn_creep)
  return righ_turn_creep_;
}
inline ::apollo::planning::CreepConfig* SignalLightConfig::release_righ_turn_creep() {
  // @@protoc_insertion_point(field_release:apollo.planning.SignalLightConfig.righ_turn_creep)
  clear_has_righ_turn_creep();
  ::apollo::planning::CreepConfig* temp = righ_turn_creep_;
  righ_turn_creep_ = NULL;
  return temp;
}
inline void SignalLightConfig::set_allocated_righ_turn_creep(::apollo::planning::CreepConfig* righ_turn_creep) {
  delete righ_turn_creep_;
  righ_turn_creep_ = righ_turn_creep;
  if (righ_turn_creep) {
    set_has_righ_turn_creep();
  } else {
    clear_has_righ_turn_creep();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.SignalLightConfig.righ_turn_creep)
}

// -------------------------------------------------------------------

// StopSignConfig

// optional double stop_distance = 1 [default = 1];
inline bool StopSignConfig::has_stop_distance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopSignConfig::set_has_stop_distance() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopSignConfig::clear_has_stop_distance() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopSignConfig::clear_stop_distance() {
  stop_distance_ = 1;
  clear_has_stop_distance();
}
inline double StopSignConfig::stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignConfig.stop_distance)
  return stop_distance_;
}
inline void StopSignConfig::set_stop_distance(double value) {
  set_has_stop_distance();
  stop_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignConfig.stop_distance)
}

// optional double min_pass_s_distance = 2 [default = 1];
inline bool StopSignConfig::has_min_pass_s_distance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StopSignConfig::set_has_min_pass_s_distance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StopSignConfig::clear_has_min_pass_s_distance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StopSignConfig::clear_min_pass_s_distance() {
  min_pass_s_distance_ = 1;
  clear_has_min_pass_s_distance();
}
inline double StopSignConfig::min_pass_s_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignConfig.min_pass_s_distance)
  return min_pass_s_distance_;
}
inline void StopSignConfig::set_min_pass_s_distance(double value) {
  set_has_min_pass_s_distance();
  min_pass_s_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignConfig.min_pass_s_distance)
}

// optional double max_stop_speed = 3 [default = 0.3];
inline bool StopSignConfig::has_max_stop_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StopSignConfig::set_has_max_stop_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StopSignConfig::clear_has_max_stop_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StopSignConfig::clear_max_stop_speed() {
  max_stop_speed_ = 0.3;
  clear_has_max_stop_speed();
}
inline double StopSignConfig::max_stop_speed() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignConfig.max_stop_speed)
  return max_stop_speed_;
}
inline void StopSignConfig::set_max_stop_speed(double value) {
  set_has_max_stop_speed();
  max_stop_speed_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignConfig.max_stop_speed)
}

// optional double max_valid_stop_distance = 4 [default = 3];
inline bool StopSignConfig::has_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StopSignConfig::set_has_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StopSignConfig::clear_has_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StopSignConfig::clear_max_valid_stop_distance() {
  max_valid_stop_distance_ = 3;
  clear_has_max_valid_stop_distance();
}
inline double StopSignConfig::max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignConfig.max_valid_stop_distance)
  return max_valid_stop_distance_;
}
inline void StopSignConfig::set_max_valid_stop_distance(double value) {
  set_has_max_valid_stop_distance();
  max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignConfig.max_valid_stop_distance)
}

// optional double stop_duration = 5 [default = 1];
inline bool StopSignConfig::has_stop_duration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StopSignConfig::set_has_stop_duration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StopSignConfig::clear_has_stop_duration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StopSignConfig::clear_stop_duration() {
  stop_duration_ = 1;
  clear_has_stop_duration();
}
inline double StopSignConfig::stop_duration() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignConfig.stop_duration)
  return stop_duration_;
}
inline void StopSignConfig::set_stop_duration(double value) {
  set_has_stop_duration();
  stop_duration_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignConfig.stop_duration)
}

// optional double watch_vehicle_max_valid_stop_speed = 6 [default = 0.5];
inline bool StopSignConfig::has_watch_vehicle_max_valid_stop_speed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StopSignConfig::set_has_watch_vehicle_max_valid_stop_speed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StopSignConfig::clear_has_watch_vehicle_max_valid_stop_speed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StopSignConfig::clear_watch_vehicle_max_valid_stop_speed() {
  watch_vehicle_max_valid_stop_speed_ = 0.5;
  clear_has_watch_vehicle_max_valid_stop_speed();
}
inline double StopSignConfig::watch_vehicle_max_valid_stop_speed() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignConfig.watch_vehicle_max_valid_stop_speed)
  return watch_vehicle_max_valid_stop_speed_;
}
inline void StopSignConfig::set_watch_vehicle_max_valid_stop_speed(double value) {
  set_has_watch_vehicle_max_valid_stop_speed();
  watch_vehicle_max_valid_stop_speed_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignConfig.watch_vehicle_max_valid_stop_speed)
}

// optional double watch_vehicle_max_valid_stop_distance = 7 [default = 5];
inline bool StopSignConfig::has_watch_vehicle_max_valid_stop_distance() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StopSignConfig::set_has_watch_vehicle_max_valid_stop_distance() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StopSignConfig::clear_has_watch_vehicle_max_valid_stop_distance() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StopSignConfig::clear_watch_vehicle_max_valid_stop_distance() {
  watch_vehicle_max_valid_stop_distance_ = 5;
  clear_has_watch_vehicle_max_valid_stop_distance();
}
inline double StopSignConfig::watch_vehicle_max_valid_stop_distance() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignConfig.watch_vehicle_max_valid_stop_distance)
  return watch_vehicle_max_valid_stop_distance_;
}
inline void StopSignConfig::set_watch_vehicle_max_valid_stop_distance(double value) {
  set_has_watch_vehicle_max_valid_stop_distance();
  watch_vehicle_max_valid_stop_distance_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignConfig.watch_vehicle_max_valid_stop_distance)
}

// optional double wait_timeout = 8 [default = 8];
inline bool StopSignConfig::has_wait_timeout() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StopSignConfig::set_has_wait_timeout() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StopSignConfig::clear_has_wait_timeout() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StopSignConfig::clear_wait_timeout() {
  wait_timeout_ = 8;
  clear_has_wait_timeout();
}
inline double StopSignConfig::wait_timeout() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignConfig.wait_timeout)
  return wait_timeout_;
}
inline void StopSignConfig::set_wait_timeout(double value) {
  set_has_wait_timeout();
  wait_timeout_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignConfig.wait_timeout)
}

// optional .apollo.planning.CreepConfig creep = 9;
inline bool StopSignConfig::has_creep() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void StopSignConfig::set_has_creep() {
  _has_bits_[0] |= 0x00000100u;
}
inline void StopSignConfig::clear_has_creep() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void StopSignConfig::clear_creep() {
  if (creep_ != NULL) creep_->::apollo::planning::CreepConfig::Clear();
  clear_has_creep();
}
inline const ::apollo::planning::CreepConfig& StopSignConfig::creep() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignConfig.creep)
  return creep_ != NULL ? *creep_ : *default_instance_->creep_;
}
inline ::apollo::planning::CreepConfig* StopSignConfig::mutable_creep() {
  set_has_creep();
  if (creep_ == NULL) {
    creep_ = new ::apollo::planning::CreepConfig;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.StopSignConfig.creep)
  return creep_;
}
inline ::apollo::planning::CreepConfig* StopSignConfig::release_creep() {
  // @@protoc_insertion_point(field_release:apollo.planning.StopSignConfig.creep)
  clear_has_creep();
  ::apollo::planning::CreepConfig* temp = creep_;
  creep_ = NULL;
  return temp;
}
inline void StopSignConfig::set_allocated_creep(::apollo::planning::CreepConfig* creep) {
  delete creep_;
  creep_ = creep;
  if (creep) {
    set_has_creep();
  } else {
    clear_has_creep();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.StopSignConfig.creep)
}

// -------------------------------------------------------------------

// TrafficRuleConfig

// optional .apollo.planning.TrafficRuleConfig.RuleId rule_id = 1;
inline bool TrafficRuleConfig::has_rule_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficRuleConfig::set_has_rule_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficRuleConfig::clear_has_rule_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficRuleConfig::clear_rule_id() {
  rule_id_ = 1;
  clear_has_rule_id();
}
inline ::apollo::planning::TrafficRuleConfig_RuleId TrafficRuleConfig::rule_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.rule_id)
  return static_cast< ::apollo::planning::TrafficRuleConfig_RuleId >(rule_id_);
}
inline void TrafficRuleConfig::set_rule_id(::apollo::planning::TrafficRuleConfig_RuleId value) {
  assert(::apollo::planning::TrafficRuleConfig_RuleId_IsValid(value));
  set_has_rule_id();
  rule_id_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficRuleConfig.rule_id)
}

// optional bool enabled = 2;
inline bool TrafficRuleConfig::has_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficRuleConfig::set_has_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficRuleConfig::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficRuleConfig::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool TrafficRuleConfig::enabled() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.enabled)
  return enabled_;
}
inline void TrafficRuleConfig::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.TrafficRuleConfig.enabled)
}

// optional .apollo.planning.BacksideVehicleConfig backside_vehicle = 3;
inline bool TrafficRuleConfig::has_backside_vehicle() const {
  return config_case() == kBacksideVehicle;
}
inline void TrafficRuleConfig::set_has_backside_vehicle() {
  _oneof_case_[0] = kBacksideVehicle;
}
inline void TrafficRuleConfig::clear_backside_vehicle() {
  if (has_backside_vehicle()) {
    delete config_.backside_vehicle_;
    clear_has_config();
  }
}
inline  const ::apollo::planning::BacksideVehicleConfig& TrafficRuleConfig::backside_vehicle() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.backside_vehicle)
  return has_backside_vehicle()
      ? *config_.backside_vehicle_
      : ::apollo::planning::BacksideVehicleConfig::default_instance();
}
inline ::apollo::planning::BacksideVehicleConfig* TrafficRuleConfig::mutable_backside_vehicle() {
  if (!has_backside_vehicle()) {
    clear_config();
    set_has_backside_vehicle();
    config_.backside_vehicle_ = new ::apollo::planning::BacksideVehicleConfig;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.backside_vehicle)
  return config_.backside_vehicle_;
}
inline ::apollo::planning::BacksideVehicleConfig* TrafficRuleConfig::release_backside_vehicle() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.backside_vehicle)
  if (has_backside_vehicle()) {
    clear_has_config();
    ::apollo::planning::BacksideVehicleConfig* temp = config_.backside_vehicle_;
    config_.backside_vehicle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TrafficRuleConfig::set_allocated_backside_vehicle(::apollo::planning::BacksideVehicleConfig* backside_vehicle) {
  clear_config();
  if (backside_vehicle) {
    set_has_backside_vehicle();
    config_.backside_vehicle_ = backside_vehicle;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrafficRuleConfig.backside_vehicle)
}

// optional .apollo.planning.ChangeLaneConfig change_lane = 4;
inline bool TrafficRuleConfig::has_change_lane() const {
  return config_case() == kChangeLane;
}
inline void TrafficRuleConfig::set_has_change_lane() {
  _oneof_case_[0] = kChangeLane;
}
inline void TrafficRuleConfig::clear_change_lane() {
  if (has_change_lane()) {
    delete config_.change_lane_;
    clear_has_config();
  }
}
inline  const ::apollo::planning::ChangeLaneConfig& TrafficRuleConfig::change_lane() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.change_lane)
  return has_change_lane()
      ? *config_.change_lane_
      : ::apollo::planning::ChangeLaneConfig::default_instance();
}
inline ::apollo::planning::ChangeLaneConfig* TrafficRuleConfig::mutable_change_lane() {
  if (!has_change_lane()) {
    clear_config();
    set_has_change_lane();
    config_.change_lane_ = new ::apollo::planning::ChangeLaneConfig;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.change_lane)
  return config_.change_lane_;
}
inline ::apollo::planning::ChangeLaneConfig* TrafficRuleConfig::release_change_lane() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.change_lane)
  if (has_change_lane()) {
    clear_has_config();
    ::apollo::planning::ChangeLaneConfig* temp = config_.change_lane_;
    config_.change_lane_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TrafficRuleConfig::set_allocated_change_lane(::apollo::planning::ChangeLaneConfig* change_lane) {
  clear_config();
  if (change_lane) {
    set_has_change_lane();
    config_.change_lane_ = change_lane;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrafficRuleConfig.change_lane)
}

// optional .apollo.planning.CrosswalkConfig crosswalk = 5;
inline bool TrafficRuleConfig::has_crosswalk() const {
  return config_case() == kCrosswalk;
}
inline void TrafficRuleConfig::set_has_crosswalk() {
  _oneof_case_[0] = kCrosswalk;
}
inline void TrafficRuleConfig::clear_crosswalk() {
  if (has_crosswalk()) {
    delete config_.crosswalk_;
    clear_has_config();
  }
}
inline  const ::apollo::planning::CrosswalkConfig& TrafficRuleConfig::crosswalk() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.crosswalk)
  return has_crosswalk()
      ? *config_.crosswalk_
      : ::apollo::planning::CrosswalkConfig::default_instance();
}
inline ::apollo::planning::CrosswalkConfig* TrafficRuleConfig::mutable_crosswalk() {
  if (!has_crosswalk()) {
    clear_config();
    set_has_crosswalk();
    config_.crosswalk_ = new ::apollo::planning::CrosswalkConfig;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.crosswalk)
  return config_.crosswalk_;
}
inline ::apollo::planning::CrosswalkConfig* TrafficRuleConfig::release_crosswalk() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.crosswalk)
  if (has_crosswalk()) {
    clear_has_config();
    ::apollo::planning::CrosswalkConfig* temp = config_.crosswalk_;
    config_.crosswalk_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TrafficRuleConfig::set_allocated_crosswalk(::apollo::planning::CrosswalkConfig* crosswalk) {
  clear_config();
  if (crosswalk) {
    set_has_crosswalk();
    config_.crosswalk_ = crosswalk;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrafficRuleConfig.crosswalk)
}

// optional .apollo.planning.DestinationConfig destination = 6;
inline bool TrafficRuleConfig::has_destination() const {
  return config_case() == kDestination;
}
inline void TrafficRuleConfig::set_has_destination() {
  _oneof_case_[0] = kDestination;
}
inline void TrafficRuleConfig::clear_destination() {
  if (has_destination()) {
    delete config_.destination_;
    clear_has_config();
  }
}
inline  const ::apollo::planning::DestinationConfig& TrafficRuleConfig::destination() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.destination)
  return has_destination()
      ? *config_.destination_
      : ::apollo::planning::DestinationConfig::default_instance();
}
inline ::apollo::planning::DestinationConfig* TrafficRuleConfig::mutable_destination() {
  if (!has_destination()) {
    clear_config();
    set_has_destination();
    config_.destination_ = new ::apollo::planning::DestinationConfig;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.destination)
  return config_.destination_;
}
inline ::apollo::planning::DestinationConfig* TrafficRuleConfig::release_destination() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.destination)
  if (has_destination()) {
    clear_has_config();
    ::apollo::planning::DestinationConfig* temp = config_.destination_;
    config_.destination_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TrafficRuleConfig::set_allocated_destination(::apollo::planning::DestinationConfig* destination) {
  clear_config();
  if (destination) {
    set_has_destination();
    config_.destination_ = destination;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrafficRuleConfig.destination)
}

// optional .apollo.planning.FrontVehicleConfig front_vehicle = 7;
inline bool TrafficRuleConfig::has_front_vehicle() const {
  return config_case() == kFrontVehicle;
}
inline void TrafficRuleConfig::set_has_front_vehicle() {
  _oneof_case_[0] = kFrontVehicle;
}
inline void TrafficRuleConfig::clear_front_vehicle() {
  if (has_front_vehicle()) {
    delete config_.front_vehicle_;
    clear_has_config();
  }
}
inline  const ::apollo::planning::FrontVehicleConfig& TrafficRuleConfig::front_vehicle() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.front_vehicle)
  return has_front_vehicle()
      ? *config_.front_vehicle_
      : ::apollo::planning::FrontVehicleConfig::default_instance();
}
inline ::apollo::planning::FrontVehicleConfig* TrafficRuleConfig::mutable_front_vehicle() {
  if (!has_front_vehicle()) {
    clear_config();
    set_has_front_vehicle();
    config_.front_vehicle_ = new ::apollo::planning::FrontVehicleConfig;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.front_vehicle)
  return config_.front_vehicle_;
}
inline ::apollo::planning::FrontVehicleConfig* TrafficRuleConfig::release_front_vehicle() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.front_vehicle)
  if (has_front_vehicle()) {
    clear_has_config();
    ::apollo::planning::FrontVehicleConfig* temp = config_.front_vehicle_;
    config_.front_vehicle_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TrafficRuleConfig::set_allocated_front_vehicle(::apollo::planning::FrontVehicleConfig* front_vehicle) {
  clear_config();
  if (front_vehicle) {
    set_has_front_vehicle();
    config_.front_vehicle_ = front_vehicle;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrafficRuleConfig.front_vehicle)
}

// optional .apollo.planning.KeepClearConfig keep_clear = 8;
inline bool TrafficRuleConfig::has_keep_clear() const {
  return config_case() == kKeepClear;
}
inline void TrafficRuleConfig::set_has_keep_clear() {
  _oneof_case_[0] = kKeepClear;
}
inline void TrafficRuleConfig::clear_keep_clear() {
  if (has_keep_clear()) {
    delete config_.keep_clear_;
    clear_has_config();
  }
}
inline  const ::apollo::planning::KeepClearConfig& TrafficRuleConfig::keep_clear() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.keep_clear)
  return has_keep_clear()
      ? *config_.keep_clear_
      : ::apollo::planning::KeepClearConfig::default_instance();
}
inline ::apollo::planning::KeepClearConfig* TrafficRuleConfig::mutable_keep_clear() {
  if (!has_keep_clear()) {
    clear_config();
    set_has_keep_clear();
    config_.keep_clear_ = new ::apollo::planning::KeepClearConfig;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.keep_clear)
  return config_.keep_clear_;
}
inline ::apollo::planning::KeepClearConfig* TrafficRuleConfig::release_keep_clear() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.keep_clear)
  if (has_keep_clear()) {
    clear_has_config();
    ::apollo::planning::KeepClearConfig* temp = config_.keep_clear_;
    config_.keep_clear_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TrafficRuleConfig::set_allocated_keep_clear(::apollo::planning::KeepClearConfig* keep_clear) {
  clear_config();
  if (keep_clear) {
    set_has_keep_clear();
    config_.keep_clear_ = keep_clear;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrafficRuleConfig.keep_clear)
}

// optional .apollo.planning.PullOverConfig pull_over = 9;
inline bool TrafficRuleConfig::has_pull_over() const {
  return config_case() == kPullOver;
}
inline void TrafficRuleConfig::set_has_pull_over() {
  _oneof_case_[0] = kPullOver;
}
inline void TrafficRuleConfig::clear_pull_over() {
  if (has_pull_over()) {
    delete config_.pull_over_;
    clear_has_config();
  }
}
inline  const ::apollo::planning::PullOverConfig& TrafficRuleConfig::pull_over() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.pull_over)
  return has_pull_over()
      ? *config_.pull_over_
      : ::apollo::planning::PullOverConfig::default_instance();
}
inline ::apollo::planning::PullOverConfig* TrafficRuleConfig::mutable_pull_over() {
  if (!has_pull_over()) {
    clear_config();
    set_has_pull_over();
    config_.pull_over_ = new ::apollo::planning::PullOverConfig;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.pull_over)
  return config_.pull_over_;
}
inline ::apollo::planning::PullOverConfig* TrafficRuleConfig::release_pull_over() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.pull_over)
  if (has_pull_over()) {
    clear_has_config();
    ::apollo::planning::PullOverConfig* temp = config_.pull_over_;
    config_.pull_over_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TrafficRuleConfig::set_allocated_pull_over(::apollo::planning::PullOverConfig* pull_over) {
  clear_config();
  if (pull_over) {
    set_has_pull_over();
    config_.pull_over_ = pull_over;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrafficRuleConfig.pull_over)
}

// optional .apollo.planning.ReferenceLineEndConfig reference_line_end = 10;
inline bool TrafficRuleConfig::has_reference_line_end() const {
  return config_case() == kReferenceLineEnd;
}
inline void TrafficRuleConfig::set_has_reference_line_end() {
  _oneof_case_[0] = kReferenceLineEnd;
}
inline void TrafficRuleConfig::clear_reference_line_end() {
  if (has_reference_line_end()) {
    delete config_.reference_line_end_;
    clear_has_config();
  }
}
inline  const ::apollo::planning::ReferenceLineEndConfig& TrafficRuleConfig::reference_line_end() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.reference_line_end)
  return has_reference_line_end()
      ? *config_.reference_line_end_
      : ::apollo::planning::ReferenceLineEndConfig::default_instance();
}
inline ::apollo::planning::ReferenceLineEndConfig* TrafficRuleConfig::mutable_reference_line_end() {
  if (!has_reference_line_end()) {
    clear_config();
    set_has_reference_line_end();
    config_.reference_line_end_ = new ::apollo::planning::ReferenceLineEndConfig;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.reference_line_end)
  return config_.reference_line_end_;
}
inline ::apollo::planning::ReferenceLineEndConfig* TrafficRuleConfig::release_reference_line_end() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.reference_line_end)
  if (has_reference_line_end()) {
    clear_has_config();
    ::apollo::planning::ReferenceLineEndConfig* temp = config_.reference_line_end_;
    config_.reference_line_end_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TrafficRuleConfig::set_allocated_reference_line_end(::apollo::planning::ReferenceLineEndConfig* reference_line_end) {
  clear_config();
  if (reference_line_end) {
    set_has_reference_line_end();
    config_.reference_line_end_ = reference_line_end;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrafficRuleConfig.reference_line_end)
}

// optional .apollo.planning.ReroutingConfig rerouting = 11;
inline bool TrafficRuleConfig::has_rerouting() const {
  return config_case() == kRerouting;
}
inline void TrafficRuleConfig::set_has_rerouting() {
  _oneof_case_[0] = kRerouting;
}
inline void TrafficRuleConfig::clear_rerouting() {
  if (has_rerouting()) {
    delete config_.rerouting_;
    clear_has_config();
  }
}
inline  const ::apollo::planning::ReroutingConfig& TrafficRuleConfig::rerouting() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.rerouting)
  return has_rerouting()
      ? *config_.rerouting_
      : ::apollo::planning::ReroutingConfig::default_instance();
}
inline ::apollo::planning::ReroutingConfig* TrafficRuleConfig::mutable_rerouting() {
  if (!has_rerouting()) {
    clear_config();
    set_has_rerouting();
    config_.rerouting_ = new ::apollo::planning::ReroutingConfig;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.rerouting)
  return config_.rerouting_;
}
inline ::apollo::planning::ReroutingConfig* TrafficRuleConfig::release_rerouting() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.rerouting)
  if (has_rerouting()) {
    clear_has_config();
    ::apollo::planning::ReroutingConfig* temp = config_.rerouting_;
    config_.rerouting_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TrafficRuleConfig::set_allocated_rerouting(::apollo::planning::ReroutingConfig* rerouting) {
  clear_config();
  if (rerouting) {
    set_has_rerouting();
    config_.rerouting_ = rerouting;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrafficRuleConfig.rerouting)
}

// optional .apollo.planning.SignalLightConfig signal_light = 12;
inline bool TrafficRuleConfig::has_signal_light() const {
  return config_case() == kSignalLight;
}
inline void TrafficRuleConfig::set_has_signal_light() {
  _oneof_case_[0] = kSignalLight;
}
inline void TrafficRuleConfig::clear_signal_light() {
  if (has_signal_light()) {
    delete config_.signal_light_;
    clear_has_config();
  }
}
inline  const ::apollo::planning::SignalLightConfig& TrafficRuleConfig::signal_light() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.signal_light)
  return has_signal_light()
      ? *config_.signal_light_
      : ::apollo::planning::SignalLightConfig::default_instance();
}
inline ::apollo::planning::SignalLightConfig* TrafficRuleConfig::mutable_signal_light() {
  if (!has_signal_light()) {
    clear_config();
    set_has_signal_light();
    config_.signal_light_ = new ::apollo::planning::SignalLightConfig;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.signal_light)
  return config_.signal_light_;
}
inline ::apollo::planning::SignalLightConfig* TrafficRuleConfig::release_signal_light() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.signal_light)
  if (has_signal_light()) {
    clear_has_config();
    ::apollo::planning::SignalLightConfig* temp = config_.signal_light_;
    config_.signal_light_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TrafficRuleConfig::set_allocated_signal_light(::apollo::planning::SignalLightConfig* signal_light) {
  clear_config();
  if (signal_light) {
    set_has_signal_light();
    config_.signal_light_ = signal_light;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrafficRuleConfig.signal_light)
}

// optional .apollo.planning.StopSignConfig stop_sign = 13;
inline bool TrafficRuleConfig::has_stop_sign() const {
  return config_case() == kStopSign;
}
inline void TrafficRuleConfig::set_has_stop_sign() {
  _oneof_case_[0] = kStopSign;
}
inline void TrafficRuleConfig::clear_stop_sign() {
  if (has_stop_sign()) {
    delete config_.stop_sign_;
    clear_has_config();
  }
}
inline  const ::apollo::planning::StopSignConfig& TrafficRuleConfig::stop_sign() const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfig.stop_sign)
  return has_stop_sign()
      ? *config_.stop_sign_
      : ::apollo::planning::StopSignConfig::default_instance();
}
inline ::apollo::planning::StopSignConfig* TrafficRuleConfig::mutable_stop_sign() {
  if (!has_stop_sign()) {
    clear_config();
    set_has_stop_sign();
    config_.stop_sign_ = new ::apollo::planning::StopSignConfig;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfig.stop_sign)
  return config_.stop_sign_;
}
inline ::apollo::planning::StopSignConfig* TrafficRuleConfig::release_stop_sign() {
  // @@protoc_insertion_point(field_release:apollo.planning.TrafficRuleConfig.stop_sign)
  if (has_stop_sign()) {
    clear_has_config();
    ::apollo::planning::StopSignConfig* temp = config_.stop_sign_;
    config_.stop_sign_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void TrafficRuleConfig::set_allocated_stop_sign(::apollo::planning::StopSignConfig* stop_sign) {
  clear_config();
  if (stop_sign) {
    set_has_stop_sign();
    config_.stop_sign_ = stop_sign;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.TrafficRuleConfig.stop_sign)
}

inline bool TrafficRuleConfig::has_config() const {
  return config_case() != CONFIG_NOT_SET;
}
inline void TrafficRuleConfig::clear_has_config() {
  _oneof_case_[0] = CONFIG_NOT_SET;
}
inline TrafficRuleConfig::ConfigCase TrafficRuleConfig::config_case() const {
  return TrafficRuleConfig::ConfigCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TrafficRuleConfigs

// repeated .apollo.planning.TrafficRuleConfig config = 1;
inline int TrafficRuleConfigs::config_size() const {
  return config_.size();
}
inline void TrafficRuleConfigs::clear_config() {
  config_.Clear();
}
inline const ::apollo::planning::TrafficRuleConfig& TrafficRuleConfigs::config(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.TrafficRuleConfigs.config)
  return config_.Get(index);
}
inline ::apollo::planning::TrafficRuleConfig* TrafficRuleConfigs::mutable_config(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.TrafficRuleConfigs.config)
  return config_.Mutable(index);
}
inline ::apollo::planning::TrafficRuleConfig* TrafficRuleConfigs::add_config() {
  // @@protoc_insertion_point(field_add:apollo.planning.TrafficRuleConfigs.config)
  return config_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::planning::TrafficRuleConfig >*
TrafficRuleConfigs::mutable_config() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.TrafficRuleConfigs.config)
  return &config_;
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::planning::TrafficRuleConfig >&
TrafficRuleConfigs::config() const {
  // @@protoc_insertion_point(field_list:apollo.planning.TrafficRuleConfigs.config)
  return config_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace planning
}  // namespace apollo

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::apollo::planning::TrafficRuleConfig_RuleId> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::TrafficRuleConfig_RuleId>() {
  return ::apollo::planning::TrafficRuleConfig_RuleId_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_planning_2ftraffic_5frule_5fconfig_2eproto__INCLUDED
