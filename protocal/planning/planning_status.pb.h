// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: planning/planning_status.proto

#ifndef PROTOBUF_planning_2fplanning_5fstatus_2eproto__INCLUDED
#define PROTOBUF_planning_2fplanning_5fstatus_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/map.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "planning/decision.pb.h"
#include "common/drive_state.pb.h"
#include "common/geometry.pb.h"
// @@protoc_insertion_point(includes)

namespace apollo {
namespace planning {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_planning_2fplanning_5fstatus_2eproto();
void protobuf_AssignDesc_planning_2fplanning_5fstatus_2eproto();
void protobuf_ShutdownFile_planning_2fplanning_5fstatus_2eproto();

class ChangeLaneStatus;
class CrosswalkStatus;
class DestinationStatus;
class PlanningStatus;
class PullOverStatus;
class ReroutingStatus;
class RightOfWayStatus;
class SidePassStatus;
class StopSignStatus;
class StopSignStatus_LaneWatchVehicles;
class StopTimer;

enum ChangeLaneStatus_Status {
  ChangeLaneStatus_Status_IN_CHANGE_LANE = 1,
  ChangeLaneStatus_Status_CHANGE_LANE_FAILED = 2,
  ChangeLaneStatus_Status_CHANGE_LANE_SUCCESS = 3
};
bool ChangeLaneStatus_Status_IsValid(int value);
const ChangeLaneStatus_Status ChangeLaneStatus_Status_Status_MIN = ChangeLaneStatus_Status_IN_CHANGE_LANE;
const ChangeLaneStatus_Status ChangeLaneStatus_Status_Status_MAX = ChangeLaneStatus_Status_CHANGE_LANE_SUCCESS;
const int ChangeLaneStatus_Status_Status_ARRAYSIZE = ChangeLaneStatus_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChangeLaneStatus_Status_descriptor();
inline const ::std::string& ChangeLaneStatus_Status_Name(ChangeLaneStatus_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChangeLaneStatus_Status_descriptor(), value);
}
inline bool ChangeLaneStatus_Status_Parse(
    const ::std::string& name, ChangeLaneStatus_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChangeLaneStatus_Status>(
    ChangeLaneStatus_Status_descriptor(), name, value);
}
enum PullOverStatus_Reason {
  PullOverStatus_Reason_DESTINATION = 1
};
bool PullOverStatus_Reason_IsValid(int value);
const PullOverStatus_Reason PullOverStatus_Reason_Reason_MIN = PullOverStatus_Reason_DESTINATION;
const PullOverStatus_Reason PullOverStatus_Reason_Reason_MAX = PullOverStatus_Reason_DESTINATION;
const int PullOverStatus_Reason_Reason_ARRAYSIZE = PullOverStatus_Reason_Reason_MAX + 1;

const ::google::protobuf::EnumDescriptor* PullOverStatus_Reason_descriptor();
inline const ::std::string& PullOverStatus_Reason_Name(PullOverStatus_Reason value) {
  return ::google::protobuf::internal::NameOfEnum(
    PullOverStatus_Reason_descriptor(), value);
}
inline bool PullOverStatus_Reason_Parse(
    const ::std::string& name, PullOverStatus_Reason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PullOverStatus_Reason>(
    PullOverStatus_Reason_descriptor(), name, value);
}
enum PullOverStatus_Status {
  PullOverStatus_Status_UNKNOWN = 1,
  PullOverStatus_Status_IN_OPERATION = 2,
  PullOverStatus_Status_DONE = 3,
  PullOverStatus_Status_DISABLED = 4
};
bool PullOverStatus_Status_IsValid(int value);
const PullOverStatus_Status PullOverStatus_Status_Status_MIN = PullOverStatus_Status_UNKNOWN;
const PullOverStatus_Status PullOverStatus_Status_Status_MAX = PullOverStatus_Status_DISABLED;
const int PullOverStatus_Status_Status_ARRAYSIZE = PullOverStatus_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* PullOverStatus_Status_descriptor();
inline const ::std::string& PullOverStatus_Status_Name(PullOverStatus_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    PullOverStatus_Status_descriptor(), value);
}
inline bool PullOverStatus_Status_Parse(
    const ::std::string& name, PullOverStatus_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PullOverStatus_Status>(
    PullOverStatus_Status_descriptor(), name, value);
}
enum SidePassStatus_Status {
  SidePassStatus_Status_UNKNOWN = 0,
  SidePassStatus_Status_DRIVE = 1,
  SidePassStatus_Status_WAIT = 2,
  SidePassStatus_Status_SIDEPASS = 3
};
bool SidePassStatus_Status_IsValid(int value);
const SidePassStatus_Status SidePassStatus_Status_Status_MIN = SidePassStatus_Status_UNKNOWN;
const SidePassStatus_Status SidePassStatus_Status_Status_MAX = SidePassStatus_Status_SIDEPASS;
const int SidePassStatus_Status_Status_ARRAYSIZE = SidePassStatus_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* SidePassStatus_Status_descriptor();
inline const ::std::string& SidePassStatus_Status_Name(SidePassStatus_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    SidePassStatus_Status_descriptor(), value);
}
inline bool SidePassStatus_Status_Parse(
    const ::std::string& name, SidePassStatus_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SidePassStatus_Status>(
    SidePassStatus_Status_descriptor(), name, value);
}
enum StopSignStatus_Status {
  StopSignStatus_Status_UNKNOWN = 0,
  StopSignStatus_Status_DRIVE = 1,
  StopSignStatus_Status_STOP = 2,
  StopSignStatus_Status_WAIT = 3,
  StopSignStatus_Status_CREEP = 4,
  StopSignStatus_Status_STOP_DONE = 5
};
bool StopSignStatus_Status_IsValid(int value);
const StopSignStatus_Status StopSignStatus_Status_Status_MIN = StopSignStatus_Status_UNKNOWN;
const StopSignStatus_Status StopSignStatus_Status_Status_MAX = StopSignStatus_Status_STOP_DONE;
const int StopSignStatus_Status_Status_ARRAYSIZE = StopSignStatus_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* StopSignStatus_Status_descriptor();
inline const ::std::string& StopSignStatus_Status_Name(StopSignStatus_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    StopSignStatus_Status_descriptor(), value);
}
inline bool StopSignStatus_Status_Parse(
    const ::std::string& name, StopSignStatus_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StopSignStatus_Status>(
    StopSignStatus_Status_descriptor(), name, value);
}
// ===================================================================

class ChangeLaneStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ChangeLaneStatus) */ {
 public:
  ChangeLaneStatus();
  virtual ~ChangeLaneStatus();

  ChangeLaneStatus(const ChangeLaneStatus& from);

  inline ChangeLaneStatus& operator=(const ChangeLaneStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeLaneStatus& default_instance();

  void Swap(ChangeLaneStatus* other);

  // implements Message ----------------------------------------------

  inline ChangeLaneStatus* New() const { return New(NULL); }

  ChangeLaneStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeLaneStatus& from);
  void MergeFrom(const ChangeLaneStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChangeLaneStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ChangeLaneStatus_Status Status;
  static const Status IN_CHANGE_LANE =
    ChangeLaneStatus_Status_IN_CHANGE_LANE;
  static const Status CHANGE_LANE_FAILED =
    ChangeLaneStatus_Status_CHANGE_LANE_FAILED;
  static const Status CHANGE_LANE_SUCCESS =
    ChangeLaneStatus_Status_CHANGE_LANE_SUCCESS;
  static inline bool Status_IsValid(int value) {
    return ChangeLaneStatus_Status_IsValid(value);
  }
  static const Status Status_MIN =
    ChangeLaneStatus_Status_Status_MIN;
  static const Status Status_MAX =
    ChangeLaneStatus_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    ChangeLaneStatus_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return ChangeLaneStatus_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return ChangeLaneStatus_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return ChangeLaneStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .apollo.planning.ChangeLaneStatus.Status status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::apollo::planning::ChangeLaneStatus_Status status() const;
  void set_status(::apollo::planning::ChangeLaneStatus_Status value);

  // optional string path_id = 2;
  bool has_path_id() const;
  void clear_path_id();
  static const int kPathIdFieldNumber = 2;
  const ::std::string& path_id() const;
  void set_path_id(const ::std::string& value);
  void set_path_id(const char* value);
  void set_path_id(const char* value, size_t size);
  ::std::string* mutable_path_id();
  ::std::string* release_path_id();
  void set_allocated_path_id(::std::string* path_id);

  // optional double timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  double timestamp() const;
  void set_timestamp(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.ChangeLaneStatus)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_path_id();
  inline void clear_has_path_id();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr path_id_;
  double timestamp_;
  int status_;
  friend void  protobuf_AddDesc_planning_2fplanning_5fstatus_2eproto();
  friend void protobuf_AssignDesc_planning_2fplanning_5fstatus_2eproto();
  friend void protobuf_ShutdownFile_planning_2fplanning_5fstatus_2eproto();

  void InitAsDefaultInstance();
  static ChangeLaneStatus* default_instance_;
};
// -------------------------------------------------------------------

class StopTimer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.StopTimer) */ {
 public:
  StopTimer();
  virtual ~StopTimer();

  StopTimer(const StopTimer& from);

  inline StopTimer& operator=(const StopTimer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopTimer& default_instance();

  void Swap(StopTimer* other);

  // implements Message ----------------------------------------------

  inline StopTimer* New() const { return New(NULL); }

  StopTimer* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StopTimer& from);
  void MergeFrom(const StopTimer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StopTimer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string obstacle_id = 1;
  bool has_obstacle_id() const;
  void clear_obstacle_id();
  static const int kObstacleIdFieldNumber = 1;
  const ::std::string& obstacle_id() const;
  void set_obstacle_id(const ::std::string& value);
  void set_obstacle_id(const char* value);
  void set_obstacle_id(const char* value, size_t size);
  ::std::string* mutable_obstacle_id();
  ::std::string* release_obstacle_id();
  void set_allocated_obstacle_id(::std::string* obstacle_id);

  // optional double stop_time = 2;
  bool has_stop_time() const;
  void clear_stop_time();
  static const int kStopTimeFieldNumber = 2;
  double stop_time() const;
  void set_stop_time(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.StopTimer)
 private:
  inline void set_has_obstacle_id();
  inline void clear_has_obstacle_id();
  inline void set_has_stop_time();
  inline void clear_has_stop_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr obstacle_id_;
  double stop_time_;
  friend void  protobuf_AddDesc_planning_2fplanning_5fstatus_2eproto();
  friend void protobuf_AssignDesc_planning_2fplanning_5fstatus_2eproto();
  friend void protobuf_ShutdownFile_planning_2fplanning_5fstatus_2eproto();

  void InitAsDefaultInstance();
  static StopTimer* default_instance_;
};
// -------------------------------------------------------------------

class CrosswalkStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.CrosswalkStatus) */ {
 public:
  CrosswalkStatus();
  virtual ~CrosswalkStatus();

  CrosswalkStatus(const CrosswalkStatus& from);

  inline CrosswalkStatus& operator=(const CrosswalkStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CrosswalkStatus& default_instance();

  void Swap(CrosswalkStatus* other);

  // implements Message ----------------------------------------------

  inline CrosswalkStatus* New() const { return New(NULL); }

  CrosswalkStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CrosswalkStatus& from);
  void MergeFrom(const CrosswalkStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CrosswalkStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string crosswalk_id = 1;
  bool has_crosswalk_id() const;
  void clear_crosswalk_id();
  static const int kCrosswalkIdFieldNumber = 1;
  const ::std::string& crosswalk_id() const;
  void set_crosswalk_id(const ::std::string& value);
  void set_crosswalk_id(const char* value);
  void set_crosswalk_id(const char* value, size_t size);
  ::std::string* mutable_crosswalk_id();
  ::std::string* release_crosswalk_id();
  void set_allocated_crosswalk_id(::std::string* crosswalk_id);

  // repeated .apollo.planning.StopTimer stop_timers = 2;
  int stop_timers_size() const;
  void clear_stop_timers();
  static const int kStopTimersFieldNumber = 2;
  const ::apollo::planning::StopTimer& stop_timers(int index) const;
  ::apollo::planning::StopTimer* mutable_stop_timers(int index);
  ::apollo::planning::StopTimer* add_stop_timers();
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::StopTimer >*
      mutable_stop_timers();
  const ::google::protobuf::RepeatedPtrField< ::apollo::planning::StopTimer >&
      stop_timers() const;

  // @@protoc_insertion_point(class_scope:apollo.planning.CrosswalkStatus)
 private:
  inline void set_has_crosswalk_id();
  inline void clear_has_crosswalk_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr crosswalk_id_;
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::StopTimer > stop_timers_;
  friend void  protobuf_AddDesc_planning_2fplanning_5fstatus_2eproto();
  friend void protobuf_AssignDesc_planning_2fplanning_5fstatus_2eproto();
  friend void protobuf_ShutdownFile_planning_2fplanning_5fstatus_2eproto();

  void InitAsDefaultInstance();
  static CrosswalkStatus* default_instance_;
};
// -------------------------------------------------------------------

class PullOverStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PullOverStatus) */ {
 public:
  PullOverStatus();
  virtual ~PullOverStatus();

  PullOverStatus(const PullOverStatus& from);

  inline PullOverStatus& operator=(const PullOverStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PullOverStatus& default_instance();

  void Swap(PullOverStatus* other);

  // implements Message ----------------------------------------------

  inline PullOverStatus* New() const { return New(NULL); }

  PullOverStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PullOverStatus& from);
  void MergeFrom(const PullOverStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PullOverStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PullOverStatus_Reason Reason;
  static const Reason DESTINATION =
    PullOverStatus_Reason_DESTINATION;
  static inline bool Reason_IsValid(int value) {
    return PullOverStatus_Reason_IsValid(value);
  }
  static const Reason Reason_MIN =
    PullOverStatus_Reason_Reason_MIN;
  static const Reason Reason_MAX =
    PullOverStatus_Reason_Reason_MAX;
  static const int Reason_ARRAYSIZE =
    PullOverStatus_Reason_Reason_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Reason_descriptor() {
    return PullOverStatus_Reason_descriptor();
  }
  static inline const ::std::string& Reason_Name(Reason value) {
    return PullOverStatus_Reason_Name(value);
  }
  static inline bool Reason_Parse(const ::std::string& name,
      Reason* value) {
    return PullOverStatus_Reason_Parse(name, value);
  }

  typedef PullOverStatus_Status Status;
  static const Status UNKNOWN =
    PullOverStatus_Status_UNKNOWN;
  static const Status IN_OPERATION =
    PullOverStatus_Status_IN_OPERATION;
  static const Status DONE =
    PullOverStatus_Status_DONE;
  static const Status DISABLED =
    PullOverStatus_Status_DISABLED;
  static inline bool Status_IsValid(int value) {
    return PullOverStatus_Status_IsValid(value);
  }
  static const Status Status_MIN =
    PullOverStatus_Status_Status_MIN;
  static const Status Status_MAX =
    PullOverStatus_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    PullOverStatus_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return PullOverStatus_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return PullOverStatus_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return PullOverStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bool in_pull_over = 1 [default = false];
  bool has_in_pull_over() const;
  void clear_in_pull_over();
  static const int kInPullOverFieldNumber = 1;
  bool in_pull_over() const;
  void set_in_pull_over(bool value);

  // optional .apollo.planning.PullOverStatus.Status status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::apollo::planning::PullOverStatus_Status status() const;
  void set_status(::apollo::planning::PullOverStatus_Status value);

  // optional .apollo.common.PointENU inlane_dest_point = 3;
  bool has_inlane_dest_point() const;
  void clear_inlane_dest_point();
  static const int kInlaneDestPointFieldNumber = 3;
  const ::apollo::common::PointENU& inlane_dest_point() const;
  ::apollo::common::PointENU* mutable_inlane_dest_point();
  ::apollo::common::PointENU* release_inlane_dest_point();
  void set_allocated_inlane_dest_point(::apollo::common::PointENU* inlane_dest_point);

  // optional .apollo.common.PointENU start_point = 4;
  bool has_start_point() const;
  void clear_start_point();
  static const int kStartPointFieldNumber = 4;
  const ::apollo::common::PointENU& start_point() const;
  ::apollo::common::PointENU* mutable_start_point();
  ::apollo::common::PointENU* release_start_point();
  void set_allocated_start_point(::apollo::common::PointENU* start_point);

  // optional .apollo.common.PointENU stop_point = 5;
  bool has_stop_point() const;
  void clear_stop_point();
  static const int kStopPointFieldNumber = 5;
  const ::apollo::common::PointENU& stop_point() const;
  ::apollo::common::PointENU* mutable_stop_point();
  ::apollo::common::PointENU* release_stop_point();
  void set_allocated_stop_point(::apollo::common::PointENU* stop_point);

  // optional double stop_point_heading = 6;
  bool has_stop_point_heading() const;
  void clear_stop_point_heading();
  static const int kStopPointHeadingFieldNumber = 6;
  double stop_point_heading() const;
  void set_stop_point_heading(double value);

  // optional .apollo.planning.PullOverStatus.Reason reason = 7;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 7;
  ::apollo::planning::PullOverStatus_Reason reason() const;
  void set_reason(::apollo::planning::PullOverStatus_Reason value);

  // optional double status_set_time = 8;
  bool has_status_set_time() const;
  void clear_status_set_time();
  static const int kStatusSetTimeFieldNumber = 8;
  double status_set_time() const;
  void set_status_set_time(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.PullOverStatus)
 private:
  inline void set_has_in_pull_over();
  inline void clear_has_in_pull_over();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_inlane_dest_point();
  inline void clear_has_inlane_dest_point();
  inline void set_has_start_point();
  inline void clear_has_start_point();
  inline void set_has_stop_point();
  inline void clear_has_stop_point();
  inline void set_has_stop_point_heading();
  inline void clear_has_stop_point_heading();
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_status_set_time();
  inline void clear_has_status_set_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool in_pull_over_;
  int status_;
  ::apollo::common::PointENU* inlane_dest_point_;
  ::apollo::common::PointENU* start_point_;
  ::apollo::common::PointENU* stop_point_;
  double stop_point_heading_;
  double status_set_time_;
  int reason_;
  friend void  protobuf_AddDesc_planning_2fplanning_5fstatus_2eproto();
  friend void protobuf_AssignDesc_planning_2fplanning_5fstatus_2eproto();
  friend void protobuf_ShutdownFile_planning_2fplanning_5fstatus_2eproto();

  void InitAsDefaultInstance();
  static PullOverStatus* default_instance_;
};
// -------------------------------------------------------------------

class ReroutingStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.ReroutingStatus) */ {
 public:
  ReroutingStatus();
  virtual ~ReroutingStatus();

  ReroutingStatus(const ReroutingStatus& from);

  inline ReroutingStatus& operator=(const ReroutingStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReroutingStatus& default_instance();

  void Swap(ReroutingStatus* other);

  // implements Message ----------------------------------------------

  inline ReroutingStatus* New() const { return New(NULL); }

  ReroutingStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReroutingStatus& from);
  void MergeFrom(const ReroutingStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReroutingStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double last_rerouting_time = 1;
  bool has_last_rerouting_time() const;
  void clear_last_rerouting_time();
  static const int kLastReroutingTimeFieldNumber = 1;
  double last_rerouting_time() const;
  void set_last_rerouting_time(double value);

  // @@protoc_insertion_point(class_scope:apollo.planning.ReroutingStatus)
 private:
  inline void set_has_last_rerouting_time();
  inline void clear_has_last_rerouting_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double last_rerouting_time_;
  friend void  protobuf_AddDesc_planning_2fplanning_5fstatus_2eproto();
  friend void protobuf_AssignDesc_planning_2fplanning_5fstatus_2eproto();
  friend void protobuf_ShutdownFile_planning_2fplanning_5fstatus_2eproto();

  void InitAsDefaultInstance();
  static ReroutingStatus* default_instance_;
};
// -------------------------------------------------------------------

class RightOfWayStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.RightOfWayStatus) */ {
 public:
  RightOfWayStatus();
  virtual ~RightOfWayStatus();

  RightOfWayStatus(const RightOfWayStatus& from);

  inline RightOfWayStatus& operator=(const RightOfWayStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RightOfWayStatus& default_instance();

  void Swap(RightOfWayStatus* other);

  // implements Message ----------------------------------------------

  inline RightOfWayStatus* New() const { return New(NULL); }

  RightOfWayStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RightOfWayStatus& from);
  void MergeFrom(const RightOfWayStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RightOfWayStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, bool> junction = 1;
  int junction_size() const;
  void clear_junction();
  static const int kJunctionFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, bool >&
      junction() const;
  ::google::protobuf::Map< ::std::string, bool >*
      mutable_junction();

  // @@protoc_insertion_point(class_scope:apollo.planning.RightOfWayStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, bool,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BOOL,
      0 >
      RightOfWayStatus_JunctionEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, bool,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_BOOL,
      0 > junction_;
  friend void  protobuf_AddDesc_planning_2fplanning_5fstatus_2eproto();
  friend void protobuf_AssignDesc_planning_2fplanning_5fstatus_2eproto();
  friend void protobuf_ShutdownFile_planning_2fplanning_5fstatus_2eproto();

  void InitAsDefaultInstance();
  static RightOfWayStatus* default_instance_;
};
// -------------------------------------------------------------------

class SidePassStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.SidePassStatus) */ {
 public:
  SidePassStatus();
  virtual ~SidePassStatus();

  SidePassStatus(const SidePassStatus& from);

  inline SidePassStatus& operator=(const SidePassStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SidePassStatus& default_instance();

  void Swap(SidePassStatus* other);

  // implements Message ----------------------------------------------

  inline SidePassStatus* New() const { return New(NULL); }

  SidePassStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SidePassStatus& from);
  void MergeFrom(const SidePassStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SidePassStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef SidePassStatus_Status Status;
  static const Status UNKNOWN =
    SidePassStatus_Status_UNKNOWN;
  static const Status DRIVE =
    SidePassStatus_Status_DRIVE;
  static const Status WAIT =
    SidePassStatus_Status_WAIT;
  static const Status SIDEPASS =
    SidePassStatus_Status_SIDEPASS;
  static inline bool Status_IsValid(int value) {
    return SidePassStatus_Status_IsValid(value);
  }
  static const Status Status_MIN =
    SidePassStatus_Status_Status_MIN;
  static const Status Status_MAX =
    SidePassStatus_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    SidePassStatus_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return SidePassStatus_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return SidePassStatus_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return SidePassStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .apollo.planning.SidePassStatus.Status status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::apollo::planning::SidePassStatus_Status status() const;
  void set_status(::apollo::planning::SidePassStatus_Status value);

  // optional double wait_start_time = 2;
  bool has_wait_start_time() const;
  void clear_wait_start_time();
  static const int kWaitStartTimeFieldNumber = 2;
  double wait_start_time() const;
  void set_wait_start_time(double value);

  // optional string pass_obstacle_id = 3;
  bool has_pass_obstacle_id() const;
  void clear_pass_obstacle_id();
  static const int kPassObstacleIdFieldNumber = 3;
  const ::std::string& pass_obstacle_id() const;
  void set_pass_obstacle_id(const ::std::string& value);
  void set_pass_obstacle_id(const char* value);
  void set_pass_obstacle_id(const char* value, size_t size);
  ::std::string* mutable_pass_obstacle_id();
  ::std::string* release_pass_obstacle_id();
  void set_allocated_pass_obstacle_id(::std::string* pass_obstacle_id);

  // optional .apollo.planning.ObjectSidePass.Type pass_side = 4;
  bool has_pass_side() const;
  void clear_pass_side();
  static const int kPassSideFieldNumber = 4;
  ::apollo::planning::ObjectSidePass_Type pass_side() const;
  void set_pass_side(::apollo::planning::ObjectSidePass_Type value);

  // @@protoc_insertion_point(class_scope:apollo.planning.SidePassStatus)
 private:
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_wait_start_time();
  inline void clear_has_wait_start_time();
  inline void set_has_pass_obstacle_id();
  inline void clear_has_pass_obstacle_id();
  inline void set_has_pass_side();
  inline void clear_has_pass_side();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double wait_start_time_;
  int status_;
  int pass_side_;
  ::google::protobuf::internal::ArenaStringPtr pass_obstacle_id_;
  friend void  protobuf_AddDesc_planning_2fplanning_5fstatus_2eproto();
  friend void protobuf_AssignDesc_planning_2fplanning_5fstatus_2eproto();
  friend void protobuf_ShutdownFile_planning_2fplanning_5fstatus_2eproto();

  void InitAsDefaultInstance();
  static SidePassStatus* default_instance_;
};
// -------------------------------------------------------------------

class StopSignStatus_LaneWatchVehicles : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.StopSignStatus.LaneWatchVehicles) */ {
 public:
  StopSignStatus_LaneWatchVehicles();
  virtual ~StopSignStatus_LaneWatchVehicles();

  StopSignStatus_LaneWatchVehicles(const StopSignStatus_LaneWatchVehicles& from);

  inline StopSignStatus_LaneWatchVehicles& operator=(const StopSignStatus_LaneWatchVehicles& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopSignStatus_LaneWatchVehicles& default_instance();

  void Swap(StopSignStatus_LaneWatchVehicles* other);

  // implements Message ----------------------------------------------

  inline StopSignStatus_LaneWatchVehicles* New() const { return New(NULL); }

  StopSignStatus_LaneWatchVehicles* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StopSignStatus_LaneWatchVehicles& from);
  void MergeFrom(const StopSignStatus_LaneWatchVehicles& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StopSignStatus_LaneWatchVehicles* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string lane_id = 1;
  bool has_lane_id() const;
  void clear_lane_id();
  static const int kLaneIdFieldNumber = 1;
  const ::std::string& lane_id() const;
  void set_lane_id(const ::std::string& value);
  void set_lane_id(const char* value);
  void set_lane_id(const char* value, size_t size);
  ::std::string* mutable_lane_id();
  ::std::string* release_lane_id();
  void set_allocated_lane_id(::std::string* lane_id);

  // repeated string watch_vehicles = 2;
  int watch_vehicles_size() const;
  void clear_watch_vehicles();
  static const int kWatchVehiclesFieldNumber = 2;
  const ::std::string& watch_vehicles(int index) const;
  ::std::string* mutable_watch_vehicles(int index);
  void set_watch_vehicles(int index, const ::std::string& value);
  void set_watch_vehicles(int index, const char* value);
  void set_watch_vehicles(int index, const char* value, size_t size);
  ::std::string* add_watch_vehicles();
  void add_watch_vehicles(const ::std::string& value);
  void add_watch_vehicles(const char* value);
  void add_watch_vehicles(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& watch_vehicles() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_watch_vehicles();

  // @@protoc_insertion_point(class_scope:apollo.planning.StopSignStatus.LaneWatchVehicles)
 private:
  inline void set_has_lane_id();
  inline void clear_has_lane_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr lane_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> watch_vehicles_;
  friend void  protobuf_AddDesc_planning_2fplanning_5fstatus_2eproto();
  friend void protobuf_AssignDesc_planning_2fplanning_5fstatus_2eproto();
  friend void protobuf_ShutdownFile_planning_2fplanning_5fstatus_2eproto();

  void InitAsDefaultInstance();
  static StopSignStatus_LaneWatchVehicles* default_instance_;
};
// -------------------------------------------------------------------

class StopSignStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.StopSignStatus) */ {
 public:
  StopSignStatus();
  virtual ~StopSignStatus();

  StopSignStatus(const StopSignStatus& from);

  inline StopSignStatus& operator=(const StopSignStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopSignStatus& default_instance();

  void Swap(StopSignStatus* other);

  // implements Message ----------------------------------------------

  inline StopSignStatus* New() const { return New(NULL); }

  StopSignStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StopSignStatus& from);
  void MergeFrom(const StopSignStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StopSignStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef StopSignStatus_LaneWatchVehicles LaneWatchVehicles;

  typedef StopSignStatus_Status Status;
  static const Status UNKNOWN =
    StopSignStatus_Status_UNKNOWN;
  static const Status DRIVE =
    StopSignStatus_Status_DRIVE;
  static const Status STOP =
    StopSignStatus_Status_STOP;
  static const Status WAIT =
    StopSignStatus_Status_WAIT;
  static const Status CREEP =
    StopSignStatus_Status_CREEP;
  static const Status STOP_DONE =
    StopSignStatus_Status_STOP_DONE;
  static inline bool Status_IsValid(int value) {
    return StopSignStatus_Status_IsValid(value);
  }
  static const Status Status_MIN =
    StopSignStatus_Status_Status_MIN;
  static const Status Status_MAX =
    StopSignStatus_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    StopSignStatus_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return StopSignStatus_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return StopSignStatus_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return StopSignStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string stop_sign_id = 1;
  bool has_stop_sign_id() const;
  void clear_stop_sign_id();
  static const int kStopSignIdFieldNumber = 1;
  const ::std::string& stop_sign_id() const;
  void set_stop_sign_id(const ::std::string& value);
  void set_stop_sign_id(const char* value);
  void set_stop_sign_id(const char* value, size_t size);
  ::std::string* mutable_stop_sign_id();
  ::std::string* release_stop_sign_id();
  void set_allocated_stop_sign_id(::std::string* stop_sign_id);

  // optional .apollo.planning.StopSignStatus.Status status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::apollo::planning::StopSignStatus_Status status() const;
  void set_status(::apollo::planning::StopSignStatus_Status value);

  // optional double stop_start_time = 3;
  bool has_stop_start_time() const;
  void clear_stop_start_time();
  static const int kStopStartTimeFieldNumber = 3;
  double stop_start_time() const;
  void set_stop_start_time(double value);

  // repeated .apollo.planning.StopSignStatus.LaneWatchVehicles lane_watch_vehicles = 4;
  int lane_watch_vehicles_size() const;
  void clear_lane_watch_vehicles();
  static const int kLaneWatchVehiclesFieldNumber = 4;
  const ::apollo::planning::StopSignStatus_LaneWatchVehicles& lane_watch_vehicles(int index) const;
  ::apollo::planning::StopSignStatus_LaneWatchVehicles* mutable_lane_watch_vehicles(int index);
  ::apollo::planning::StopSignStatus_LaneWatchVehicles* add_lane_watch_vehicles();
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::StopSignStatus_LaneWatchVehicles >*
      mutable_lane_watch_vehicles();
  const ::google::protobuf::RepeatedPtrField< ::apollo::planning::StopSignStatus_LaneWatchVehicles >&
      lane_watch_vehicles() const;

  // @@protoc_insertion_point(class_scope:apollo.planning.StopSignStatus)
 private:
  inline void set_has_stop_sign_id();
  inline void clear_has_stop_sign_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_stop_start_time();
  inline void clear_has_stop_start_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr stop_sign_id_;
  double stop_start_time_;
  ::google::protobuf::RepeatedPtrField< ::apollo::planning::StopSignStatus_LaneWatchVehicles > lane_watch_vehicles_;
  int status_;
  friend void  protobuf_AddDesc_planning_2fplanning_5fstatus_2eproto();
  friend void protobuf_AssignDesc_planning_2fplanning_5fstatus_2eproto();
  friend void protobuf_ShutdownFile_planning_2fplanning_5fstatus_2eproto();

  void InitAsDefaultInstance();
  static StopSignStatus* default_instance_;
};
// -------------------------------------------------------------------

class DestinationStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.DestinationStatus) */ {
 public:
  DestinationStatus();
  virtual ~DestinationStatus();

  DestinationStatus(const DestinationStatus& from);

  inline DestinationStatus& operator=(const DestinationStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DestinationStatus& default_instance();

  void Swap(DestinationStatus* other);

  // implements Message ----------------------------------------------

  inline DestinationStatus* New() const { return New(NULL); }

  DestinationStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DestinationStatus& from);
  void MergeFrom(const DestinationStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DestinationStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool has_passed_destination = 1 [default = false];
  bool has_has_passed_destination() const;
  void clear_has_passed_destination();
  static const int kHasPassedDestinationFieldNumber = 1;
  bool has_passed_destination() const;
  void set_has_passed_destination(bool value);

  // @@protoc_insertion_point(class_scope:apollo.planning.DestinationStatus)
 private:
  inline void set_has_has_passed_destination();
  inline void clear_has_has_passed_destination();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool has_passed_destination_;
  friend void  protobuf_AddDesc_planning_2fplanning_5fstatus_2eproto();
  friend void protobuf_AssignDesc_planning_2fplanning_5fstatus_2eproto();
  friend void protobuf_ShutdownFile_planning_2fplanning_5fstatus_2eproto();

  void InitAsDefaultInstance();
  static DestinationStatus* default_instance_;
};
// -------------------------------------------------------------------

class PlanningStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.planning.PlanningStatus) */ {
 public:
  PlanningStatus();
  virtual ~PlanningStatus();

  PlanningStatus(const PlanningStatus& from);

  inline PlanningStatus& operator=(const PlanningStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlanningStatus& default_instance();

  void Swap(PlanningStatus* other);

  // implements Message ----------------------------------------------

  inline PlanningStatus* New() const { return New(NULL); }

  PlanningStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlanningStatus& from);
  void MergeFrom(const PlanningStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlanningStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .apollo.planning.ChangeLaneStatus change_lane = 1;
  bool has_change_lane() const;
  void clear_change_lane();
  static const int kChangeLaneFieldNumber = 1;
  const ::apollo::planning::ChangeLaneStatus& change_lane() const;
  ::apollo::planning::ChangeLaneStatus* mutable_change_lane();
  ::apollo::planning::ChangeLaneStatus* release_change_lane();
  void set_allocated_change_lane(::apollo::planning::ChangeLaneStatus* change_lane);

  // optional .apollo.planning.CrosswalkStatus crosswalk = 2;
  bool has_crosswalk() const;
  void clear_crosswalk();
  static const int kCrosswalkFieldNumber = 2;
  const ::apollo::planning::CrosswalkStatus& crosswalk() const;
  ::apollo::planning::CrosswalkStatus* mutable_crosswalk();
  ::apollo::planning::CrosswalkStatus* release_crosswalk();
  void set_allocated_crosswalk(::apollo::planning::CrosswalkStatus* crosswalk);

  // optional .apollo.common.EngageAdvice engage_advice = 3;
  bool has_engage_advice() const;
  void clear_engage_advice();
  static const int kEngageAdviceFieldNumber = 3;
  const ::apollo::common::EngageAdvice& engage_advice() const;
  ::apollo::common::EngageAdvice* mutable_engage_advice();
  ::apollo::common::EngageAdvice* release_engage_advice();
  void set_allocated_engage_advice(::apollo::common::EngageAdvice* engage_advice);

  // optional .apollo.planning.ReroutingStatus rerouting = 4;
  bool has_rerouting() const;
  void clear_rerouting();
  static const int kReroutingFieldNumber = 4;
  const ::apollo::planning::ReroutingStatus& rerouting() const;
  ::apollo::planning::ReroutingStatus* mutable_rerouting();
  ::apollo::planning::ReroutingStatus* release_rerouting();
  void set_allocated_rerouting(::apollo::planning::ReroutingStatus* rerouting);

  // optional .apollo.planning.RightOfWayStatus right_of_way = 5;
  bool has_right_of_way() const;
  void clear_right_of_way();
  static const int kRightOfWayFieldNumber = 5;
  const ::apollo::planning::RightOfWayStatus& right_of_way() const;
  ::apollo::planning::RightOfWayStatus* mutable_right_of_way();
  ::apollo::planning::RightOfWayStatus* release_right_of_way();
  void set_allocated_right_of_way(::apollo::planning::RightOfWayStatus* right_of_way);

  // optional .apollo.planning.SidePassStatus side_pass = 6;
  bool has_side_pass() const;
  void clear_side_pass();
  static const int kSidePassFieldNumber = 6;
  const ::apollo::planning::SidePassStatus& side_pass() const;
  ::apollo::planning::SidePassStatus* mutable_side_pass();
  ::apollo::planning::SidePassStatus* release_side_pass();
  void set_allocated_side_pass(::apollo::planning::SidePassStatus* side_pass);

  // optional .apollo.planning.StopSignStatus stop_sign = 7;
  bool has_stop_sign() const;
  void clear_stop_sign();
  static const int kStopSignFieldNumber = 7;
  const ::apollo::planning::StopSignStatus& stop_sign() const;
  ::apollo::planning::StopSignStatus* mutable_stop_sign();
  ::apollo::planning::StopSignStatus* release_stop_sign();
  void set_allocated_stop_sign(::apollo::planning::StopSignStatus* stop_sign);

  // optional .apollo.planning.DestinationStatus destination = 8;
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 8;
  const ::apollo::planning::DestinationStatus& destination() const;
  ::apollo::planning::DestinationStatus* mutable_destination();
  ::apollo::planning::DestinationStatus* release_destination();
  void set_allocated_destination(::apollo::planning::DestinationStatus* destination);

  // optional .apollo.planning.PullOverStatus pull_over = 9;
  bool has_pull_over() const;
  void clear_pull_over();
  static const int kPullOverFieldNumber = 9;
  const ::apollo::planning::PullOverStatus& pull_over() const;
  ::apollo::planning::PullOverStatus* mutable_pull_over();
  ::apollo::planning::PullOverStatus* release_pull_over();
  void set_allocated_pull_over(::apollo::planning::PullOverStatus* pull_over);

  // @@protoc_insertion_point(class_scope:apollo.planning.PlanningStatus)
 private:
  inline void set_has_change_lane();
  inline void clear_has_change_lane();
  inline void set_has_crosswalk();
  inline void clear_has_crosswalk();
  inline void set_has_engage_advice();
  inline void clear_has_engage_advice();
  inline void set_has_rerouting();
  inline void clear_has_rerouting();
  inline void set_has_right_of_way();
  inline void clear_has_right_of_way();
  inline void set_has_side_pass();
  inline void clear_has_side_pass();
  inline void set_has_stop_sign();
  inline void clear_has_stop_sign();
  inline void set_has_destination();
  inline void clear_has_destination();
  inline void set_has_pull_over();
  inline void clear_has_pull_over();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::apollo::planning::ChangeLaneStatus* change_lane_;
  ::apollo::planning::CrosswalkStatus* crosswalk_;
  ::apollo::common::EngageAdvice* engage_advice_;
  ::apollo::planning::ReroutingStatus* rerouting_;
  ::apollo::planning::RightOfWayStatus* right_of_way_;
  ::apollo::planning::SidePassStatus* side_pass_;
  ::apollo::planning::StopSignStatus* stop_sign_;
  ::apollo::planning::DestinationStatus* destination_;
  ::apollo::planning::PullOverStatus* pull_over_;
  friend void  protobuf_AddDesc_planning_2fplanning_5fstatus_2eproto();
  friend void protobuf_AssignDesc_planning_2fplanning_5fstatus_2eproto();
  friend void protobuf_ShutdownFile_planning_2fplanning_5fstatus_2eproto();

  void InitAsDefaultInstance();
  static PlanningStatus* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ChangeLaneStatus

// optional .apollo.planning.ChangeLaneStatus.Status status = 1;
inline bool ChangeLaneStatus::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeLaneStatus::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeLaneStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeLaneStatus::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::apollo::planning::ChangeLaneStatus_Status ChangeLaneStatus::status() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneStatus.status)
  return static_cast< ::apollo::planning::ChangeLaneStatus_Status >(status_);
}
inline void ChangeLaneStatus::set_status(::apollo::planning::ChangeLaneStatus_Status value) {
  assert(::apollo::planning::ChangeLaneStatus_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneStatus.status)
}

// optional string path_id = 2;
inline bool ChangeLaneStatus::has_path_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeLaneStatus::set_has_path_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeLaneStatus::clear_has_path_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeLaneStatus::clear_path_id() {
  path_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path_id();
}
inline const ::std::string& ChangeLaneStatus::path_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneStatus.path_id)
  return path_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChangeLaneStatus::set_path_id(const ::std::string& value) {
  set_has_path_id();
  path_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneStatus.path_id)
}
inline void ChangeLaneStatus::set_path_id(const char* value) {
  set_has_path_id();
  path_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.ChangeLaneStatus.path_id)
}
inline void ChangeLaneStatus::set_path_id(const char* value, size_t size) {
  set_has_path_id();
  path_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.ChangeLaneStatus.path_id)
}
inline ::std::string* ChangeLaneStatus::mutable_path_id() {
  set_has_path_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.ChangeLaneStatus.path_id)
  return path_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ChangeLaneStatus::release_path_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.ChangeLaneStatus.path_id)
  clear_has_path_id();
  return path_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ChangeLaneStatus::set_allocated_path_id(::std::string* path_id) {
  if (path_id != NULL) {
    set_has_path_id();
  } else {
    clear_has_path_id();
  }
  path_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path_id);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.ChangeLaneStatus.path_id)
}

// optional double timestamp = 3;
inline bool ChangeLaneStatus::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangeLaneStatus::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangeLaneStatus::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangeLaneStatus::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
inline double ChangeLaneStatus::timestamp() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ChangeLaneStatus.timestamp)
  return timestamp_;
}
inline void ChangeLaneStatus::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ChangeLaneStatus.timestamp)
}

// -------------------------------------------------------------------

// StopTimer

// optional string obstacle_id = 1;
inline bool StopTimer::has_obstacle_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopTimer::set_has_obstacle_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopTimer::clear_has_obstacle_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopTimer::clear_obstacle_id() {
  obstacle_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_obstacle_id();
}
inline const ::std::string& StopTimer::obstacle_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopTimer.obstacle_id)
  return obstacle_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StopTimer::set_obstacle_id(const ::std::string& value) {
  set_has_obstacle_id();
  obstacle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.planning.StopTimer.obstacle_id)
}
inline void StopTimer::set_obstacle_id(const char* value) {
  set_has_obstacle_id();
  obstacle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.StopTimer.obstacle_id)
}
inline void StopTimer::set_obstacle_id(const char* value, size_t size) {
  set_has_obstacle_id();
  obstacle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.StopTimer.obstacle_id)
}
inline ::std::string* StopTimer::mutable_obstacle_id() {
  set_has_obstacle_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.StopTimer.obstacle_id)
  return obstacle_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StopTimer::release_obstacle_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.StopTimer.obstacle_id)
  clear_has_obstacle_id();
  return obstacle_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StopTimer::set_allocated_obstacle_id(::std::string* obstacle_id) {
  if (obstacle_id != NULL) {
    set_has_obstacle_id();
  } else {
    clear_has_obstacle_id();
  }
  obstacle_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), obstacle_id);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.StopTimer.obstacle_id)
}

// optional double stop_time = 2;
inline bool StopTimer::has_stop_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StopTimer::set_has_stop_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StopTimer::clear_has_stop_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StopTimer::clear_stop_time() {
  stop_time_ = 0;
  clear_has_stop_time();
}
inline double StopTimer::stop_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopTimer.stop_time)
  return stop_time_;
}
inline void StopTimer::set_stop_time(double value) {
  set_has_stop_time();
  stop_time_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.StopTimer.stop_time)
}

// -------------------------------------------------------------------

// CrosswalkStatus

// optional string crosswalk_id = 1;
inline bool CrosswalkStatus::has_crosswalk_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CrosswalkStatus::set_has_crosswalk_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CrosswalkStatus::clear_has_crosswalk_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CrosswalkStatus::clear_crosswalk_id() {
  crosswalk_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_crosswalk_id();
}
inline const ::std::string& CrosswalkStatus::crosswalk_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkStatus.crosswalk_id)
  return crosswalk_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CrosswalkStatus::set_crosswalk_id(const ::std::string& value) {
  set_has_crosswalk_id();
  crosswalk_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.planning.CrosswalkStatus.crosswalk_id)
}
inline void CrosswalkStatus::set_crosswalk_id(const char* value) {
  set_has_crosswalk_id();
  crosswalk_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.CrosswalkStatus.crosswalk_id)
}
inline void CrosswalkStatus::set_crosswalk_id(const char* value, size_t size) {
  set_has_crosswalk_id();
  crosswalk_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.CrosswalkStatus.crosswalk_id)
}
inline ::std::string* CrosswalkStatus::mutable_crosswalk_id() {
  set_has_crosswalk_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.CrosswalkStatus.crosswalk_id)
  return crosswalk_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CrosswalkStatus::release_crosswalk_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.CrosswalkStatus.crosswalk_id)
  clear_has_crosswalk_id();
  return crosswalk_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CrosswalkStatus::set_allocated_crosswalk_id(::std::string* crosswalk_id) {
  if (crosswalk_id != NULL) {
    set_has_crosswalk_id();
  } else {
    clear_has_crosswalk_id();
  }
  crosswalk_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), crosswalk_id);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.CrosswalkStatus.crosswalk_id)
}

// repeated .apollo.planning.StopTimer stop_timers = 2;
inline int CrosswalkStatus::stop_timers_size() const {
  return stop_timers_.size();
}
inline void CrosswalkStatus::clear_stop_timers() {
  stop_timers_.Clear();
}
inline const ::apollo::planning::StopTimer& CrosswalkStatus::stop_timers(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.CrosswalkStatus.stop_timers)
  return stop_timers_.Get(index);
}
inline ::apollo::planning::StopTimer* CrosswalkStatus::mutable_stop_timers(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.CrosswalkStatus.stop_timers)
  return stop_timers_.Mutable(index);
}
inline ::apollo::planning::StopTimer* CrosswalkStatus::add_stop_timers() {
  // @@protoc_insertion_point(field_add:apollo.planning.CrosswalkStatus.stop_timers)
  return stop_timers_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::planning::StopTimer >*
CrosswalkStatus::mutable_stop_timers() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.CrosswalkStatus.stop_timers)
  return &stop_timers_;
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::planning::StopTimer >&
CrosswalkStatus::stop_timers() const {
  // @@protoc_insertion_point(field_list:apollo.planning.CrosswalkStatus.stop_timers)
  return stop_timers_;
}

// -------------------------------------------------------------------

// PullOverStatus

// optional bool in_pull_over = 1 [default = false];
inline bool PullOverStatus::has_in_pull_over() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PullOverStatus::set_has_in_pull_over() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PullOverStatus::clear_has_in_pull_over() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PullOverStatus::clear_in_pull_over() {
  in_pull_over_ = false;
  clear_has_in_pull_over();
}
inline bool PullOverStatus::in_pull_over() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.in_pull_over)
  return in_pull_over_;
}
inline void PullOverStatus::set_in_pull_over(bool value) {
  set_has_in_pull_over();
  in_pull_over_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverStatus.in_pull_over)
}

// optional .apollo.planning.PullOverStatus.Status status = 2;
inline bool PullOverStatus::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PullOverStatus::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PullOverStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PullOverStatus::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::apollo::planning::PullOverStatus_Status PullOverStatus::status() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.status)
  return static_cast< ::apollo::planning::PullOverStatus_Status >(status_);
}
inline void PullOverStatus::set_status(::apollo::planning::PullOverStatus_Status value) {
  assert(::apollo::planning::PullOverStatus_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverStatus.status)
}

// optional .apollo.common.PointENU inlane_dest_point = 3;
inline bool PullOverStatus::has_inlane_dest_point() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PullOverStatus::set_has_inlane_dest_point() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PullOverStatus::clear_has_inlane_dest_point() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PullOverStatus::clear_inlane_dest_point() {
  if (inlane_dest_point_ != NULL) inlane_dest_point_->::apollo::common::PointENU::Clear();
  clear_has_inlane_dest_point();
}
inline const ::apollo::common::PointENU& PullOverStatus::inlane_dest_point() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.inlane_dest_point)
  return inlane_dest_point_ != NULL ? *inlane_dest_point_ : *default_instance_->inlane_dest_point_;
}
inline ::apollo::common::PointENU* PullOverStatus::mutable_inlane_dest_point() {
  set_has_inlane_dest_point();
  if (inlane_dest_point_ == NULL) {
    inlane_dest_point_ = new ::apollo::common::PointENU;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PullOverStatus.inlane_dest_point)
  return inlane_dest_point_;
}
inline ::apollo::common::PointENU* PullOverStatus::release_inlane_dest_point() {
  // @@protoc_insertion_point(field_release:apollo.planning.PullOverStatus.inlane_dest_point)
  clear_has_inlane_dest_point();
  ::apollo::common::PointENU* temp = inlane_dest_point_;
  inlane_dest_point_ = NULL;
  return temp;
}
inline void PullOverStatus::set_allocated_inlane_dest_point(::apollo::common::PointENU* inlane_dest_point) {
  delete inlane_dest_point_;
  inlane_dest_point_ = inlane_dest_point;
  if (inlane_dest_point) {
    set_has_inlane_dest_point();
  } else {
    clear_has_inlane_dest_point();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PullOverStatus.inlane_dest_point)
}

// optional .apollo.common.PointENU start_point = 4;
inline bool PullOverStatus::has_start_point() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PullOverStatus::set_has_start_point() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PullOverStatus::clear_has_start_point() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PullOverStatus::clear_start_point() {
  if (start_point_ != NULL) start_point_->::apollo::common::PointENU::Clear();
  clear_has_start_point();
}
inline const ::apollo::common::PointENU& PullOverStatus::start_point() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.start_point)
  return start_point_ != NULL ? *start_point_ : *default_instance_->start_point_;
}
inline ::apollo::common::PointENU* PullOverStatus::mutable_start_point() {
  set_has_start_point();
  if (start_point_ == NULL) {
    start_point_ = new ::apollo::common::PointENU;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PullOverStatus.start_point)
  return start_point_;
}
inline ::apollo::common::PointENU* PullOverStatus::release_start_point() {
  // @@protoc_insertion_point(field_release:apollo.planning.PullOverStatus.start_point)
  clear_has_start_point();
  ::apollo::common::PointENU* temp = start_point_;
  start_point_ = NULL;
  return temp;
}
inline void PullOverStatus::set_allocated_start_point(::apollo::common::PointENU* start_point) {
  delete start_point_;
  start_point_ = start_point;
  if (start_point) {
    set_has_start_point();
  } else {
    clear_has_start_point();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PullOverStatus.start_point)
}

// optional .apollo.common.PointENU stop_point = 5;
inline bool PullOverStatus::has_stop_point() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PullOverStatus::set_has_stop_point() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PullOverStatus::clear_has_stop_point() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PullOverStatus::clear_stop_point() {
  if (stop_point_ != NULL) stop_point_->::apollo::common::PointENU::Clear();
  clear_has_stop_point();
}
inline const ::apollo::common::PointENU& PullOverStatus::stop_point() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.stop_point)
  return stop_point_ != NULL ? *stop_point_ : *default_instance_->stop_point_;
}
inline ::apollo::common::PointENU* PullOverStatus::mutable_stop_point() {
  set_has_stop_point();
  if (stop_point_ == NULL) {
    stop_point_ = new ::apollo::common::PointENU;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PullOverStatus.stop_point)
  return stop_point_;
}
inline ::apollo::common::PointENU* PullOverStatus::release_stop_point() {
  // @@protoc_insertion_point(field_release:apollo.planning.PullOverStatus.stop_point)
  clear_has_stop_point();
  ::apollo::common::PointENU* temp = stop_point_;
  stop_point_ = NULL;
  return temp;
}
inline void PullOverStatus::set_allocated_stop_point(::apollo::common::PointENU* stop_point) {
  delete stop_point_;
  stop_point_ = stop_point;
  if (stop_point) {
    set_has_stop_point();
  } else {
    clear_has_stop_point();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PullOverStatus.stop_point)
}

// optional double stop_point_heading = 6;
inline bool PullOverStatus::has_stop_point_heading() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PullOverStatus::set_has_stop_point_heading() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PullOverStatus::clear_has_stop_point_heading() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PullOverStatus::clear_stop_point_heading() {
  stop_point_heading_ = 0;
  clear_has_stop_point_heading();
}
inline double PullOverStatus::stop_point_heading() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.stop_point_heading)
  return stop_point_heading_;
}
inline void PullOverStatus::set_stop_point_heading(double value) {
  set_has_stop_point_heading();
  stop_point_heading_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverStatus.stop_point_heading)
}

// optional .apollo.planning.PullOverStatus.Reason reason = 7;
inline bool PullOverStatus::has_reason() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PullOverStatus::set_has_reason() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PullOverStatus::clear_has_reason() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PullOverStatus::clear_reason() {
  reason_ = 1;
  clear_has_reason();
}
inline ::apollo::planning::PullOverStatus_Reason PullOverStatus::reason() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.reason)
  return static_cast< ::apollo::planning::PullOverStatus_Reason >(reason_);
}
inline void PullOverStatus::set_reason(::apollo::planning::PullOverStatus_Reason value) {
  assert(::apollo::planning::PullOverStatus_Reason_IsValid(value));
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverStatus.reason)
}

// optional double status_set_time = 8;
inline bool PullOverStatus::has_status_set_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PullOverStatus::set_has_status_set_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PullOverStatus::clear_has_status_set_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PullOverStatus::clear_status_set_time() {
  status_set_time_ = 0;
  clear_has_status_set_time();
}
inline double PullOverStatus::status_set_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PullOverStatus.status_set_time)
  return status_set_time_;
}
inline void PullOverStatus::set_status_set_time(double value) {
  set_has_status_set_time();
  status_set_time_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.PullOverStatus.status_set_time)
}

// -------------------------------------------------------------------

// ReroutingStatus

// optional double last_rerouting_time = 1;
inline bool ReroutingStatus::has_last_rerouting_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReroutingStatus::set_has_last_rerouting_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReroutingStatus::clear_has_last_rerouting_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReroutingStatus::clear_last_rerouting_time() {
  last_rerouting_time_ = 0;
  clear_has_last_rerouting_time();
}
inline double ReroutingStatus::last_rerouting_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.ReroutingStatus.last_rerouting_time)
  return last_rerouting_time_;
}
inline void ReroutingStatus::set_last_rerouting_time(double value) {
  set_has_last_rerouting_time();
  last_rerouting_time_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.ReroutingStatus.last_rerouting_time)
}

// -------------------------------------------------------------------

// RightOfWayStatus

// map<string, bool> junction = 1;
inline int RightOfWayStatus::junction_size() const {
  return junction_.size();
}
inline void RightOfWayStatus::clear_junction() {
  junction_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, bool >&
RightOfWayStatus::junction() const {
  // @@protoc_insertion_point(field_map:apollo.planning.RightOfWayStatus.junction)
  return junction_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, bool >*
RightOfWayStatus::mutable_junction() {
  // @@protoc_insertion_point(field_mutable_map:apollo.planning.RightOfWayStatus.junction)
  return junction_.MutableMap();
}

// -------------------------------------------------------------------

// SidePassStatus

// optional .apollo.planning.SidePassStatus.Status status = 1;
inline bool SidePassStatus::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SidePassStatus::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SidePassStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SidePassStatus::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::apollo::planning::SidePassStatus_Status SidePassStatus::status() const {
  // @@protoc_insertion_point(field_get:apollo.planning.SidePassStatus.status)
  return static_cast< ::apollo::planning::SidePassStatus_Status >(status_);
}
inline void SidePassStatus::set_status(::apollo::planning::SidePassStatus_Status value) {
  assert(::apollo::planning::SidePassStatus_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.SidePassStatus.status)
}

// optional double wait_start_time = 2;
inline bool SidePassStatus::has_wait_start_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SidePassStatus::set_has_wait_start_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SidePassStatus::clear_has_wait_start_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SidePassStatus::clear_wait_start_time() {
  wait_start_time_ = 0;
  clear_has_wait_start_time();
}
inline double SidePassStatus::wait_start_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.SidePassStatus.wait_start_time)
  return wait_start_time_;
}
inline void SidePassStatus::set_wait_start_time(double value) {
  set_has_wait_start_time();
  wait_start_time_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.SidePassStatus.wait_start_time)
}

// optional string pass_obstacle_id = 3;
inline bool SidePassStatus::has_pass_obstacle_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SidePassStatus::set_has_pass_obstacle_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SidePassStatus::clear_has_pass_obstacle_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SidePassStatus::clear_pass_obstacle_id() {
  pass_obstacle_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pass_obstacle_id();
}
inline const ::std::string& SidePassStatus::pass_obstacle_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.SidePassStatus.pass_obstacle_id)
  return pass_obstacle_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SidePassStatus::set_pass_obstacle_id(const ::std::string& value) {
  set_has_pass_obstacle_id();
  pass_obstacle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.planning.SidePassStatus.pass_obstacle_id)
}
inline void SidePassStatus::set_pass_obstacle_id(const char* value) {
  set_has_pass_obstacle_id();
  pass_obstacle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.SidePassStatus.pass_obstacle_id)
}
inline void SidePassStatus::set_pass_obstacle_id(const char* value, size_t size) {
  set_has_pass_obstacle_id();
  pass_obstacle_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.SidePassStatus.pass_obstacle_id)
}
inline ::std::string* SidePassStatus::mutable_pass_obstacle_id() {
  set_has_pass_obstacle_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.SidePassStatus.pass_obstacle_id)
  return pass_obstacle_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SidePassStatus::release_pass_obstacle_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.SidePassStatus.pass_obstacle_id)
  clear_has_pass_obstacle_id();
  return pass_obstacle_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SidePassStatus::set_allocated_pass_obstacle_id(::std::string* pass_obstacle_id) {
  if (pass_obstacle_id != NULL) {
    set_has_pass_obstacle_id();
  } else {
    clear_has_pass_obstacle_id();
  }
  pass_obstacle_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pass_obstacle_id);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.SidePassStatus.pass_obstacle_id)
}

// optional .apollo.planning.ObjectSidePass.Type pass_side = 4;
inline bool SidePassStatus::has_pass_side() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SidePassStatus::set_has_pass_side() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SidePassStatus::clear_has_pass_side() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SidePassStatus::clear_pass_side() {
  pass_side_ = 1;
  clear_has_pass_side();
}
inline ::apollo::planning::ObjectSidePass_Type SidePassStatus::pass_side() const {
  // @@protoc_insertion_point(field_get:apollo.planning.SidePassStatus.pass_side)
  return static_cast< ::apollo::planning::ObjectSidePass_Type >(pass_side_);
}
inline void SidePassStatus::set_pass_side(::apollo::planning::ObjectSidePass_Type value) {
  assert(::apollo::planning::ObjectSidePass_Type_IsValid(value));
  set_has_pass_side();
  pass_side_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.SidePassStatus.pass_side)
}

// -------------------------------------------------------------------

// StopSignStatus_LaneWatchVehicles

// optional string lane_id = 1;
inline bool StopSignStatus_LaneWatchVehicles::has_lane_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopSignStatus_LaneWatchVehicles::set_has_lane_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopSignStatus_LaneWatchVehicles::clear_has_lane_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopSignStatus_LaneWatchVehicles::clear_lane_id() {
  lane_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_lane_id();
}
inline const ::std::string& StopSignStatus_LaneWatchVehicles::lane_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignStatus.LaneWatchVehicles.lane_id)
  return lane_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StopSignStatus_LaneWatchVehicles::set_lane_id(const ::std::string& value) {
  set_has_lane_id();
  lane_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignStatus.LaneWatchVehicles.lane_id)
}
inline void StopSignStatus_LaneWatchVehicles::set_lane_id(const char* value) {
  set_has_lane_id();
  lane_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.StopSignStatus.LaneWatchVehicles.lane_id)
}
inline void StopSignStatus_LaneWatchVehicles::set_lane_id(const char* value, size_t size) {
  set_has_lane_id();
  lane_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.StopSignStatus.LaneWatchVehicles.lane_id)
}
inline ::std::string* StopSignStatus_LaneWatchVehicles::mutable_lane_id() {
  set_has_lane_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.StopSignStatus.LaneWatchVehicles.lane_id)
  return lane_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StopSignStatus_LaneWatchVehicles::release_lane_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.StopSignStatus.LaneWatchVehicles.lane_id)
  clear_has_lane_id();
  return lane_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StopSignStatus_LaneWatchVehicles::set_allocated_lane_id(::std::string* lane_id) {
  if (lane_id != NULL) {
    set_has_lane_id();
  } else {
    clear_has_lane_id();
  }
  lane_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lane_id);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.StopSignStatus.LaneWatchVehicles.lane_id)
}

// repeated string watch_vehicles = 2;
inline int StopSignStatus_LaneWatchVehicles::watch_vehicles_size() const {
  return watch_vehicles_.size();
}
inline void StopSignStatus_LaneWatchVehicles::clear_watch_vehicles() {
  watch_vehicles_.Clear();
}
inline const ::std::string& StopSignStatus_LaneWatchVehicles::watch_vehicles(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignStatus.LaneWatchVehicles.watch_vehicles)
  return watch_vehicles_.Get(index);
}
inline ::std::string* StopSignStatus_LaneWatchVehicles::mutable_watch_vehicles(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.StopSignStatus.LaneWatchVehicles.watch_vehicles)
  return watch_vehicles_.Mutable(index);
}
inline void StopSignStatus_LaneWatchVehicles::set_watch_vehicles(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignStatus.LaneWatchVehicles.watch_vehicles)
  watch_vehicles_.Mutable(index)->assign(value);
}
inline void StopSignStatus_LaneWatchVehicles::set_watch_vehicles(int index, const char* value) {
  watch_vehicles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:apollo.planning.StopSignStatus.LaneWatchVehicles.watch_vehicles)
}
inline void StopSignStatus_LaneWatchVehicles::set_watch_vehicles(int index, const char* value, size_t size) {
  watch_vehicles_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.StopSignStatus.LaneWatchVehicles.watch_vehicles)
}
inline ::std::string* StopSignStatus_LaneWatchVehicles::add_watch_vehicles() {
  // @@protoc_insertion_point(field_add_mutable:apollo.planning.StopSignStatus.LaneWatchVehicles.watch_vehicles)
  return watch_vehicles_.Add();
}
inline void StopSignStatus_LaneWatchVehicles::add_watch_vehicles(const ::std::string& value) {
  watch_vehicles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:apollo.planning.StopSignStatus.LaneWatchVehicles.watch_vehicles)
}
inline void StopSignStatus_LaneWatchVehicles::add_watch_vehicles(const char* value) {
  watch_vehicles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:apollo.planning.StopSignStatus.LaneWatchVehicles.watch_vehicles)
}
inline void StopSignStatus_LaneWatchVehicles::add_watch_vehicles(const char* value, size_t size) {
  watch_vehicles_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:apollo.planning.StopSignStatus.LaneWatchVehicles.watch_vehicles)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StopSignStatus_LaneWatchVehicles::watch_vehicles() const {
  // @@protoc_insertion_point(field_list:apollo.planning.StopSignStatus.LaneWatchVehicles.watch_vehicles)
  return watch_vehicles_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StopSignStatus_LaneWatchVehicles::mutable_watch_vehicles() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.StopSignStatus.LaneWatchVehicles.watch_vehicles)
  return &watch_vehicles_;
}

// -------------------------------------------------------------------

// StopSignStatus

// optional string stop_sign_id = 1;
inline bool StopSignStatus::has_stop_sign_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopSignStatus::set_has_stop_sign_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopSignStatus::clear_has_stop_sign_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopSignStatus::clear_stop_sign_id() {
  stop_sign_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_stop_sign_id();
}
inline const ::std::string& StopSignStatus::stop_sign_id() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignStatus.stop_sign_id)
  return stop_sign_id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StopSignStatus::set_stop_sign_id(const ::std::string& value) {
  set_has_stop_sign_id();
  stop_sign_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignStatus.stop_sign_id)
}
inline void StopSignStatus::set_stop_sign_id(const char* value) {
  set_has_stop_sign_id();
  stop_sign_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:apollo.planning.StopSignStatus.stop_sign_id)
}
inline void StopSignStatus::set_stop_sign_id(const char* value, size_t size) {
  set_has_stop_sign_id();
  stop_sign_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:apollo.planning.StopSignStatus.stop_sign_id)
}
inline ::std::string* StopSignStatus::mutable_stop_sign_id() {
  set_has_stop_sign_id();
  // @@protoc_insertion_point(field_mutable:apollo.planning.StopSignStatus.stop_sign_id)
  return stop_sign_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StopSignStatus::release_stop_sign_id() {
  // @@protoc_insertion_point(field_release:apollo.planning.StopSignStatus.stop_sign_id)
  clear_has_stop_sign_id();
  return stop_sign_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StopSignStatus::set_allocated_stop_sign_id(::std::string* stop_sign_id) {
  if (stop_sign_id != NULL) {
    set_has_stop_sign_id();
  } else {
    clear_has_stop_sign_id();
  }
  stop_sign_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stop_sign_id);
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.StopSignStatus.stop_sign_id)
}

// optional .apollo.planning.StopSignStatus.Status status = 2;
inline bool StopSignStatus::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StopSignStatus::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StopSignStatus::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StopSignStatus::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::apollo::planning::StopSignStatus_Status StopSignStatus::status() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignStatus.status)
  return static_cast< ::apollo::planning::StopSignStatus_Status >(status_);
}
inline void StopSignStatus::set_status(::apollo::planning::StopSignStatus_Status value) {
  assert(::apollo::planning::StopSignStatus_Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignStatus.status)
}

// optional double stop_start_time = 3;
inline bool StopSignStatus::has_stop_start_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StopSignStatus::set_has_stop_start_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StopSignStatus::clear_has_stop_start_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StopSignStatus::clear_stop_start_time() {
  stop_start_time_ = 0;
  clear_has_stop_start_time();
}
inline double StopSignStatus::stop_start_time() const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignStatus.stop_start_time)
  return stop_start_time_;
}
inline void StopSignStatus::set_stop_start_time(double value) {
  set_has_stop_start_time();
  stop_start_time_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.StopSignStatus.stop_start_time)
}

// repeated .apollo.planning.StopSignStatus.LaneWatchVehicles lane_watch_vehicles = 4;
inline int StopSignStatus::lane_watch_vehicles_size() const {
  return lane_watch_vehicles_.size();
}
inline void StopSignStatus::clear_lane_watch_vehicles() {
  lane_watch_vehicles_.Clear();
}
inline const ::apollo::planning::StopSignStatus_LaneWatchVehicles& StopSignStatus::lane_watch_vehicles(int index) const {
  // @@protoc_insertion_point(field_get:apollo.planning.StopSignStatus.lane_watch_vehicles)
  return lane_watch_vehicles_.Get(index);
}
inline ::apollo::planning::StopSignStatus_LaneWatchVehicles* StopSignStatus::mutable_lane_watch_vehicles(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.planning.StopSignStatus.lane_watch_vehicles)
  return lane_watch_vehicles_.Mutable(index);
}
inline ::apollo::planning::StopSignStatus_LaneWatchVehicles* StopSignStatus::add_lane_watch_vehicles() {
  // @@protoc_insertion_point(field_add:apollo.planning.StopSignStatus.lane_watch_vehicles)
  return lane_watch_vehicles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::planning::StopSignStatus_LaneWatchVehicles >*
StopSignStatus::mutable_lane_watch_vehicles() {
  // @@protoc_insertion_point(field_mutable_list:apollo.planning.StopSignStatus.lane_watch_vehicles)
  return &lane_watch_vehicles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::planning::StopSignStatus_LaneWatchVehicles >&
StopSignStatus::lane_watch_vehicles() const {
  // @@protoc_insertion_point(field_list:apollo.planning.StopSignStatus.lane_watch_vehicles)
  return lane_watch_vehicles_;
}

// -------------------------------------------------------------------

// DestinationStatus

// optional bool has_passed_destination = 1 [default = false];
inline bool DestinationStatus::has_has_passed_destination() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DestinationStatus::set_has_has_passed_destination() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DestinationStatus::clear_has_has_passed_destination() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DestinationStatus::clear_has_passed_destination() {
  has_passed_destination_ = false;
  clear_has_has_passed_destination();
}
inline bool DestinationStatus::has_passed_destination() const {
  // @@protoc_insertion_point(field_get:apollo.planning.DestinationStatus.has_passed_destination)
  return has_passed_destination_;
}
inline void DestinationStatus::set_has_passed_destination(bool value) {
  set_has_has_passed_destination();
  has_passed_destination_ = value;
  // @@protoc_insertion_point(field_set:apollo.planning.DestinationStatus.has_passed_destination)
}

// -------------------------------------------------------------------

// PlanningStatus

// optional .apollo.planning.ChangeLaneStatus change_lane = 1;
inline bool PlanningStatus::has_change_lane() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlanningStatus::set_has_change_lane() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlanningStatus::clear_has_change_lane() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlanningStatus::clear_change_lane() {
  if (change_lane_ != NULL) change_lane_->::apollo::planning::ChangeLaneStatus::Clear();
  clear_has_change_lane();
}
inline const ::apollo::planning::ChangeLaneStatus& PlanningStatus::change_lane() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.change_lane)
  return change_lane_ != NULL ? *change_lane_ : *default_instance_->change_lane_;
}
inline ::apollo::planning::ChangeLaneStatus* PlanningStatus::mutable_change_lane() {
  set_has_change_lane();
  if (change_lane_ == NULL) {
    change_lane_ = new ::apollo::planning::ChangeLaneStatus;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.change_lane)
  return change_lane_;
}
inline ::apollo::planning::ChangeLaneStatus* PlanningStatus::release_change_lane() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.change_lane)
  clear_has_change_lane();
  ::apollo::planning::ChangeLaneStatus* temp = change_lane_;
  change_lane_ = NULL;
  return temp;
}
inline void PlanningStatus::set_allocated_change_lane(::apollo::planning::ChangeLaneStatus* change_lane) {
  delete change_lane_;
  change_lane_ = change_lane;
  if (change_lane) {
    set_has_change_lane();
  } else {
    clear_has_change_lane();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.change_lane)
}

// optional .apollo.planning.CrosswalkStatus crosswalk = 2;
inline bool PlanningStatus::has_crosswalk() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlanningStatus::set_has_crosswalk() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlanningStatus::clear_has_crosswalk() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlanningStatus::clear_crosswalk() {
  if (crosswalk_ != NULL) crosswalk_->::apollo::planning::CrosswalkStatus::Clear();
  clear_has_crosswalk();
}
inline const ::apollo::planning::CrosswalkStatus& PlanningStatus::crosswalk() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.crosswalk)
  return crosswalk_ != NULL ? *crosswalk_ : *default_instance_->crosswalk_;
}
inline ::apollo::planning::CrosswalkStatus* PlanningStatus::mutable_crosswalk() {
  set_has_crosswalk();
  if (crosswalk_ == NULL) {
    crosswalk_ = new ::apollo::planning::CrosswalkStatus;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.crosswalk)
  return crosswalk_;
}
inline ::apollo::planning::CrosswalkStatus* PlanningStatus::release_crosswalk() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.crosswalk)
  clear_has_crosswalk();
  ::apollo::planning::CrosswalkStatus* temp = crosswalk_;
  crosswalk_ = NULL;
  return temp;
}
inline void PlanningStatus::set_allocated_crosswalk(::apollo::planning::CrosswalkStatus* crosswalk) {
  delete crosswalk_;
  crosswalk_ = crosswalk;
  if (crosswalk) {
    set_has_crosswalk();
  } else {
    clear_has_crosswalk();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.crosswalk)
}

// optional .apollo.common.EngageAdvice engage_advice = 3;
inline bool PlanningStatus::has_engage_advice() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlanningStatus::set_has_engage_advice() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlanningStatus::clear_has_engage_advice() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlanningStatus::clear_engage_advice() {
  if (engage_advice_ != NULL) engage_advice_->::apollo::common::EngageAdvice::Clear();
  clear_has_engage_advice();
}
inline const ::apollo::common::EngageAdvice& PlanningStatus::engage_advice() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.engage_advice)
  return engage_advice_ != NULL ? *engage_advice_ : *default_instance_->engage_advice_;
}
inline ::apollo::common::EngageAdvice* PlanningStatus::mutable_engage_advice() {
  set_has_engage_advice();
  if (engage_advice_ == NULL) {
    engage_advice_ = new ::apollo::common::EngageAdvice;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.engage_advice)
  return engage_advice_;
}
inline ::apollo::common::EngageAdvice* PlanningStatus::release_engage_advice() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.engage_advice)
  clear_has_engage_advice();
  ::apollo::common::EngageAdvice* temp = engage_advice_;
  engage_advice_ = NULL;
  return temp;
}
inline void PlanningStatus::set_allocated_engage_advice(::apollo::common::EngageAdvice* engage_advice) {
  delete engage_advice_;
  engage_advice_ = engage_advice;
  if (engage_advice) {
    set_has_engage_advice();
  } else {
    clear_has_engage_advice();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.engage_advice)
}

// optional .apollo.planning.ReroutingStatus rerouting = 4;
inline bool PlanningStatus::has_rerouting() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlanningStatus::set_has_rerouting() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlanningStatus::clear_has_rerouting() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlanningStatus::clear_rerouting() {
  if (rerouting_ != NULL) rerouting_->::apollo::planning::ReroutingStatus::Clear();
  clear_has_rerouting();
}
inline const ::apollo::planning::ReroutingStatus& PlanningStatus::rerouting() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.rerouting)
  return rerouting_ != NULL ? *rerouting_ : *default_instance_->rerouting_;
}
inline ::apollo::planning::ReroutingStatus* PlanningStatus::mutable_rerouting() {
  set_has_rerouting();
  if (rerouting_ == NULL) {
    rerouting_ = new ::apollo::planning::ReroutingStatus;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.rerouting)
  return rerouting_;
}
inline ::apollo::planning::ReroutingStatus* PlanningStatus::release_rerouting() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.rerouting)
  clear_has_rerouting();
  ::apollo::planning::ReroutingStatus* temp = rerouting_;
  rerouting_ = NULL;
  return temp;
}
inline void PlanningStatus::set_allocated_rerouting(::apollo::planning::ReroutingStatus* rerouting) {
  delete rerouting_;
  rerouting_ = rerouting;
  if (rerouting) {
    set_has_rerouting();
  } else {
    clear_has_rerouting();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.rerouting)
}

// optional .apollo.planning.RightOfWayStatus right_of_way = 5;
inline bool PlanningStatus::has_right_of_way() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlanningStatus::set_has_right_of_way() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlanningStatus::clear_has_right_of_way() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlanningStatus::clear_right_of_way() {
  if (right_of_way_ != NULL) right_of_way_->::apollo::planning::RightOfWayStatus::Clear();
  clear_has_right_of_way();
}
inline const ::apollo::planning::RightOfWayStatus& PlanningStatus::right_of_way() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.right_of_way)
  return right_of_way_ != NULL ? *right_of_way_ : *default_instance_->right_of_way_;
}
inline ::apollo::planning::RightOfWayStatus* PlanningStatus::mutable_right_of_way() {
  set_has_right_of_way();
  if (right_of_way_ == NULL) {
    right_of_way_ = new ::apollo::planning::RightOfWayStatus;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.right_of_way)
  return right_of_way_;
}
inline ::apollo::planning::RightOfWayStatus* PlanningStatus::release_right_of_way() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.right_of_way)
  clear_has_right_of_way();
  ::apollo::planning::RightOfWayStatus* temp = right_of_way_;
  right_of_way_ = NULL;
  return temp;
}
inline void PlanningStatus::set_allocated_right_of_way(::apollo::planning::RightOfWayStatus* right_of_way) {
  delete right_of_way_;
  right_of_way_ = right_of_way;
  if (right_of_way) {
    set_has_right_of_way();
  } else {
    clear_has_right_of_way();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.right_of_way)
}

// optional .apollo.planning.SidePassStatus side_pass = 6;
inline bool PlanningStatus::has_side_pass() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlanningStatus::set_has_side_pass() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlanningStatus::clear_has_side_pass() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlanningStatus::clear_side_pass() {
  if (side_pass_ != NULL) side_pass_->::apollo::planning::SidePassStatus::Clear();
  clear_has_side_pass();
}
inline const ::apollo::planning::SidePassStatus& PlanningStatus::side_pass() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.side_pass)
  return side_pass_ != NULL ? *side_pass_ : *default_instance_->side_pass_;
}
inline ::apollo::planning::SidePassStatus* PlanningStatus::mutable_side_pass() {
  set_has_side_pass();
  if (side_pass_ == NULL) {
    side_pass_ = new ::apollo::planning::SidePassStatus;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.side_pass)
  return side_pass_;
}
inline ::apollo::planning::SidePassStatus* PlanningStatus::release_side_pass() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.side_pass)
  clear_has_side_pass();
  ::apollo::planning::SidePassStatus* temp = side_pass_;
  side_pass_ = NULL;
  return temp;
}
inline void PlanningStatus::set_allocated_side_pass(::apollo::planning::SidePassStatus* side_pass) {
  delete side_pass_;
  side_pass_ = side_pass;
  if (side_pass) {
    set_has_side_pass();
  } else {
    clear_has_side_pass();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.side_pass)
}

// optional .apollo.planning.StopSignStatus stop_sign = 7;
inline bool PlanningStatus::has_stop_sign() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PlanningStatus::set_has_stop_sign() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PlanningStatus::clear_has_stop_sign() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PlanningStatus::clear_stop_sign() {
  if (stop_sign_ != NULL) stop_sign_->::apollo::planning::StopSignStatus::Clear();
  clear_has_stop_sign();
}
inline const ::apollo::planning::StopSignStatus& PlanningStatus::stop_sign() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.stop_sign)
  return stop_sign_ != NULL ? *stop_sign_ : *default_instance_->stop_sign_;
}
inline ::apollo::planning::StopSignStatus* PlanningStatus::mutable_stop_sign() {
  set_has_stop_sign();
  if (stop_sign_ == NULL) {
    stop_sign_ = new ::apollo::planning::StopSignStatus;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.stop_sign)
  return stop_sign_;
}
inline ::apollo::planning::StopSignStatus* PlanningStatus::release_stop_sign() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.stop_sign)
  clear_has_stop_sign();
  ::apollo::planning::StopSignStatus* temp = stop_sign_;
  stop_sign_ = NULL;
  return temp;
}
inline void PlanningStatus::set_allocated_stop_sign(::apollo::planning::StopSignStatus* stop_sign) {
  delete stop_sign_;
  stop_sign_ = stop_sign;
  if (stop_sign) {
    set_has_stop_sign();
  } else {
    clear_has_stop_sign();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.stop_sign)
}

// optional .apollo.planning.DestinationStatus destination = 8;
inline bool PlanningStatus::has_destination() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PlanningStatus::set_has_destination() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PlanningStatus::clear_has_destination() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PlanningStatus::clear_destination() {
  if (destination_ != NULL) destination_->::apollo::planning::DestinationStatus::Clear();
  clear_has_destination();
}
inline const ::apollo::planning::DestinationStatus& PlanningStatus::destination() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.destination)
  return destination_ != NULL ? *destination_ : *default_instance_->destination_;
}
inline ::apollo::planning::DestinationStatus* PlanningStatus::mutable_destination() {
  set_has_destination();
  if (destination_ == NULL) {
    destination_ = new ::apollo::planning::DestinationStatus;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.destination)
  return destination_;
}
inline ::apollo::planning::DestinationStatus* PlanningStatus::release_destination() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.destination)
  clear_has_destination();
  ::apollo::planning::DestinationStatus* temp = destination_;
  destination_ = NULL;
  return temp;
}
inline void PlanningStatus::set_allocated_destination(::apollo::planning::DestinationStatus* destination) {
  delete destination_;
  destination_ = destination;
  if (destination) {
    set_has_destination();
  } else {
    clear_has_destination();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.destination)
}

// optional .apollo.planning.PullOverStatus pull_over = 9;
inline bool PlanningStatus::has_pull_over() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PlanningStatus::set_has_pull_over() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PlanningStatus::clear_has_pull_over() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PlanningStatus::clear_pull_over() {
  if (pull_over_ != NULL) pull_over_->::apollo::planning::PullOverStatus::Clear();
  clear_has_pull_over();
}
inline const ::apollo::planning::PullOverStatus& PlanningStatus::pull_over() const {
  // @@protoc_insertion_point(field_get:apollo.planning.PlanningStatus.pull_over)
  return pull_over_ != NULL ? *pull_over_ : *default_instance_->pull_over_;
}
inline ::apollo::planning::PullOverStatus* PlanningStatus::mutable_pull_over() {
  set_has_pull_over();
  if (pull_over_ == NULL) {
    pull_over_ = new ::apollo::planning::PullOverStatus;
  }
  // @@protoc_insertion_point(field_mutable:apollo.planning.PlanningStatus.pull_over)
  return pull_over_;
}
inline ::apollo::planning::PullOverStatus* PlanningStatus::release_pull_over() {
  // @@protoc_insertion_point(field_release:apollo.planning.PlanningStatus.pull_over)
  clear_has_pull_over();
  ::apollo::planning::PullOverStatus* temp = pull_over_;
  pull_over_ = NULL;
  return temp;
}
inline void PlanningStatus::set_allocated_pull_over(::apollo::planning::PullOverStatus* pull_over) {
  delete pull_over_;
  pull_over_ = pull_over;
  if (pull_over) {
    set_has_pull_over();
  } else {
    clear_has_pull_over();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.planning.PlanningStatus.pull_over)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace planning
}  // namespace apollo

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::apollo::planning::ChangeLaneStatus_Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::ChangeLaneStatus_Status>() {
  return ::apollo::planning::ChangeLaneStatus_Status_descriptor();
}
template <> struct is_proto_enum< ::apollo::planning::PullOverStatus_Reason> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::PullOverStatus_Reason>() {
  return ::apollo::planning::PullOverStatus_Reason_descriptor();
}
template <> struct is_proto_enum< ::apollo::planning::PullOverStatus_Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::PullOverStatus_Status>() {
  return ::apollo::planning::PullOverStatus_Status_descriptor();
}
template <> struct is_proto_enum< ::apollo::planning::SidePassStatus_Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::SidePassStatus_Status>() {
  return ::apollo::planning::SidePassStatus_Status_descriptor();
}
template <> struct is_proto_enum< ::apollo::planning::StopSignStatus_Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::apollo::planning::StopSignStatus_Status>() {
  return ::apollo::planning::StopSignStatus_Status_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_planning_2fplanning_5fstatus_2eproto__INCLUDED
